{"config":{"lang":["da"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"index.html","title":"Introduktion til kurset","text":""},{"location":"index.html#om-kurset","title":"Om kurset","text":"<p>Dette kursus er baseret p\u00e5 noter krydret med opgaver fordi det format egner sig bedst til kurser relateret til programmering. Materialet er opdelt i moduler som igen best\u00e5r af forskellige sektioner, og hver sektion kan indeholde en masse eksempler, en eller flere videoer for at forklare og vise teorien, samt en eller flere opgaver du du har nemt ved at \u00f8ve dig. Opgaverne skal ikke afleveres og der er altid et forslag til en l\u00f8sning.</p>"},{"location":"index.html#vrktjer","title":"V\u00e6rkt\u00f8jer","text":"<p>Dette kursus er baseret p\u00e5 Visual Studio, og du kan finde en (for private) gratis version der hedder Visual Studio Community Edition. Den kan installeres p\u00e5 Windows og Mac.</p> <p>Der er et helt modul om Visual Studio senere s\u00e5 du kan komme godt igang.</p>"},{"location":"index.html#gode-rad","title":"Gode r\u00e5d","text":"<ul> <li>Kod s\u00e5 meget som overhovedet muligt<ul> <li>Kopier eksempler fra noter til VS (Visual Studio) og pr\u00f8v det selv. V\u00e6r nysgerrig!</li> <li>Lav opgaver<ul> <li>Opgaverne skal ikke afleveres men der er altid en l\u00f8sning</li> <li>Pr\u00f8v at l\u00f8se opgaverne selv - men det er ok at \u201ckopiere\u201d fra l\u00f8sning. Det er dog vigtigt at skrive syntaks med videre selv. Det er gennem fejl man bliver bedre - ogs\u00e5 i programmering. Hvis du kopierer fra l\u00f8sning s\u00e5 kom retur til opgaven senere og pr\u00f8v selv</li> </ul> </li> </ul> </li> </ul>"},{"location":"index.html#om-michell-cronberg","title":"Om Michell Cronberg","text":"<p>Jeg er instruktur p\u00e5 kurser relateret til diverse programmeringssprog (C#, JavaScript og TypeScript) samt webudvikling p\u00e5 blandt andet Teknologisk Institut, samt konsulent og forfatter til diverse b\u00f8ger og artikler.</p>"},{"location":"index.html#kontakt","title":"Kontakt","text":"<ul> <li>Hvis du har problemer med site, videoer eller opgaver s\u00e5 send en mail - michell@cronberg.dk</li> </ul>"},{"location":"010_introcs.html","title":"Introdution til .NET","text":""},{"location":"010_introcs.html#om-modulet","title":"Om modulet","text":"<p>Dette modul vil introducere dig til programmering. Hvis du kender til programmeringssprog mv kan du bare springe det over. Herefter er der en intro til .NET Framework/.NET Core. Sluttelig skal du tage stilling til hvilket udviklingsmilj\u00f8 du vil benytte.</p>"},{"location":"010_introcs.html#formal-med-programmering","title":"Form\u00e5l med programmering","text":"<p>Det overordnede form\u00e5l med programmering er jo, at skabe instruktioner til en CPU (processor). Der er mange forskellige processorer, og mange forskellige arkitekturer (X86, X64, ARM med videre)</p> <p>Her er den gamle 8088 fra 70\u2019erne, den moderne Intel Core 9 og ESP32 (typisk brugt i IoT):</p> <p></p> <p></p> <p></p> <p>En processor best\u00e5r i bund og grund af en stor samling transistorer (elektrisk kontakt), som kombineret i s\u00e5kaldte gates (digitale porte) skaber mulighed for at beregne og opbevare data i en rasende fart.</p> <p>En processor har et instruktionss\u00e6t som - i bund og grund - er bin\u00e6re v\u00e6rdier der \u00e5bner/lukker/t\u00e6nder/slukker for kontrollinjer til de forskellige komponenter i processoren (registrer, beregningsenhed, I/O med videre).</p> <p>Hvis du har lyst kan du se et eksempel p\u00e5 en SAP-CPU (simple as possible CPU) som jeg bruger i andre kurser.</p> <p></p> <p>Her er der et begr\u00e6nset antal kontrollinjer som g\u00f8r det muligt at skrive programmer til \u201cprocessoren\u201d. S\u00e5 bin\u00e6rer instruktioner som:</p> <pre><code>1010 0111 0\n0000 0101 0\n1000 0000 1\n0110 0000 0\n</code></pre> <p>betyder i virkeligheden:</p> <pre><code>Hent til tal fra en adresse i RAM\nL\u00e6g det sammen med sig selv\nPlacer det i RAM igen\n</code></pre> <p>Men i stedet for at p\u00e5virke kontrollinjer direkte med bin\u00e6re koder, er det noget nemmere at f\u00e5 hj\u00e6lp fra en \u201cAssembler\u201d, som egentlig blot overs\u00e6tter \u201cbogstavkoder\u201d til bin\u00e6re v\u00e6rdier (samt tilf\u00f8jer features som blandt variabler):</p> <pre><code>LIA 3\nSTA F\nADD F\nOUTA\nJMP 3\n</code></pre> <p>Koden beregner en tre tabel.</p> <p></p> <p>Se eventuelt mere p\u00e5 devcronberg/sap-cpu - men det er ikke vigtigt for din videre f\u00e6rd ind i C#.</p>"},{"location":"010_introcs.html#maskinkode-binre-instruktioner","title":"Maskinkode / bin\u00e6re instruktioner","text":"<ul> <li>her 16 bit instruktioner:</li> </ul> <pre><code>1100010001000011 0011101001110010\n1000110001110000 1111101110000001\n...\n</code></pre> <ul> <li>der ogs\u00e5 kan skrives som (hex)</li> </ul> <pre><code>C443 3A72\n8C70 FB81\n...\n</code></pre>"},{"location":"010_introcs.html#maskinsprog-assembler","title":"Maskinsprog / Assembler","text":"<p>De bin\u00e6re instruktioner er hvad alt kode i sidste ende bliver til, men det er lidt nemmere at skrive Maskinsprog/Assembler (lavniveau)</p> <ul> <li>Meget t\u00e6t p\u00e5 CPU instruktioner</li> <li>Variabler</li> <li>Flow<ul> <li>Betingelser</li> <li>Jump</li> </ul> </li> </ul> <pre><code>main:\n    mov ax,'00'\n    mov di,counter\n    mov cx,digits+cntDigits/2\n    cld\n    rep stosw\n    inc ax\n    mov [num1 + digits - 1],al\n    mov [num2 + digits - 1],al\n    mov [counter + cntDigits - 1],al\n    jmp .bottom\n</code></pre>"},{"location":"010_introcs.html#hjniveau-sprog","title":"H\u00f8jniveau sprog","text":"<p>Og nemmere at benytte et h\u00f8jniveau sprog (her C#):</p> <pre><code>// Her er en kommentar\nint antal = 3;\nbool skriv = true;\nstring navn = \"mikkel\";\nif (antal &lt; 5)\n{\nfor (int i = 0; i &lt; antal; i++)\n{\nif (skriv)\n{\nConsole.WriteLine(navn);\n}\n}\n}\nelse\n{\nConsole.WriteLine(\"Antal er for stort\");\n}\n</code></pre> <p>Endnu nemmere at bruge visuel programmering som:</p> <ul> <li>MicroBit<ul> <li>IoT (BBC =&gt; folkeskoler)</li> <li>Eksempel</li> </ul> </li> <li>AppInventor<ul> <li>Android (iOS)</li> </ul> </li> </ul>"},{"location":"010_introcs.html#diverse-programmeringssprog","title":"Diverse programmeringssprog","text":"<ul> <li>COBOL fra 1960\u2019erne<ul> <li>Howard Bromberg og flere</li> </ul> </li> <li>BASIC<ul> <li>John George Kemeny og Thomas Eugene Kurtz p\u00e5 Dartmouth College (USA) i starten af 1960\u2019erne</li> </ul> </li> <li>C<ul> <li>Dennis Ritchie (Bell Labs) i starten af 1970\u2019erne</li> </ul> </li> <li>C++<ul> <li>Bjarne Stroustrup (Bell Labs) i starten af 1980\u2019erne</li> </ul> </li> <li>Objective-C<ul> <li>Tom Love og Brad Cox er ogs\u00e5 fra 1980\u2019erne</li> </ul> </li> <li>Java<ul> <li>James Gosling fra Sun Microsystems (nu Oracle) fra 90\u2019erne</li> </ul> </li> <li>JavaScript (som ikke m\u00e5 forveksles med Java)<ul> <li>Brendan Eich (Netscape - senere Mozilla/Firefox) i 1990\u2019erne</li> </ul> </li> <li>C#<ul> <li>Anders Hejlsberg hos Microsoft (2002)</li> </ul> </li> <li>PHP<ul> <li>Rasmus Lerdorf omkring 1995</li> </ul> </li> <li>Delphi<ul> <li>Anders Hejslberg hos Borland i 90\u2019erne</li> </ul> </li> <li>Ruby<ul> <li>Yukihiro Matsumoto i 1995</li> </ul> </li> <li>Python<ul> <li>Guido van Rossum i 1991</li> </ul> </li> <li>Dart<ul> <li>Lars Bak og Kasper Lund</li> </ul> </li> </ul> <p>Se StackOverflow\u2019s survey.</p>"},{"location":"010_introcs.html#oversttelse-af-kode","title":"Overs\u00e6ttelse af kode","text":"<p>Traditionelt overs\u00e6ttes kildekode direkte til eksekverbar kode</p> <p></p> <p>.NET sprog overs\u00e6ttes til IL-kode, som efterf\u00f8lgende af en runtime overs\u00e6ttes til eksekverbar kode</p> <p></p>"},{"location":"010_introcs.html#fra-cnet-til-il-til-asm","title":"Fra C#.NET til IL til ASM","text":"<p>Her er et kort eksempel p\u00e5 kompilering fra C# til IL til ASM (assembler) (skabt ved hj\u00e6lp af https://sharplab.io/)</p> <p>Her er C#-kode:</p> <pre><code>using System;\nnamespace Demo\n{\nclass Program\n{\nstatic void Main(string[] args)\n{\nConsole.WriteLine(\"Program start\");\n// T\u00e6ller fra 1-5\nfor (int i = 1; i &lt; 6; i++)\n{\nVisTal(i);\n}\nConsole.WriteLine(\"Program slut\");\n}\nprivate static void VisTal(int i)\n{\nConsole.WriteLine(i);\n}\n}\n}\n</code></pre> <p>Som konverteres til IL-kode:</p> <pre><code>.class private auto ansi '&lt;Module&gt;'\n{\n} // end of class &lt;Module&gt;\n.class private auto ansi beforefieldinit Demo.Program\nextends [mscorlib]System.Object\n{\n// Methods\n.method private hidebysig static\nvoid Main (\nstring[] args\n) cil managed\n{\n// Method begins at RVA 0x2050\n// Code size 49 (0x31)\n.maxstack 2\n.locals init (\n[0] int32,\n[1] bool\n)\nIL_0000: nop\nIL_0001: ldstr \"Program start\"\nIL_0006: call void [mscorlib]System.Console::WriteLine(string)\nIL_000b: nop\nIL_000c: ldc.i4.1\nIL_000d: stloc.0\n// sequence point: hidden\nIL_000e: br.s IL_001d\n// loop start (head: IL_001d)\nIL_0010: nop\nIL_0011: ldloc.0\nIL_0012: call void Demo.Program::VisTal(int32)\nIL_0017: nop\nIL_0018: nop\nIL_0019: ldloc.0\nIL_001a: ldc.i4.1\nIL_001b: add\nIL_001c: stloc.0\nIL_001d: ldloc.0\nIL_001e: ldc.i4.6\nIL_001f: clt\nIL_0021: stloc.1\n// sequence point: hidden\nIL_0022: ldloc.1\nIL_0023: brtrue.s IL_0010\n// end loop\nIL_0025: ldstr \"Program slut\"\nIL_002a: call void [mscorlib]System.Console::WriteLine(string)\nIL_002f: nop\nIL_0030: ret\n} // end of method Program::Main\n.method private hidebysig static\nvoid VisTal (\nint32 i\n) cil managed\n{\n// Method begins at RVA 0x208d\n// Code size 9 (0x9)\n.maxstack 8\nIL_0000: nop\nIL_0001: ldarg.0\nIL_0002: call void [mscorlib]System.Console::WriteLine(int32)\nIL_0007: nop\nIL_0008: ret\n} // end of method Program::VisTal\n.method public hidebysig specialname rtspecialname\ninstance void .ctor () cil managed\n{\n// Method begins at RVA 0x2097\n// Code size 8 (0x8)\n.maxstack 8\nIL_0000: ldarg.0\nIL_0001: call instance void [mscorlib]System.Object::.ctor()\nIL_0006: nop\nIL_0007: ret\n} // end of method Program::.ctor\n} // end of class Demo.Program\n</code></pre> <p>Som konverteres til (her) X86 assembler, som ligger til grund for den bin\u00e6re eksekverbare kode:</p> <pre><code>; Desktop CLR v4.7.3416.00 (clr.dll) on x86.\nDemo.Program..ctor()\nL0000: push ebp\nL0001: mov ebp, esp\nL0003: push eax\nL0004: mov [ebp-0x4], ecx\nL0007: cmp dword [0x23072fd0], 0x0\nL000e: jz L0015\nL0010: call 0x73104370\nL0015: mov ecx, [ebp-0x4]\nL0018: call System.Object..ctor()\nL001d: nop\nL001e: nop\nL001f: mov esp, ebp\nL0021: pop ebp\nL0022: ret\nDemo.Program.Main(System.String[])\nL0000: push ebp\nL0001: mov ebp, esp\nL0003: sub esp, 0xc\nL0006: mov [ebp-0x4], ecx\nL0009: cmp dword [0x23072fd0], 0x0\nL0010: jz L0017\nL0012: call 0x73104370\nL0017: xor edx, edx\nL0019: mov [ebp-0x8], edx\nL001c: mov dword [ebp-0xc], 0x0\nL0023: nop\nL0024: mov ecx, [0xf3b6f24]\nL002a: call System.Console.WriteLine(System.String)\nL002f: nop\nL0030: mov dword [ebp-0x8], 0x1\nL0037: nop\nL0038: jmp L0049\nL003a: nop\nL003b: mov ecx, [ebp-0x8]\nL003e: call dword [0x23076f40]\nL0044: nop\nL0045: nop\nL0046: inc dword [ebp-0x8]\nL0049: cmp dword [ebp-0x8], 0x6\nL004d: setl al\nL0050: movzx eax, al\nL0053: mov [ebp-0xc], eax\nL0056: cmp dword [ebp-0xc], 0x0\nL005a: jnz L003a\nL005c: mov ecx, [0xf3b6f28]\nL0062: call System.Console.WriteLine(System.String)\nL0067: nop\nL0068: nop\nL0069: mov esp, ebp\nL006b: pop ebp\nL006c: ret\nDemo.Program.VisTal(Int32)\nL0000: push ebp\nL0001: mov ebp, esp\nL0003: push eax\nL0004: mov [ebp-0x4], ecx\nL0007: cmp dword [0x23072fd0], 0x0\nL000e: jz L0015\nL0010: call 0x73104370\nL0015: nop\nL0016: mov ecx, [ebp-0x4]\nL0019: call System.Console.WriteLine(Int32)\nL001e: nop\nL001f: nop\nL0020: mov esp, ebp\nL0022: pop ebp\nL0023: ret\n</code></pre>"},{"location":"010_introcs.html#decompilere","title":"Decompilere","text":"<p>Der findes flere v\u00e6rkt\u00f8jer til at kigge i IL kode, og eventuelt decompilere til C# (eller andre sprog). Nogle af de kendte er blandt andet:</p> <ul> <li>dotPeek</li> <li>ILSpy</li> </ul>"},{"location":"010_introcs.html#runtime","title":"Runtime","text":"<p>En runtime i .NET skal du se som en n\u00f8dvendighed for at kunne afvikle IL-kode. F\u00f8r 2020 fandtes der er en del forskellige runtime (.NET Framework, .NET Core, Mono og Xamarin), men i november 2020 blev .NET 5 frigivet (sammen med C# 9), og den er f\u00f8rste skridt til at samle de gamle runtimes til en samlet runtime.</p> <p>Download de forskellige runtime\u2019s</p> <p>Se .NET som en virtuel maskine med en generisk samling af komponenter man kan skrive kode til, og som nok selv skal s\u00f8rge for at applikationen bliver afviklet p\u00e5 den p\u00e5g\u00e6ldende platform.</p> <p>Internt best\u00e5r en .NET runtime af komponenter som:</p> <ul> <li>CLR, som s\u00f8rger for afvikling</li> <li>BCL, som er en stor samling klassebiblioteker der stiller funktionalitet til r\u00e5dighed</li> <li>Komponenter brugt i forbindelse med udvikling (debuggere mv)</li> <li>Komponenter brugt i forbindelse med sikkerhed (signering af kode mv)</li> </ul>"},{"location":"010_introcs.html#bcl","title":"BCL","text":"<p>Is\u00e6r BCL\u2019en er vigtig for C# udviklere, for her findes alle de klasser og strukturer som MS stiller til r\u00e5dighed for at hj\u00e6lpe med udvikling af applikationer.</p> <p>Komponenterne er placeret i namespace\u2019s for at skabe en logisk struktur og indkapsling, og samtidigt undg\u00e5 navnesammenfald.</p> <p>De fleste klasser og strukturer kan tilg\u00e5s under \u201cSystem\u201d, og ved hj\u00e6lp af punktumnotation kan BCL\u2019en \u201cbrowses/bladres\u201d.</p> <p>En stor del af det at l\u00e6re at kode i C# handler om, at l\u00e6re hvordan man nemmest</p> <ul> <li>\u00e5bner en fil</li> <li>taler med en database</li> <li>skaber et http-kald</li> <li>finde noder i en xml-fil</li> <li>finder et tilf\u00e6ldig tal</li> <li>Kryptere en tekst</li> <li>osv\u2026</li> </ul> <p>og typerne til at h\u00e5ndtere det finder i selve BCL\u2019en.</p>"},{"location":"010_introcs.html#nuget","title":"NuGet","text":"<p>NuGet er Microsofts store pakkebibliotek hvor der findes yderligere generisk kode. Pakker er tilf\u00f8jet af b\u00e5de Microsoft og af 3. parts firmaer, grupper eller enkelt personer. I starten af 2021 var der over 230.000 pakker tilg\u00e6ngelige, og de kan tilf\u00f8jes ed download, gennem konsol eller (nemmest) gennem Visual Studio eller Visual Studio Code. Mange af pakkerne er open source-projekter fra GitHub.</p>"},{"location":"010_introcs.html#udviklingsmiljer","title":"Udviklingsmilj\u00f8(er)","text":"<ul> <li>Visual Studio<ul> <li>Community (gratis for private - men check licensbetingelser)</li> <li>Professional</li> <li>Enterprise</li> </ul> </li> <li>Visual Studio Code</li> <li>Rider fra JetBrains</li> <li>Plugins<ul> <li>VS - bla ReSharper fra JetBrains og mange flere</li> <li>VSC - \u201cC#\u201d og mange flere</li> </ul> </li> <li>Snippets mv</li> </ul>"},{"location":"010_introcs.html#installation-af-visual-studio","title":"Installation af Visual Studio","text":"<p>Download Visual Studio Community Edition. Ved installation skal du v\u00e6lge \u201c.NET desktop development\u201d og eventuelt \u201cASP.NET\u201d hvis du vil lave web udvikling p\u00e5 et senere tidspunkt.</p>"},{"location":"010_introcs.html#hvad-kan-man-udvikle-med-net-og-c","title":"Hvad kan man udvikle med .NET (og C#)","text":"<p>Hvis f\u00f8rst du kender til et .NET sprog (C#, F#, VB.NET) har du mulighed for at skabe mange forskellige typer af applikationer.</p>"},{"location":"010_introcs.html#konsol","title":"Konsol","text":"<p>Dette kursus tager udgangspunkt i en konsolapplikation for at kunne holde fokus p\u00e5 teorien og syntaksen. Det er den mest simple type af applikation, men bliver faktisk benyttet en del til v\u00e6rkt\u00f8jer og administrative applikationer. Og som en af de f\u00e5 applikationstyper (bortset fra webapplikationer) kan den afvikles p\u00e5 alle supporterede platforme.</p> <p></p>"},{"location":"010_introcs.html#winform","title":"WinForm","text":"<p>Hvis du \u00f8nsker at skabe en desktop applikation har du forskellige muligheder. Du kan v\u00e6lge at udvikle en traditionel Windows Forms-applikation, som er bundet til interne komponenter i Windows. Denne typer applikation har levet i mange \u00e5r, og er opgraderet til forskellige runtimes. I skrivende stund kan den findes p\u00e5 listen over mulige projekter i Visual Studio som \u201dWindows Forms (.NET)\u201d.</p> <p>Med Windows Forms kan du meget hurtigt skabe en brugerflade med alle mulige former for kontroller, og s\u00e5 binde det hele sammen med C# kode.</p> <p></p>"},{"location":"010_introcs.html#wpf","title":"WPF","text":"<p>Du kan ogs\u00e5 v\u00e6lge en WPF (Windows Presentation Foundation) applikation som er noget nyere end Windows Forms, og ikke helt s\u00e5 bundet til interne komponenter i Windows. Der er nogen flere muligheder i en WPF applikation, men den er fortsat bundet til Windows-platformen.</p> <p>I skrivende stund kan den findes p\u00e5 listen over mulige projekter i Visual Studio som \u201dWPF App (.NET)\u201d.</p> <p>I skrivende stund er Microsoft ved at f\u00e6rdigg\u00f8re et projekt kaldet WinUI , og det vil sikkert blive den anbefalede m\u00e5de (m\u00e5ske fra .NET 6) at skabe desktop applikationer p\u00e5.</p> <p></p>"},{"location":"010_introcs.html#maui","title":"MAUI","text":"<p>MAUI er Microsofts nyeste bud p\u00e5 et cross platform UI framework. Med MAUI kan du bygge b\u00e5de desktop og mobile applikationer. Det er en videreudvikling af Xamarin Forms, og nye projekter b\u00f8r m\u00e5ske kigge p\u00e5 MAUI fremfor Xamarin.</p>"},{"location":"010_introcs.html#mobil","title":"Mobil","text":"<p>Du kan ogs\u00e5 skabe forskellige typer af mobile applikationer til Android og iOS. Microsoft k\u00f8bte for nogle \u00e5r siden et firma der hed Xamarin som havde skabt et framework til at udvikle mobile applikationer. Navnet Xamarin fremg\u00e5r stadig af projekttyperne i Visual Studio, og det er i skrivende stund m\u00e5den at skabe mobile applikationerne p\u00e5 med C#.</p>"},{"location":"010_introcs.html#web","title":"Web","text":"<p>Hvis du \u00f8nsker at skabe web applikationer har Microsoft tre forskellige projekttyper du kan v\u00e6lge i mellem. Det mest solide og komplette framework hedder ASP.NET MVC (st\u00e5r for Model View Controller), og det benyttes til de traditionelle serverbaserede webapplikationer. Alternativet er det mindre, men ogs\u00e5 meget nemmere, framework kaldet ASP.NET Web Pages. Hvis du blot skal skabe et par websider, er det uden tvivl det nemmere at komme i gang med. Som noget nyt kan du ogs\u00e5 v\u00e6lge at skabe SPA applikationer (Single Page Applications) med et nyt framework kaldet Blazor . Det benytter helt nye standardiseret m\u00e5der at afvikle IL kode (og dermed C#) direkte i browseren. I skrivende stund er dette framework meget nyt, men den teknologi det er bygget p\u00e5 (WebAssembly forkortet WASM) er p\u00e5 vej frem i webudvikling, og det bliver sp\u00e6ndende at se om Blazor bider sig fast.</p>"},{"location":"010_introcs.html#serviceapi","title":"Service/API","text":"<p>Hvis du \u00f8nsker at skabe en servicebaseret applikation som kan v\u00e6re kernen i samling af forskellige applikationer, b\u00f8r du se n\u00e6rmere p\u00e5 gRPC . Det er oprindeligt Google\u2019s framework til RPC (Remote Procedure Call), og er nu t\u00e6t p\u00e5 industristandard for den typer af applikationer p\u00e5 mange platforme og i mange programmeringssprog. Projekttyper relateret til gRPC er i skrivende netop tilf\u00f8jet .NET (og Visual Studio).</p>"},{"location":"010_introcs.html#database","title":"Database","text":"<p>Slutteligt kan du n\u00e6sten ikke skabe en applikation uden at involvere en database. Der findes masser af muligheder for at tale med alle mulige former for databaser i .NET, men de fleste v\u00e6lger at benytte et ORM produkt (Object\u2013Relational Mapping). Det giver mulighed for at abstrahere meget at databasekode v\u00e6k, og i stedet fokusere p\u00e5 forretningslogik. Microsoft eget ORM produkt hedder Entity Framework (EF), og kan spare en frygtelig masse tid ved udvikling af en applikation.</p> <p>EF er en integreret del .NET og udviklingsmilj\u00f8erne.</p>"},{"location":"020_omcs.html","title":"Om C#-sproget","text":""},{"location":"020_omcs.html#om-modulet","title":"Om modulet","text":"<p>Dette modul vil introducere dig til C# sproget, typer samt opbygningen af en C# applikation.</p>"},{"location":"020_omcs.html#c-sproget","title":"C#-sproget","text":"<ul> <li>C# er det prim\u00e6re sprog i .NET (se ogs\u00e5 F#, VB.NET og det sp\u00e6ndende Q#)</li> <li>Skabt af et team ledet af Anders Hejlsberg</li> <li>Borland: Turbo Pascal, Delphi</li> <li>Anders Hejlsberg - WikiPedia</li> <li>Historien bag</li> <li>C#</li> <li>.NET framework</li> <li>.NET Core</li> </ul>"},{"location":"020_omcs.html#version","title":"Version","text":"<p>Den sidste nye version af C# er version 10 fra november 2021.</p>"},{"location":"020_omcs.html#syntaks","title":"Syntaks","text":"<ul> <li>Sproget benytter C-relateret syntaks</li> <li>Semikolon afslutter instruktion<ul> <li>Mellemrum, whitespace, tabulering, linjeskift har ingen betydning</li> <li>Der er forskel p\u00e5 brug af store og sm\u00e5 bogstaver</li> </ul> </li> <li>// = kommentar</li> <li>Tuborgklamme omkranser virkefelt</li> <li>Ingen linjenumre</li> <li>Brug af Unicode</li> </ul> <pre><code>using System;\nnamespace Demo\n{\nclass Program\n{\nstatic void Main(string[] args)\n{\nif (1 == 1)\n{\nConsole.WriteLine(\"G\u00f8r noget\");\n}\nelse {\nConsole.WriteLine(\"G\u00f8r noget andet\");\n}\nfor (int i = 0; i &lt; 4; i++)\n{\nConsole.WriteLine(i);\n}\n{\nint j = 1;\n}\nint k =                 10;\nint l\n= 10;\n// Dette er en kommentar\n/*\n                Dette er ogs\u00e5 en kommentar\n            */\nint m = 1;\nint M = 2;\nint M\u00e5GerneBruge\u00c6\u00d8\u00c5 = 1;\n}\n}\n}\n</code></pre>"},{"location":"020_omcs.html#helt-grundlggende-om-c-programmering","title":"Helt grundl\u00e6ggende om C#-programmering","text":"<ul> <li>Mange indbyggede simple datatyper</li> <li>variabler</li> <li>BCL (Base Class Library) stiller en masse funktionalitet til r\u00e5dighed</li> <li>System.???</li> <li>Alt er baseret p\u00e5 typer</li> <li> <p>I den grundl\u00e6ggende C# </p> <ul> <li>Klasser</li> <li>Strukturer</li> <li>Enumerations</li> <li>Delegates</li> <li>Interface</li> </ul> </li> <li> <p>I grundl\u00e6ggende C# beh\u00f8ver man ikke v\u00e6re s\u00e6rlig bevidst eller bekymret for oprydning af hukommelse</p> </li> <li>Modsat andre sprog som eksempelvis C eller C++</li> </ul>"},{"location":"020_omcs.html#c-er-iterativt-og-proceduralt","title":"C# er iterativt og proceduralt","text":"<pre><code>using System;\nnamespace Demo\n{\nclass Program\n{\nstatic void Main(string[] args)\n{\nint antal = 5;\nConsole.WriteLine($\"Starter med at t\u00e6lle\");\nfor (int i = 0; i &lt; antal; i++)\n{\nif (DateTime.Now.DayOfWeek == DayOfWeek.Sunday)\n{\nConsole.ForegroundColor = ConsoleColor.Red;\n}\nelse\n{\nConsole.ForegroundColor = ConsoleColor.Gray;\n}\nConsole.WriteLine(i);\n}\nConsole.WriteLine(\"F\u00e6rdig med at t\u00e6lle\");\n}\n}\n}\n</code></pre> <p>eller\u2026 lidt mere moderne ved brug af metoder for nemmere genbrug og vedligeholdelse</p> <pre><code>using System;\nnamespace Demo\n{\nclass Program\n{\nstatic void Main(string[] args)\n{\nT\u00e6l(5, ConsoleColor.Red);\n}\nstatic void T\u00e6l(int antal, ConsoleColor FarveTilS\u00f8ndag)\n{\nConsole.WriteLine($\"Starter med at t\u00e6lle\");\nfor (int i = 0; i &lt; antal; i++)\n{\nif (DateTime.Now.DayOfWeek == DayOfWeek.Sunday)\n{\nConsole.ForegroundColor = FarveTilS\u00f8ndag;\n}\nelse\n{\nConsole.ForegroundColor = ConsoleColor.Gray;\n}\nConsole.WriteLine(i);\n}\nConsole.WriteLine(\"F\u00e6rdig med at t\u00e6lle\");\n}\n}\n}\n</code></pre>"},{"location":"020_omcs.html#c-er-objektorienteret","title":"C# er objektorienteret","text":"<pre><code>using System;\nnamespace Demo\n{\nclass Program\n{\nstatic void Main(string[] args)\n{\nMinT\u00e6ller t\u00e6ller = new MinT\u00e6ller(5, ConsoleColor.Red);\nt\u00e6ller.T\u00e6l();\n}\n}\nclass MinT\u00e6ller {\npublic int Antal { get; private set; }\npublic ConsoleColor FarveTilS\u00f8ndag { get; private set; }\npublic MinT\u00e6ller(int antal, ConsoleColor farve)\n{\nthis.Antal = antal;\nthis.FarveTilS\u00f8ndag = farve;\n}\npublic void T\u00e6l() {\nConsole.WriteLine($\"Starter med at t\u00e6lle\");\nfor (int i = 0; i &lt; this.Antal; i++)\n{\nif (DateTime.Now.DayOfWeek == DayOfWeek.Sunday)\n{\nConsole.ForegroundColor = this.FarveTilS\u00f8ndag;\n}\nelse\n{\nConsole.ForegroundColor = ConsoleColor.Gray;\n}\nConsole.WriteLine(i);\n}\nConsole.WriteLine(\"F\u00e6rdig med at t\u00e6lle\");\n}\n}\n}\n</code></pre>"},{"location":"020_omcs.html#c-er-funktionsorienteret","title":"C# er funktionsorienteret","text":"<pre><code>using System;\nusing System.Collections.Generic;\nusing System.Linq;\nnamespace Demo\n{\nclass Program\n{\nstatic void Main(string[] args)\n{\nT\u00e6l(Enumerable.Range(0, 5),\n() =&gt;\n{\nif (DateTime.Now.DayOfWeek == DayOfWeek.Sunday)\nConsole.ForegroundColor = ConsoleColor.Red;\n},\n() =&gt; Console.ForegroundColor = ConsoleColor.Gray,\nConsole.WriteLine);\n// Blot eksempel p\u00e5 kald af funktionen med en anden\n// nummerr\u00e6kke og referencer til andre skriv/farve funktioner\nT\u00e6l(Enumerable.Range(1, 10).Where(i =&gt; i % 2 == 0),\n() =&gt;\n{\nif (DateTime.Now.DayOfWeek == DayOfWeek.Sunday)\nSystem.IO.File.AppendAllText(@\"c:\\temp\\side.html\", \"&lt;div class='red'&gt;\\r\\n\");\n},\n() =&gt; System.IO.File.AppendAllText(@\"c:\\temp\\side.html\", \"&lt;div class='gray'&gt;\\r\\n\"),\n(t) =&gt; System.IO.File.AppendAllText(@\"c:\\temp\\side.html\", \"\\r\\n\" + t)\n);\n}\nstatic void T\u00e6l(IEnumerable&lt;int&gt; tal,\nAction metodeTilAtS\u00e6tteFarve,\nAction metodeTilAtResetFarve,\nAction&lt;string&gt; metodeTilAtSkrive)\n{\nmetodeTilAtSkrive($\"Starter med at t\u00e6lle\");\ntal.ToList().ForEach((i) =&gt;\n{\nmetodeTilAtS\u00e6tteFarve();\nmetodeTilAtSkrive(i.ToString());\nmetodeTilAtResetFarve();\n});\nmetodeTilAtSkrive(\"F\u00e6rdig med at t\u00e6lle\");\n}\n}\n}\n</code></pre>"},{"location":"020_omcs.html#c-er-typestrkt","title":"C# er typest\u00e6rkt","text":"<pre><code>using System;\nnamespace Demo\n{\nclass Program\n{\nstatic void Main(string[] args)\n{\nint i = 10;\n// i = true;     // fejl\n// i = \"test\";   // fejl\nbyte j = 0;\n// j = 256;      // fejl\nint k = 10;\nbyte l = 0;\n// l = k;        // fejl (32 bit -&gt; 8 bit)\n// ok - men kan jo fejle\nl = Convert.ToByte(k);\nTest(2);        // ok\n// Test(256);   // fejl\n// Test(\"a\");   // fejl\n}\nstatic void Test(byte a) {\n// kode\n}\n}\n}\n</code></pre>"},{"location":"020_omcs.html#c-er-typesikkert","title":"C# er typesikkert","text":"<pre><code>using System;\nnamespace Demo\n{\nclass Program\n{\nstatic void Main(string[] args)\n{\nbool a = true;\nif (a == true)\n{\nint b = 10;\nConsole.WriteLine($\"a er {a} og b er {b}\");\n}\nelse\n{\nint b = 20;\nConsole.WriteLine($\"a er {a} og b er {b}\");\n}\nTest();\nMinKlasse c = new MinKlasse();\n}\nstatic void Test() {\nstring a = \"\";\nDateTime b = DateTime.Now;\n}\n}\nclass MinKlasse {\npublic double A { get; set; }\npublic int B { get; set; }\n}\n}\n</code></pre> <p>Der findes dog muligheder for s\u00e5kaldt \u201cunsafe\u201d kode hvor pointere til et sted i hukommelen er muligt!</p>"},{"location":"020_omcs.html#alt-er-baseret-pa-typer","title":"Alt er baseret p\u00e5 typer","text":"<p>I C# er alt baseret p\u00e5 nogle f\u00e5 typer</p> <ul> <li>class (klasse)</li> <li>struct (struktur)</li> <li>interface (definitation af medlemmer p\u00e5 en type)</li> <li>delegate (\u201cfunktionspointer\u201d)</li> <li>enum (relateret konstant)</li> <li>records (autogenereret klasse/struct - ny i C# 9 og 10)</li> </ul> <p>I den helt grundl\u00e6ggende C# kan du n\u00f8jes med at fokusere p\u00e5 at skabe typer baseret class og struct - og i de fleste tilf\u00e6lde blot p\u00e5 class.</p> <p>Men b\u00e5de struct og class (og record) skal ses som en skabelon for instanser</p> <p></p> <p>Instanser af klasser kaldes typisk for objekter.</p> <p>I disse instanser er der typisk b\u00e5de data (tal, tegn, datoer, referencer til andre objekter), samt metoder der kan arbejde med disse data.</p> <pre><code>namespace Demo\n{\nclass Program\n{\nstatic void Main(string[] args)\n{\n// a er en instans af System.Int32 (struct) og kan opbevare en heltalsv\u00e6rdi (32 bit)\nSystem.Int32 a = new System.Int32();\na = 10;\n// kan ogs\u00e5 skrives nemmere som\n// int a;\n// a = 10;\n// eller\n// int a = 10;\n// System.Int32 indeholder metoden ToString(), der konverterer heltallet til en streng\nstring b = a.ToString();\n// ------------------------\n// c er en instans af System.DateTime (struct) og kan opbevare dato og tid\nSystem.DateTime c = new System.DateTime();\nc = System.DateTime.Now;\n// kan ogs\u00e5 skrives som\n// System.DateTime c;\n// c = System.DateTime.Now;    // System tid\n// eller\n// System.DateTime c = System.DateTime.Now;\n// System.DateTime indeholder en masse metoder der kan bruges p\u00e5 den gemte dato\nSystem.Console.WriteLine(c.AddDays(1));\nSystem.Console.WriteLine(c.IsDaylightSavingTime());\n// System.Random (class) kan bruges til at finde et tilf\u00e6ldigt tal\nSystem.Random d = new System.Random();\n// og indeholder en masse metoder relateret til dette\nSystem.Console.WriteLine(d.Next(1, 10));\n// Hund (class) er type med data (navn og antalben) og en enkelt metode\nHund e = new Hund();\ne.Navn = \"Fido\";\ne.AntalBen = 4;\nSystem.Console.WriteLine(e.SigNoget());\n// B\u00e5de System.Int32, System.DateTime, System.Random og Hund er typer (struct eller class)\n}\n}\nclass Hund\n{\npublic string Navn;\npublic int AntalBen;\npublic string SigNoget()\n{\nreturn $\"Jeg hedder {this.Navn} og har {this.AntalBen} ben.\";\n}\n}\n}\n</code></pre>"},{"location":"020_omcs.html#namespace","title":"Namespace","text":"<p>Alle typer er placeret i et namespace. Et namespace kan best\u00e5 af typer samt andre namespace\u2019s, og kan man derfor opbygge et hieraki af typer. Det sikrer logisk struktur og indkapsling, og samtidigt undg\u00e5r man evt navnesammenfald.</p> <p>Det bedste eksempel er MS egen BCL hvor alt er placeret i eller under System-namespacet</p> <p>Her er blot nogle f\u00e5 eksempler under <code>System</code></p> <ul> <li>System.Console</li> <li>System.IO</li> <li>System.Data</li> <li>System.Math</li> <li>System.Net</li> <li>System.Xml</li> <li>System.Collections</li> <li>System.Diagnostics</li> <li>System.Reflection</li> <li>System.Security</li> <li>System.Threading</li> <li>System.Random</li> </ul> <p>Man kan selv erkl\u00e6re et namespace hieraki, og her opbevare forskellige typer som</p> <ul> <li>klasser</li> <li>strukturer</li> <li>enumerations</li> <li>delegates</li> </ul> <p></p> <pre><code>namespace NS1\n{\npublic class A { }\npublic class B { }\npublic struct C { }\npublic enum D { }\npublic delegate Action E();\n}\n</code></pre> <p>Et namespace omkranser typer og sikre struktur og forhindre navnesammenfald</p> <p></p> <pre><code>namespace NS1\n{\npublic class A { }\npublic class B { }\npublic struct C { }\npublic enum D { }\npublic delegate Action E();\n}\nnamespace NS2\n{\npublic class A { }\npublic class B { }\npublic struct C { }\npublic enum D { }\npublic delegate Action E();\n}\n</code></pre> <p>Et namespace m\u00e5 gerne v\u00e6re i sit eget namespace (som ligger i sit eget namespace (som \u2026))</p> <p></p> <pre><code>namespace NS1\n{\nnamespace NS2\n{\npublic class A { }\npublic class B { }\npublic struct C { }\npublic enum D { }\npublic delegate Action E();\n}\nnamespace NS3\n{\npublic class A { }\npublic class B { }\npublic struct C { }\npublic enum D { }\npublic delegate Action E();\n}\n}\n</code></pre>"},{"location":"020_omcs.html#typer-i-typer-i-typer","title":"Typer i typer (i typer)","text":"<p>I enkelte situationer kan typer ogs\u00e5 placeres i typer</p> <p></p> <pre><code>namespace NS1\n{\nclass A\n{\nclass B\n{\n}\n}\nclass C\n{\nenum D\n{\n}\nstruct E\n{\n}\n}\n}\n</code></pre> <p>I grundl\u00e6ggende C# er det dog ikke s\u00e6rlig tit det benyttes.</p>"},{"location":"020_omcs.html#tilgang-til-typer","title":"Tilgang til typer","text":"<p>Ved definering af typer angives ogs\u00e5 en access modifier. Det er besked til compileren om hvor typen kan benyttes.</p>"},{"location":"020_omcs.html#pa-namespace-niveau","title":"P\u00e5 namespace-niveau","text":"<p>I grundl\u00e6ggende C# benyttes to</p> <ul> <li>internal (privat - kun tilg\u00e6ngelig i projekt)</li> <li>public (offentlig - alle projekter med reference kan tilg\u00e5 typen)</li> </ul> <p>Begyndere b\u00f8r angive en access modifier - men internal er default</p> <pre><code>public class A\n{\n}\ninternal class B\n{\n}\nclass C // internal som default\n{\n}\n</code></pre>"},{"location":"020_omcs.html#tilgang-til-typer-pa-type-niveau","title":"Tilgang til typer p\u00e5 type niveau","text":"<p>I grundl\u00e6ggende C# benyttes to</p> <ul> <li>private (privat - kun tilg\u00e6ngelig i typen)</li> <li>public (offentlig - alle kan tilg\u00e5 typen)</li> </ul> <p>Men igen - typer i typer er ikke s\u00e5 meget benyttet i den grundl\u00e6ggende C#.</p> <pre><code>public class A\n{\nprivate class B\n{\n}\n}\n</code></pre>"},{"location":"025_IntroduktiontilVS.html","title":"Introduktion til Visual Studio","text":""},{"location":"025_IntroduktiontilVS.html#om-modulet","title":"Om modulet","text":"<p>Dette modul vil introducere dig til Visual Studio og debuggeren.</p>"},{"location":"025_IntroduktiontilVS.html#installation","title":"Installation","text":"<p>Visual Studio kan findes p\u00e5</p> <p>https://visualstudio.microsoft.com/</p> <p>og findes som tidligere n\u00e6vnt i flere versioner. Community Edition er den gratis version (for private og mindre firmaer - se licens betingelser).</p> <p>Den kan installeres p\u00e5 Windows og Mac, og du skal i installationsproceduren mindst v\u00e6lge \u201c.NET desktop development\u201d.</p>"},{"location":"025_IntroduktiontilVS.html#version","title":"Version","text":"<p>Den sidste nye version af Visual Studio er VS 2022 fra november 2021.</p>"},{"location":"025_IntroduktiontilVS.html#oprettelse-af-et-projekt","title":"Oprettelse af et projekt","text":"<p>Man kan skabe mange forskelige projekttyper i Visual Studio, men vi vil her udelukkende fokusere p\u00e5 en \u201cConsole Application (.NET Core)\u201d for p\u00e5 den m\u00e5de at holde fokus p\u00e5 koden og ikke p\u00e5 brugerflade. S\u00e5 kan du efterf\u00f8lgende selv lege med andre projekttyper.</p> <p>Du kan skabe en ny applikationer ved at v\u00e6lge File-&gt;Project og s\u00e5 v\u00e6lge C# i \u201cLanguage\u201d dropdown-boksen, og s\u00f8ge efter console. N\u00e5r du f\u00f8rst har brugt den en gang dukker projekttypen op i listen til venstre i vinduet.</p> <p></p> <p>Herefter kan man angive navnet p\u00e5 projektet og hvilken mappe det skal placeres i.</p> <p></p>"},{"location":"025_IntroduktiontilVS.html#en-c-lsning","title":"En C# l\u00f8sning","text":"<p>En C# l\u00f8sning (solution) best\u00e5r typisk af et eller flere projekter, og et enkelt projekt kan v\u00e6re en konsol applikation, web applikation, windows applikation, mobil applikation med videre. En l\u00f8sning er repr\u00e6senteret ved en .sln fil.</p> <p>Hvert projekt kan s\u00e5 v\u00e6re opdelt i flere filer, som kompileren vil s\u00f8rge for at kompilere sammen. Et projekt er repr\u00e6senteret af en .csproj fil, og best\u00e5r typisk af en masse .cs filer med kode samt eventuelle konfigurationsfiler.</p> <p>N\u00e5r man skabe en konsol applikation best\u00e5r den alts\u00e5 af en .sln-fil (l\u00f8sning)</p> <p></p> <p>og en .csproj-fil (projekt) samt de filer som projektet best\u00e5r af.</p> <p></p> <p>I Visual Studio kan finde l\u00f8sning, projekter og filer i \u201cSolution Explorer\u201d:</p> <p></p> <p>Af andre vigtige vinduer i VS kan n\u00e6vnes \u201cError List\u201d vinduet hvor eventuelle kompileringsfejl dukker op.</p> <p></p>"},{"location":"025_IntroduktiontilVS.html#mange-kodefiler-i-et-projekt","title":"Mange kodefiler i et projekt","text":"<p>Man m\u00e5 gerne have mange cs-filer (kodefiler) i et projekt, og kan organisere disse som man \u00f8nsker i mapper. Alle filer skal dog best\u00e5 af en typedefinition (klasse, struktur, enum med videre). Man kan s\u00e5g\u00e5r i den mere avancerecede C# fort\u00e6lle kompileren at den skal kombinere typer. Det kan ske ved hj\u00e6lp af <code>partial</code> kodeordet - herom senere.</p> <p>Man kan ogs\u00e5 v\u00e6lge at have flere typer i samme fil - kompilereren er ligeglad.</p> <p>Et konsol projekt med flere typer kan alts\u00e5 enten best\u00e5r af</p> <ul> <li>en stor program.cs med mange typer definitioner</li> </ul> <p>eller</p> <ul> <li>en program.cs og en fil for hver type (hund.cs, faktura.cs mv)</li> </ul> <p>eller</p> <ul> <li>en program.cs og mapper (h\u00f8jreklik p\u00e5 projekt og \u201cNew folder\u201d) med en fil for hver type<ul> <li>\\regnskab<ul> <li>faktura.cs</li> <li>fakturalinje.cs</li> </ul> </li> <li>\\personale<ul> <li>person.cs</li> <li>medarbejder.cs</li> </ul> </li> </ul> </li> </ul> <p>eller en kombination.</p>"},{"location":"025_IntroduktiontilVS.html#intellisense","title":"IntelliSense","text":"<p>N\u00e5r du skriver kode i Visual Studio s\u00e5 l\u00e6r at bruge \u201cIntelliSense\u201d - alts\u00e5 at lade Visual Studio skrive s\u00e5 meget af kode som muligt ved at v\u00e6lge p\u00e5 listen der automatisk dukker op. Det er en af fordelene ved at arbejde med et typest\u00e6rkt sprog som C# - VS ved hvad en konkret type indeholder.</p> <p></p> <p>Hold \u00f8je med listen n\u00e5r du skriver, og tryk Enter eller Tab n\u00e5r det rigtige er valgt p\u00e5 listen.</p> <p></p> <p>Pr\u00f8v den m\u00e5de kan du nemt se havd en type best\u00e5r af, og staver ikke forkert.</p>"},{"location":"025_IntroduktiontilVS.html#intellicode","title":"IntelliCode","text":"<p>Med VS 2022 f\u00f8lger (normalt) Microsofts IntelliCode extension som udvider hj\u00e6lpen fsva syntaks og instruktioner med AI. Hvis du \u00f8nsker denne extension kan den disables - alternativt tilrettes under options.</p>"},{"location":"025_IntroduktiontilVS.html#snippets","title":"Snippets","text":"<p>Lad VS g\u00f8re s\u00e5 meget af arbejdet som overhovedet muligt - brug kode snippets s\u00e5 meget du kan. Der findes en del indbyggede, og du kan oprette dine egne.</p> <p>Find de forskellige snippets ved at h\u00f8jre klikke og v\u00e6lge Snippet-&gt;Insert Snippets-&gt;Visual C#</p> <p></p> <p>Du kan ogs\u00e5 bruge genvejsnavnet og blot trykke 2 gange tabulering</p> <p></p> <p>Her er nogle af de mere kendte snippets til C#</p> <ul> <li>for = for loop</li> <li>try = try catch</li> <li>do = do/while</li> <li>if = if</li> <li>cw = Console.WriteLine()</li> </ul>"},{"location":"025_IntroduktiontilVS.html#genvejstaster","title":"Genvejstaster","text":"<p>VS best\u00e5r af et hav af genvejstaster som du efterh\u00e5ndende vil l\u00e6re - her er nogle af de vigtigste s\u00e5 du har en liste at komme retur til:</p> <ul> <li>Ctrl + K + D = Format code</li> <li>Ctrl + K + C = Comment selection</li> <li>Ctrl + K + U = Uncomment selection</li> <li>Ctrl + K + X = Insert snippet</li> <li>Ctrl + K + S = Surround with (snippet)</li> <li>F12 = Goto definition</li> <li>Ctrl + K + R = Find all references</li> <li>Ctrl + . = Quick actions</li> <li>Ctrl + [space] = Activate intelliSense</li> <li>F5 = Start with debugger</li> <li>Ctrl + F5 = Start without debugger</li> <li>Shift + F5 = End debugger session</li> <li>F9 = Set breakpoint</li> <li>F10 = Step over</li> <li>F11 = Step into</li> <li>Ctrl + Shift + F9 = Delete all breakpoints</li> <li>Alt + up/down arrow = Move selected code</li> <li>Ctrl + Shift + B = Build</li> <li>Ctrl + , = Global find types, members, files</li> <li>Ctrl + Tab = switch between windows</li> <li>F2 = rename</li> </ul> <p>Vi kommer tilbage til flere af dem senere.</p> <p></p>"},{"location":"025_IntroduktiontilVS.html#hjlp-fra-visual-studio","title":"Hj\u00e6lp fra Visual Studio","text":"<p>N\u00e5r du koder vil Visual Studio fors\u00f8ge at hj\u00e6lpe dig s\u00e5 meget den kan. Det sker eksempelvis ved hj\u00e6lp af et ikon af en p\u00e6re.</p> <p></p> <p>Det kan ogs\u00e5 ske ved hj\u00e6lp af et ikon af en skruen\u00f8gle.</p> <p></p> <p>Tastaturgenvejen til hj\u00e6lp er Ctrl + punktum.</p> <p>I starten vil du nok ikke benytte den hj\u00e6lp Visual Studio tilbyder, men efterh\u00e5nden som du bliver mere erfaren s\u00e5 pr\u00f8v at v\u00e6re lidt nysgerrig, og lad Visual Studio \u00e6ndre koden. Det er en god m\u00e5de at blive lidt klogere p\u00e5 C# syntaks, og du kan altid fortryde en \u00e6ndring.</p>"},{"location":"025_IntroduktiontilVS.html#kompilering","title":"Kompilering","text":"<p>Et projekt kan kompileres (bygges) p\u00e5 flere m\u00e5der</p> <ul> <li>V\u00e6lg \u201cBuild [projekt]\u201d p\u00e5 Build-menuen</li> <li>Med fokus i en kodefil kan du trykke F6</li> <li>Ctrl+Shift+B</li> </ul> <p>Under alle omst\u00e6ndigheder skulle det gerne ende med en \u201cBuild succeeded\u201d i venstre nederste hj\u00f8rne.</p> <p></p> <p>Applikationen kan herefter afvikles fra konsolen (eller flyttes til server/mobil).</p>"},{"location":"025_IntroduktiontilVS.html#afvikling","title":"Afvikling","text":"<p>En applikation kan ogs\u00e5 bygges og afvikles direkte fra VS</p> <ul> <li>Debug-&gt;Start debugging</li> <li>F5</li> </ul> <p>eller</p> <ul> <li>Debug-&gt;Start without debugging</li> <li>Ctrl+F5</li> </ul> <p>Typisk vil man starte med debuggeren, men mere om det senere.</p>"},{"location":"025_IntroduktiontilVS.html#prv-selv","title":"Pr\u00f8v selv","text":"<p>Det er vigtig at du lige f\u00e5r pr\u00f8vet at oprette en konsol applikation, og leget lidt med de forskellige muligheder i VS. I f\u00f8lgende opgave pr\u00f8ver du blandt andet</p> <ul> <li>at finde sln/csproj filerne</li> <li>bruge Error vinduet</li> <li>bruge IntelliSense</li> <li>bruge snippets</li> <li>bygge og afvikle</li> </ul> <p>Info</p>"},{"location":"025_IntroduktiontilVS.html#opgave-25-1","title":"Opgave 25-1","text":"<p>Simpel \u2018pr\u00f8v det selv\u2019/\u2019kom i gang\u2019 opgave (kode til s\u00f8gning: CFB)</p> <p>Se opgave</p>"},{"location":"025_IntroduktiontilVS.html#simpel-debugging","title":"Simpel debugging","text":"<p>Der findes et masse muligheder for at debugge (fejlfinde) en applikation, men mest brugt er brugen af breakpoints og steppe sig gennem koden.</p> <p>Breakpoints s\u00e6ttes nemmest med F9, og F10/F11 kan bruges til at steppe sig gennem koden. Der findes samtidigt en del tilg\u00e6ngelig vinduer under debugging som giver en masse information om variabler og eksekvering.</p> <p>Se i \u00f8vrigt ogs\u00e5</p> <ul> <li>C# Interactice</li> <li>C# Immediate</li> </ul> <p>Pr\u00f8v selv med f\u00f8lgende opgave (og se evt. video - der er et link i selve opgaven).</p> <p>Info</p>"},{"location":"025_IntroduktiontilVS.html#opgave-25-2","title":"Opgave 25-2","text":"<p>Opgave i simpel debugging (kode til s\u00f8gning: CFC)</p> <p>Se opgave</p>"},{"location":"025_IntroduktiontilVS.html#profiling-og-mere-avanceret-debugging","title":"Profiling og mere avanceret debugging","text":"<p>Nogle funktioner er ikke tilg\u00e6ngelige i VS Community</p> <ul> <li>CPU/GPU threads vindue</li> <li>Code analyze<ul> <li>\u201cRydder op\u201d i koden efter regler</li> <li>Se menuen Analyze</li> </ul> </li> <li>Diagmostic tools<ul> <li>Optag (snapshot) hukommelse og CPU forbrug</li> </ul> </li> <li>IntelliTrace<ul> <li>Optager events, hukommelse mv</li> </ul> </li> <li>Performance profiler<ul> <li>Avanceret profiling<ul> <li>Threads</li> <li>CPU / GPU</li> <li>Hukommelse</li> <li>\u2026</li> </ul> </li> </ul> </li> </ul>"},{"location":"025_IntroduktiontilVS.html#benchmark","title":"Benchmark","text":"<p>En af de mere avancerede profiling pakker</p> <ul> <li>Benchmark.net</li> </ul> <pre><code>// Package 'BenchmarkDotNet'\nusing System.Threading;\nusing BenchmarkDotNet.Attributes;\nusing BenchmarkDotNet.Running;\nnamespace MyBenchmarks\n{\npublic class Program\n{\npublic static void Main(string[] args)\n{\nvar summary = BenchmarkRunner.Run(typeof(IntroBasic).Assembly);\n}\n}\npublic class IntroBasic\n{\n[Benchmark]\npublic void Sleep() =&gt; Thread.Sleep(10);\n[Benchmark(Description = \"Thread.Sleep(10)\")]\npublic void SleepWithDescription() =&gt; Thread.Sleep(10);\n}\n}\n</code></pre>"},{"location":"030_KonsolApp.html","title":"En konsol applikation","text":""},{"location":"030_KonsolApp.html#om-modulet","title":"Om modulet","text":"<p>P\u00e5 kurset benytter vi udelukkende en C# konsol applikation s\u00e5 det er vigtigt du ved hvordan den er skruet sammen.</p>"},{"location":"030_KonsolApp.html#en-net-core-konsol-applikation","title":"En (.NET Core) konsol applikation","text":"<p>En konsol-applikation er blot en ud af mange forskellige projekttyper, men vi arbejder med konsol-applikationer for at kunne s\u00e6tte fokus p\u00e5 kode og ikke p\u00e5 UI. Se information om oprettelse af en konsol applikation i forrige modul.</p> <p>Skabelonen ser s\u00e5ledes ud:</p> <pre><code>using System;\nnamespace Demo\n{\nclass Program\n{\nstatic void Main(string[] args)\n{\nConsole.WriteLine(\"Hello world!\");\n}\n}\n}\n</code></pre> <p>Namespace svarer til navnet p\u00e5 applikationen (men kan \u00e6ndres) - klassen Program og metoden Main skal du ikke tage dig af lige nu. Det er blot skabelonen som runtime forventer, og vil automatisk afvikle kode i Main()-metoden.</p>"},{"location":"030_KonsolApp.html#c-9-konsol-applikation","title":"C# 9+ Konsol applikation","text":"<p>Blot til orientering s\u00e5 kan man fra C# 9 sk\u00e6re en del af koden i skabelonen v\u00e6k og blot n\u00f8jes med</p> <pre><code>using System;\nConsole.WriteLine(\"Hello world!\");\n</code></pre> <p>I C# 10 kan man s\u00e5g\u00e5r ogs\u00e5 droppe \u201cusing System\u201d som er implicit.</p> <p>For bedre at kunne forst\u00e5 C# holder matarialet dog fast i brugen af den store skabelon:</p> <pre><code>using System;\nnamespace Demo\n{\nclass Program\n{\nstatic void Main(string[] args)\n{\nConsole.WriteLine(\"Hello world!\");\n}\n}\n}\n</code></pre> <p>Du kan bruge ovenn\u00e6vnte som skabelon.</p> <p>Du kan ogs\u00e5 installere en extension i VS (vsix fil) med min .NET 6 skabelon. Find den p\u00e5 GitHub. Den kan installeres ved at hente og afvikle vsix-filen (luk VS inden installation). Herefter kan du finde skabelonen ved at s\u00f8ge p\u00e5 \u2018classic\u2019.</p>"},{"location":"030_KonsolApp.html#afvikling-af-en-konsol-applikation","title":"Afvikling af en konsol applikation","text":"<p>Forudsat at et konsol applikation projekt kan kompilere uden fejl er der som tidligere n\u00e6vnt flere m\u00e5der at afvikle koden p\u00e5.</p> <ul> <li>Byg og afvikling fra kommandolinjen</li> <li>F6</li> <li>ctrl+shift+b</li> <li>Afvikling med debugger</li> <li>F5</li> <li>Afvikling uden debugger</li> <li>ctrl+F5</li> </ul> <p>Man vil typisk altid afvikle med debuggeren for at f\u00e5 s\u00e5 meget hj\u00e6lp som muligt.</p>"},{"location":"030_KonsolApp.html#helt-grundlggende-om-strenge","title":"Helt grundl\u00e6ggende om strenge","text":"<p>En streng er en samling af tegn og findes i alle programmeringssprog. Der kommer meget senere mere om strenge senere men du vil falde over typen hele tiden s\u00e5 for en god ordens skyld er her en kort introduktion.</p> <p>En streng (datatypen hedder en string)i C# er omkranset af dobbeltplinger (\u201c\u201d) og kan sammenl\u00e6gges med + operatoren:</p> <pre><code>string a = \"Dette er tekst\";\nstring fornavn = \"Mathias\";\nstring efternavn = \"Cronberg\";\nstring navn = fornavn + \" \" + efternavn;    // Mathias Cronberg\n</code></pre> <p>Som du vil se senere er string-typen ret omfattende og indeholder en masse metoder (g\u00f8r til store/sm\u00e5 bogstaver, fjern mellemrum, t\u00e6l antal tegn med videre).</p> <p>Yderligere vil du se brugen af string-templates i en masse eksempler - her og i eksempler p\u00e5 nettet. Det er en simpel og effektiv m\u00e5de at sammenl\u00e6gge strenge. Det sker ved at danne en skabelon med $\u201d\u201d hvor udtryk og variabler kan inds\u00e6ttes med {}.</p> <pre><code>string fornavn = \"Mathias\";\nstring efternavn = \"Cronberg\";\nstring navn = $\"Mit navn er {fornavn} {efternavn}\"; // Mit navn er Mathias Cronberg\n</code></pre> <p>Der er meget mere du skal vide om strenge - dette er blot en introduktion.</p>"},{"location":"030_KonsolApp.html#helt-grundlggende-om-metoder","title":"Helt grundl\u00e6ggende om metoder","text":"<p>Inden vi kigger p\u00e5 udvikling af egne metoder er det vigtigt at du har en grundl\u00e6ggende forst\u00e5else for brug af metoder. Alle typer har en eller flere metoder - nogle kan v\u00e6re relateret til typens (eventuelle) data, og andre er blot hj\u00e6lpemetoder.</p> <p>Kald til metoder sker altid ved at angive metodens navn og angive argumenter i parentes. Nogle metoder returnerer en v\u00e6rdi - andre g\u00f8r ikke.</p> <pre><code>using System;\nnamespace Demo\n{\nclass Program\n{\nstatic void Main(string[] args)\n{\nConsole.WriteLine();\nConsole.WriteLine(\"Test\");\nint res = Math.Max(10, 20);\n}\n}\n}\n</code></pre>"},{"location":"030_KonsolApp.html#using","title":"using","text":"<p>En C# fil vil typisk altid i toppen have placeret nogle \u201cusing\u201d instruktioner. Det er en m\u00e5de at fort\u00e6lle kompileren at den ogs\u00e5 skal s\u00f8ge efter typer i konkrete namespaces. S\u00e5ledes kan f\u00f8lgende:</p> <pre><code>namespace Demo\n{\nclass Program\n{\nstatic void Main(string[] args)\n{\nSystem.Console.WriteLine(\"Test\");\nSystem.Random rnd = new System.Random();\nstring data = System.IO.File.ReadAllText(@\"c:\\temp\\data.txt\");\nCronberg.Hund hund = new Cronberg.Hund();\n}\n}\n}\nnamespace Cronberg {\nclass Hund { }\n}\n</code></pre> <p>skrives som</p> <pre><code>using Cronberg;\nusing System;\nusing System.IO;\nnamespace Demo\n{\nclass Program\n{\nstatic void Main(string[] args)\n{\nConsole.WriteLine(\"Test\");\nRandom rnd = new System.Random();\nstring data = File.ReadAllText(@\"c:\\temp\\data.txt\");\nHund hund = new Hund();\n}\n}\n}\nnamespace Cronberg {\nclass Hund { }\n}\n</code></pre> <p>Man sparer alts\u00e5 lidt referencer og g\u00f8r koden nemmere og hurtigere at skrive. Kodeordet <code>using</code> st\u00e5r typisk i toppen af en fil, men kan ogs\u00e5 placeres i et namespace.</p>"},{"location":"030_KonsolApp.html#implicit-using","title":"Implicit using","text":"<p>Fra C# 10 kan man i projekt filen aktivere implicit using instruktioner:</p> <pre><code>&lt;Project Sdk=\"Microsoft.NET.Sdk\"&gt;\n\n    &lt;PropertyGroup&gt;\n        &lt;OutputType&gt;Exe&lt;/OutputType&gt;\n        &lt;TargetFramework&gt;net6.0&lt;/TargetFramework&gt;\n        &lt;ImplicitUsings&gt;enable&lt;/ImplicitUsings&gt;\n    &lt;/PropertyGroup&gt;\n\n&lt;/Project&gt;\n</code></pre> <p>Det vil automatisk s\u00e6tte f\u00f8lgende globale usings (her en konsol app):</p> <pre><code>using System;\nusing System.Collections.Generic;\nusing System.IO;\nusing System.Linq;\nusing System.Net.Http;\nusing System.Threading;\nusing System.Threading.Tasks;\n</code></pre>"},{"location":"030_KonsolApp.html#global-using","title":"Global using","text":"<p>Fra C# 10 er det muligt at benytte globale using instruktioner - evt i en fil for sig selv:</p> <p>Her er eksempelvis indholdet i en fil kaldet globalUsings.cs</p> <pre><code>global using System.Text.Json;\n</code></pre>"},{"location":"030_KonsolApp.html#using-alias","title":"using - alias","text":"<p>Man kan nogle gange have en fordel ved at benytte et alias - is\u00e6r hvis der er risiko for navne sammenfald:</p> <pre><code>using IO = System.IO;\nusing Cronberg;\nnamespace Demo\n{\nclass Program\n{\nstatic void Main(string[] args)\n{\nIO.FileInfo f1;\nFileInfo f2;\n}\n}\n}\nnamespace Cronberg {\nclass FileInfo { }\n}\n</code></pre>"},{"location":"030_KonsolApp.html#static-using","title":"static using","text":"<p>Brug af <code>static using</code> giver hurtig adgang til statiske medlemmer:</p> <pre><code>using static System.IO.File;\nusing static System.Console;\nnamespace Demo\n{\nclass Program\n{\nstatic void Main(string[] args)\n{\nvar s = ReadAllLines(@\"c:\\temp\\data.txt\");\nWriteLine(s);\n}\n}\n}\n</code></pre>"},{"location":"030_KonsolApp.html#brug-af-console-klassen","title":"Brug af Console-klassen","text":"<p>Console-klassen best\u00e5r af en masse statiske metoder (man beh\u00f8ver ikke skabe en instans for at bruge dem), men i virkeligheden er den vigtigste WriteLine(). Den skriver blot ud p\u00e5 konsolen. Den kan eventuelt kombineres med Write(), som ogs\u00e5 udskriver blot uden linjeskift:</p> <pre><code>using System;\nnamespace Demo\n{\nclass Program\n{\nstatic void Main(string[] args)\n{\nConsole.WriteLine(\"Skriver en tekst...\");\nstring a = \"Skriver en anden tekst\";\nConsole.WriteLine(a);\n// Tom linje\nConsole.WriteLine();\n// Skriver uden linjeskrift\nConsole.Write(\"a\");\nConsole.Write(\"b\");\nConsole.Write(\"c\");\nConsole.WriteLine();\n}\n}\n}\n</code></pre> <p>Det kan ogs\u00e5 v\u00e6re praktisk at kunne l\u00e6se fra consol og m\u00e5ske skifte farve:</p> <pre><code>using System;\nnamespace Demo\n{\nclass Program\n{\nstatic void Main(string[] args)\n{\n// L\u00e6s fra linje\nstring input = Console.ReadLine();\nConsoleKeyInfo k = Console.ReadKey();\nif (k.Key == ConsoleKey.A) { }\nif (k.Key == ConsoleKey.Escape) { }\n// Farve\nConsole.ForegroundColor = ConsoleColor.Red;\nConsole.WriteLine(\"R\u00f8d\");\nConsole.ForegroundColor = ConsoleColor.Gray;\n}\n}\n}\n</code></pre>"},{"location":"030_KonsolApp.html#argumenter-til-afvikling","title":"Argumenter til afvikling","text":"<p>N\u00e5r en konsol applikation startes fra kommandoprompt kan eventuelle argumenter afl\u00e6ses gennem args-arrayet - ved eksempelvis:</p> <pre><code>dotnet demo.dll /a /b\n</code></pre> <p>best\u00e5r args af</p> <pre><code>[0] \"/a\"\n[1] \"/b\"\n</code></pre>"},{"location":"030_KonsolApp.html#pakker-til-at-hjlpe-med-args","title":"Pakker til at hj\u00e6lpe med args","text":"<p>Der findes masser af NuGet pakker til at hj\u00e6lpe med at splitte args - eksempelvis little-sharps/args eller commandlineparser/commandline. Sidstn\u00e6vnte er nok den st\u00f8rste og er rimelig nem i brug - her er en simpel skabelon:</p> <pre><code>using System;\nusing System.Collections.Generic;\nusing CommandLine;\n// Kr\u00e6ver NuGet pakken CommandLineParser\nnamespace ConsoleApp1\n{\nclass Program\n{\nstatic void Main(string[] args)\n{\nParser.Default.ParseArguments&lt;Options&gt;(args)\n.WithParsed(Run)\n.WithNotParsed(HandleParseError);\n}\nprivate static void Run(Options opts)\n{\nstring json = System.Text.Json.JsonSerializer.Serialize(opts);\nConsole.WriteLine(\"Start with: \" + json);\n}\nprivate static void HandleParseError(IEnumerable&lt;Error&gt; errs)\n{\nif (errs.IsVersion())\n{\nConsole.WriteLine(\"More info about version\");\nreturn;\n}\nif (errs.IsHelp())\n{\nConsole.WriteLine(\"More info about help\");\nreturn;\n}\n// More code related to error handling\n}\n}\nclass Options\n{\n[Option('a', \"text for a\", Required = false, HelpText = \"Help text for a\")]\npublic bool A { get; set; }\n[Option('b', \"text for b\", Required = true, HelpText = \"Help text for b\")]\npublic string B { get; set; }\n[Option('c', \"text for c\", Required = false, HelpText = \"Help text for c\")]\npublic int C { get; set; }\n}\n}\n</code></pre> <p>Husk at du nemt kan teste start fra kommandolinjen fra fanen debug p\u00e5 egenskaberne p\u00e5 selve projektet.</p> <p>Info</p>"},{"location":"030_KonsolApp.html#opgave-30-1","title":"Opgave 30-1","text":"<p>Opgave i h\u00e5ndtering af parametre fra kommandoprompt (kode til s\u00f8gning: DAB)</p> <p>Se opgave</p>"},{"location":"030_KonsolApp.html#async-console-applikation","title":"Async console applikation","text":"<p>Hvis du skrive kode der benytter async og await kan du med fordel erstatte den almindelige konsol skabelon fra:</p> <pre><code>namespace Demo\n{\nclass Program\n{\nstatic void Main(string[] args)\n{\n}\n}\n}\n</code></pre> <p>til</p> <pre><code>using System.Threading.Tasks;\nnamespace Demo\n{\nclass Program\n{\nstatic async Task Main(string[] args)\n{\n// nu er await mulig\nawait Task.Run(() =&gt; { });\n}\n}\n}\n</code></pre>"},{"location":"030_KonsolApp.html#xml-kommentar","title":"XML kommentar","text":"<p>/// giver mulighed for en special dokumentation, som efterf\u00f8lgende kan udtr\u00e6kkes til en hj\u00e6lpefil. Den giver i \u00f8vrigt VS yderligere information om metoder og typer:</p> <pre><code>/// &lt;summary&gt;\n/// Beskrivelse af MinMetode\n/// &lt;/summary&gt;\n/// &lt;param name=\"a\"&gt;Beskrivelse af argument&lt;/param&gt;\n/// &lt;param name=\"b\"&gt;Beskrivelse af argument&lt;/param&gt;\nvoid MinMetode(int a, bool b) { }\n</code></pre> <p>Brug /// som snippet.</p>"},{"location":"040_simplevariabler.html","title":"Simple variabler","text":""},{"location":"040_simplevariabler.html#om-modulet","title":"Om modulet","text":"<p>Dette modul vil introducere dig simple variabler. Hvis du kommer fra andre sprog, og kender til allokering af hukommelse mv, s\u00e5 kan du roligt springe den f\u00f8rste sektion over.</p> <p>Herefter ser vi p\u00e5 erkl\u00e6ring og brug af variabler relateret til tal. Hvis du er ny i C# programmering er det vigtigt at du pr\u00f8ver selv - b\u00e5de ved at g\u00f8re det samme som jeg g\u00f8r i forel\u00e6sning/video, og ved at lave de sm\u00e5 opgaver.</p> <p>Det er ogs\u00e5 vigtigt at du kender til grundl\u00e6ggende typekonvertering.</p> <p>Der er nogle opgaver til dette modul, og det er vigtigt du f\u00e5r dem lavet. Fortvivl ikke hvis du tosser for meget rundt i syntaks - det falder p\u00e5 plads med tiden. Hvis det kokser helt s\u00e5 start forfra og kopi\u2019er fra l\u00f8sningen og f\u00e5 det til at virke. S\u00e5 m\u00e5 du vende tilbage til opgaverne efterf\u00f8lgende.</p> <p>Opgaverne er et eksternt link (github), men til opgaverne er der (udover en l\u00f8sning i kode) ogs\u00e5 en video der viser der hvordan den kan l\u00f8ses. Link til disse \u201copgave-video\u2019er\u201d vil v\u00e6re at finde i opgave teksten.</p> <p>S\u00e5....</p> <ul> <li>Forst\u00e5 hvad en simpel variabel er og hvordan man erkl\u00e6re og benytter den</li> <li>Forst\u00e5 de grundl\u00e6ggende operatorer</li> <li>Forst\u00e5 hvad typekonvertering er</li> </ul> <p>Kod s\u00e5 meget som muligt!</p>"},{"location":"040_simplevariabler.html#grundlggende-om-variabler","title":"Grundl\u00e6ggende om variabler","text":"<p>En C# app bliver automatisk tildelt et omr\u00e5de i hukommelsen at boltre sig p\u00e5 - noget bliver brugt til det oversatte program (flow, metoder mv), og noget til midlertidige data</p> <ul> <li>Stack</li> <li>Heap</li> </ul> <p></p> <p>Hukommelse er jo i realiteten en samling elektroniske komponenter (porte og kredsl\u00f8b) der kan gemme tal som bin\u00e6re v\u00e6rdier.</p>"},{"location":"040_simplevariabler.html#variabler","title":"Variabler","text":"<p>Alle applikationer har behov for at gemme midlertidige data, og i de fleste programmeringssprog sker dette ved hj\u00e6lp af variabler.</p> <p>C# er typest\u00e6rkt s\u00e5 kompileren ved pr\u00e6cis hvor meget der skal afs\u00e6ttes i hukommelsen. I stedet for at vi selv skal s\u00f8rge for at allokere hukommelse, og efterf\u00f8lgende holde styr p\u00e5 hvor i hukommelsen vi skal finde data, s\u00e5 stiller kompileren variabler til r\u00e5dighed. I realiteten er det blot en tabel over n\u00f8gler (variabel navne) og adresser i hukommelsen samt allokeret plads.</p> <p></p>"},{"location":"040_simplevariabler.html#typesystemet","title":"Typesystemet","text":"<p>Mange forskellige typer i .NET:</p> <ul> <li>Heltal af forskellig st\u00f8rrelse</li> <li>Reelle tal (kommatal) af forskellig st\u00f8rrelse</li> <li>Dato og tid</li> <li>Boolske v\u00e6rdier (sand/falsk)</li> <li>Tegn eller tekster (ogs\u00e5 kaldet strenge)</li> <li>Referencer til objekter eller strukturer</li> </ul> <p>Typerne er opdelt i</p> <ul> <li> <p>ValueTypes (v\u00e6rdibaserede typer)</p> <ul> <li>Struct<ul> <li>bool (System.Boolean)</li> <li>int (System.Int32)</li> <li>float (System.Float)</li> <li>decimal (System.Decimal)</li> <li>DateTime (System.DateTime)</li> <li>\u2026</li> </ul> </li> </ul> </li> <li> <p>ReferenceTypes (referencebaserede typer)</p> <ul> <li>Class<ul> <li>string (System.String)</li> <li>arrays (System.Array)</li> <li>lister (System.Collection.Generic....)</li> <li>exceptions (System.Exception)</li> <li>\u2026</li> </ul> </li> </ul> </li> </ul> <p>Grundl\u00e6ggende er forskellen p\u00e5 de to typer, at v\u00e6rdier fra v\u00e6rdibaserede variabler er placeret et sted i hukommelsen kaldet stak, og v\u00e6rdier fra de referencebaserede variabler er placeret et andet sted i hukommelse kaldet heap. Variabler af begge typer er placeret p\u00e5 stak\u2019en men de v\u00e6rdibaserede typer indeholder konkrete v\u00e6rdier (ved heltal er v\u00e6rdien et konkret tal), medens variabler af referencebasrede typer indeholder referencer til et sted p\u00e5 heap\u2019en. Meget mere om det senere.</p>"},{"location":"040_simplevariabler.html#erklring-af-variabler","title":"Erkl\u00e6ring af variabler","text":"<p>F\u00f8rst angives typen</p> <ul> <li>C# typenavn eller System-typenavn</li> </ul> <p>Herefter navnet p\u00e5 variablen</p> <pre><code>[variabeltype] [navn]\n</code></pre> <p>Husk - der er forskel p\u00e5 store og sm\u00e5 bogstaver</p> <ul> <li>A er forskellig fra a</li> <li>navnP\u00e5Person er forskellig fra navnp\u00e5person</li> </ul> <p>Navngivning</p> <ul> <li>Navnet skal begynde med et bogstav eller en underscore (_)</li> <li>Navnet m\u00e5 ikke kun best\u00e5 af underscores</li> <li>Navnet m\u00e5 kun best\u00e5 af bogstaver, tal eller underscores</li> <li>Man m\u00e5 gerne p\u00e5 \u00c6 \u00d8 \u00c5 (men b\u00f8r man?)</li> </ul> <p>Navngivningsstandard</p> <ul> <li>Tal dansk eller engelsk?</li> <li>Design Guidelines (http://goo.gl/YVxNz)</li> <li>Brug eventuelt .editorconfig</li> </ul> <p>Eksempler p\u00e5 navngivning af lokale variabler</p> <pre><code>int antal;\nint antalM\u00e5neder;\nint antalM\u00e5nederPr\u00c5r;\nstring navnP\u00e5Person;\n</code></pre> <p>Man kan v\u00e6lge at bruge system navne (men best pratice er brug af genvejsnavne):</p> <pre><code>System.Int32 antal;\nSystem.Int32 antalM\u00e5neder;\nSystem.Int32 antalM\u00e5nederPr\u00c5r;\nSystem.String navnP\u00e5Person;\n</code></pre> <p>Variablen kan eventuelt tildeles en v\u00e6rdi ved erkl\u00e6ring</p> <pre><code>int antal = 1;\nint antalM\u00e5neder = 6;\nint antalM\u00e5nederPr\u00c5r = 12;\nstring navnP\u00e5Person = \"abc\";\n// Brug evt systemnavn - giver det samme\n// System.String navnP\u00e5Person = \"abc\";\n</code></pre> <p>Man kan v\u00e6lge at benytte <code>new</code> ved oprettelse af simple variabler - men det er ikke n\u00f8dvendigt ved de fleste simple v\u00e6rdibaserede variabler:</p> <pre><code>int a;\na = 10;\nint b = new int();\nb = 10;\nSystem.Int32 c = new System.Int32();\nc = 10;\n</code></pre>"},{"location":"040_simplevariabler.html#brug-af-var","title":"Brug af var","text":"<p>var-kodeordet er et avanceret compilertrick</p> <ul> <li>Brug evt var ved erkl\u00e6ring af variabler</li> <li>Skal tildeles en v\u00e6rdi ved erkl\u00e6ring</li> <li>Stadig type sikker</li> <li>heltal = int som default</li> <li>kommatal = double som default</li> </ul> <pre><code>var a = 10;                 // int\n// a = \"\";                  // Fejl - erkl\u00e6ret som int tidligere\nvar b = 11.2;               // double\nvar c = \"a\";                // string\nvar d = 'b';                // char\nvar e = DateTime.Now;       // DateTime\n</code></pre> <p>Nogle gang er det sv\u00e6rt at udlede typen fra et udtryk - s\u00e5 kan var v\u00e6re smart at bruge var</p> <pre><code>var f = new int[] { 4, 3, 1, 6, 4, 3, 2, 6 }; // int[]\nvar g = f.GroupBy(i =&gt; i);          // IGrouping&lt;int, int&gt;\n// I den avancerede C# benyttes var blandt andet til anonyme typer\nvar h = new { navn =  \"Mikkel\" };\n</code></pre>"},{"location":"040_simplevariabler.html#virkefelter-stack-og-heap","title":"Virkefelter, Stack og Heap","text":"<p>N\u00e5r du ser et virkefelt i C# (<code>{ }</code>) skal du tegne en tegning i hovedet (Stack-definition).</p> <pre><code>{\n// virkefelt\n}\n// betingelse\nbool a = true;\nif (a == true)\n{\n// virkefelt\n}\n// l\u00f8kke\nfor (int i = 0; i &lt; 4; i++)\n{\n// Virkefelt\n}\n// metode\nvoid Test()\n{\n// Virkefelt\n}\n</code></pre> <p>Den fort\u00e6ller hvilke variabler der er tilg\u00e6ngelige i det givne virkefelt, og hvilken v\u00e6rdier (eller reference) disse variabler har.</p> <p></p> <p>Hvis et virkefelt er placeret i et andet virkefelt m\u00e5 du tegne det som en stack i en stack</p> <p></p> <p>Indre virkefelter har adgang til variabler i de ydre virkefelter - ikke omvendt (og ikke virkefelter p\u00e5 samme niveau).</p> <pre><code>int a = 1;\nConsole.WriteLine($\"a = {a}\");\n{\nint b = 2;\nConsole.WriteLine($\"a = {a}\");\nConsole.WriteLine($\"b = {b}\");\n{\nint c = 3;\nConsole.WriteLine($\"a = {a}\");\nConsole.WriteLine($\"b = {b}\");\nConsole.WriteLine($\"c = {c}\");\n}\n}\n</code></pre> <p>De fleste simple variabeltyper beholder v\u00e6rdien p\u00e5 stacken, men enkelte typer placerer v\u00e6rdien andre steder i hukommelsen (den s\u00e5kaldte heap), og variablens v\u00e6rdi er s\u00e5 en reference til et andet sted i hukommelsen. Mere om det senere!</p>"},{"location":"040_simplevariabler.html#instans-medlemmer-og-statiske-medlemmer","title":"Instans medlemmer og statiske medlemmer","text":"<p>Der er forskel p\u00e5 om man benytter instanser af datatypen eller typens statiske medlemmer</p> <pre><code>int i = 10;\n// instans medlem\nConsole.WriteLine(i.ToString());\n// statisk medlem\nConsole.WriteLine(int.MinValue);\nDateTime d = new DateTime(2018, 1, 1);\n// instans medlem\nConsole.WriteLine(d.ToLongDateString());\n// statisk medlemmer\nConsole.WriteLine(DateTime.Now);\nConsole.WriteLine(DateTime.IsLeapYear(2018));\n</code></pre>"},{"location":"040_simplevariabler.html#tal","title":"Tal","text":""},{"location":"040_simplevariabler.html#heltal","title":"Heltal","text":".NET C# Forklaring Sp\u00e6nd Litral suffix System.Byte byte 8-bit heltal uden fortegn 0 til 255 System.Int16 short 16-bit heltal med fortegn -32.768 til 32.767 System.Int32 int 32-bit heltal med fortegn -2.147.483.648 til 2.147.483.647 System.Int64 long 64-bit heltal med fortegn -9.223.372 til 9.223.372 (trillioner) L eller l <pre><code>byte a;\nshort b;\nint c;\nlong d;\na = 10;\n// a = 500;   Vil skabe en fejl fordi 500 ikke kan repr\u00e6senteres af 8 bit\nb = 10000;\n// b = 50000; Vil skabe en fejl fordi 50000 ikke kan repr\u00e6senteres af 16 bit\nc = 1000000000;\nd = 1000000000000000000;\nint e = 1;  // initialisering ved erkl\u00e6ring\n</code></pre>"},{"location":"040_simplevariabler.html#reelle-tal","title":"Reelle tal","text":".NET C# Forklaring Betydende cifre Litral suffix System.Single float 32-bit reelt tal (floating point) omkring 7 F eller f System.Double double 64-bit reelt tal (floating point) omkring 15 D eller d System.Decimal decimal 128-bit reelt tal omkring 28 M eller m <pre><code>float a;\ndouble b;\ndecimal c;\n// eksempler:\na = 0.00000387326299309487F; // F konverterer en konstant til en float\nb = 0.000233;\nb = 838383629203242342342342342342342.234;\nc = 1208376382.23221M; // M konverterer en konstant til en decimal\n// Konstanter p\u00e5 typen\nConsole.WriteLine($\"double min = {System.Double.MinValue}\");    // MEGET lille tal\nConsole.WriteLine($\"double max = {System.Double.MaxValue}\");    // MEGET stort tal\n</code></pre>"},{"location":"040_simplevariabler.html#mest-benyttede-variabler","title":"Mest benyttede variabler","text":"<p>De mest benyttede typer er int (32 bit) og double (64 bit). Begge er ogs\u00e5 default typer ved konstanter.</p>"},{"location":"040_simplevariabler.html#binre-og-hexadecimale-konstanter","title":"Bin\u00e6re og Hexadecimale konstanter","text":"<p>Der findes forskellige m\u00e5der benytte bin\u00e6re og hexadecimale konstanter :</p> <pre><code>{\nint svaretP\u00e5Alt = 0b101010;\n}\n{\nint svaretP\u00e5Alt = 0x2A;\n}\n</code></pre>"},{"location":"040_simplevariabler.html#double-decimal","title":"double / decimal","text":"<p>Pas lige p\u00e5 med double (64 bit) - typen er en base2 type og benytter floating point hvilke kan give nogle afrundningsfejl.</p> <pre><code>{\ndouble v = .1;\ndouble r = v + v + v + v + v + v + v + v + v + v;\n// r = 0.99999999999999989\n}\n{\ndecimal v = .1M;\ndecimal r = v + v + v + v + v + v + v + v + v + v;\n// r = 1\n}\n</code></pre> <p>Til geng\u00e6ld er den vanvittig hurtig - som i 20 gange hurtigere end decimal (kode fra exceptionnotfound):</p> <pre><code>private static int iterations = 100000000;\nprivate static void DoubleTest()\n{\nStopwatch watch = new Stopwatch();\nwatch.Start();\nDouble z = 0;\nfor (int i = 0; i &lt; iterations; i++)\n{\nDouble x = i;\nDouble y = x * i;\nz += y;\n}\nwatch.Stop();\nConsole.WriteLine(\"Double: \" + watch.ElapsedTicks);\nConsole.WriteLine(z);\n}\nprivate static void DecimalTest()\n{\nStopwatch watch = new Stopwatch();\nwatch.Start();\nDecimal z = 0;\nfor (int i = 0; i &lt; iterations; i++)\n{\nDecimal x = i;\nDecimal y = x * i;\nz += y;\n}\nwatch.Stop();\nConsole.WriteLine(\"Decimal: \" + watch.ElapsedTicks);\nConsole.WriteLine(z);\n}\n</code></pre> <p>Brug double hvor pr\u00e6cision har lavere prioritet end hastighed.</p>"},{"location":"040_simplevariabler.html#operatorer-relateret-til-tal","title":"Operatorer relateret til tal","text":"Operator Forklaring + Plus - Minus * Gange / Division % Modulus (returnerer resten ved en division) <pre><code>int tal1 = 2;\nint tal2 = 5;\nint resultat1 = tal1 + tal2;\nConsole.WriteLine($\"Resultat1 = {resultat1}\");\nint resultat2 = tal2 - tal1;\nConsole.WriteLine($\"Resultat2 = {resultat2}\");\nint resultat3 = tal1 * tal2;\nConsole.WriteLine($\"Resultat3 = {resultat3}\");\nint antalM\u00e5neder = 12;\ndouble \u00e5rsl\u00f8n = 300000;\ndouble gennemsnitligL\u00f8n = \u00e5rsl\u00f8n / antalM\u00e5neder;\nConsole.WriteLine($\"Gennemsnit = {gennemsnitligL\u00f8n}\");\nint resultat4 = tal2 % tal1;\nConsole.WriteLine($\"Resultat4 = {resultat4}\");\n// Pas p\u00e5 med at dividere heltal\nint a1 = 10;\nint b1 = 3;\nint c1 = a1 / b1;\nint d1 = a1 % b1;\nConsole.WriteLine($\"a1 = {a1}\");\nConsole.WriteLine($\"b1 = {b1}\");\nConsole.WriteLine($\"c1 = {c1}\");\nConsole.WriteLine($\"d1 = {d1}\");\ndouble a2 = 10;\ndouble b2 = 3;\ndouble c2 = a2 / b2;\ndouble d2 = a2 % b2;\nConsole.WriteLine($\"a2 = {a2}\");\nConsole.WriteLine($\"b2 = {b2}\");\nConsole.WriteLine($\"c2 = {c2}\");\nConsole.WriteLine($\"d2 = {d2}\");\n// Brug parentes\ndouble a3 = 10 - 5 / 5;\ndouble b3 = (10 - 5) / 5;\nConsole.WriteLine($\"a3 = {a3}\");\nConsole.WriteLine($\"b3 = {b3}\");\n</code></pre> Operator Forklaring += Adderer og tildeler v\u00e6rdien af en variabel med en v\u00e6rdi. -= Subtraherer og tildeler v\u00e6rdien af en variabel med en v\u00e6rdi. *= Multiplicerer og tildeler v\u00e6rdien af en variabel med en v\u00e6rdi. /= Dividerer og tildeler v\u00e6rdien af en variabel med en v\u00e6rdi. ++ For\u00f8ger en variabel med en. \u2013 Formindsker en variabel med en. <pre><code>int a = 10;\nConsole.WriteLine($\"a = {a}\");\na = a + 10;\nConsole.WriteLine($\"a = {a}\");\na += 10;\nConsole.WriteLine($\"a = {a}\");\nint b = 50;\nConsole.WriteLine($\"b = {b}\");\nb = b - 10;\nConsole.WriteLine($\"b = {b}\");\nb -= 10;\nConsole.WriteLine($\"b = {b}\");\nint c = 10;\nConsole.WriteLine($\"c = {c}\");\nc = c * 2;\nConsole.WriteLine($\"c = {c}\");\nc *= 2;\nConsole.WriteLine($\"c = {c}\");\nint d = 10;\nConsole.WriteLine($\"d = {d}\");\nd++;\nConsole.WriteLine($\"d = {d}\");\nint e = 10;\nConsole.WriteLine($\"e = {e}\");\ne--;\nConsole.WriteLine($\"e = {e}\");\nint f = 1;\nif (f++ == 1)\n{\nConsole.WriteLine($\"f = 1\");\n}\n// nu er f = 2\nif (--f == 1)   // f = 1 igen (f\u00f8r check)\n{\nConsole.WriteLine($\"f = 1\");\n}\n</code></pre> <p>Info</p>"},{"location":"040_simplevariabler.html#opgave-40-1","title":"Opgave 40-1","text":"<p>Simpel brug af forskellige tal og operatorer (l\u00f8sning med video) (kode til s\u00f8gning: EAB)</p> <p>Se opgave</p>"},{"location":"040_simplevariabler.html#overflow","title":"Overflow","text":"<p>Brug checked hvis overflow skal skabe exception</p> <pre><code>{\nbyte b = 255;\nConsole.WriteLine($\"b={b}\");\nb++;\nConsole.WriteLine($\"b={b}\");\n}\nchecked\n{\nbyte b = 255;\nConsole.WriteLine($\"b={b}\");\n// b++; skaber et overflow\n}\n</code></pre>"},{"location":"040_simplevariabler.html#andre-datatyper","title":"Andre datatyper","text":"<p>Der findes flere andre datatyper som ikke er s\u00e5 brugt:</p> .NET C# Forklaring Sp\u00e6nd System.SByte sbyte 8-bit heltal med fortegn -127 til 128 System.UInt16 ushort 16-bit heltal uden fortegn 0 til 65,535 System.UInt32 uint 32-bit heltal uden fortegn 0 til 4.294.967.295 System.UInt64 ulong 64-bit heltal uden fortegn 0 til 18.446.744.073.709.551.615"},{"location":"040_simplevariabler.html#store-heltal","title":"Store heltal","text":"<p>Hvis man \u00f8nsker meget store helttal - som i tal uden en nedre eller \u00f8vre gr\u00e6nse - kan du bruge strukturen System.Numerics.BigInterger. Se mere p\u00e5</p> <p>https://docs.microsoft.com/en-us/dotnet/api/system.numerics.biginteger</p>"},{"location":"040_simplevariabler.html#komplekse-tal","title":"Komplekse tal","text":"<p>Hvis man \u00f8nsker at regne med komplekse tal findes der i frameworket strukturen System.Numerics.Complex. Den best\u00e5r af b\u00e5de et reelt og et imagin\u00e6rt tal. Se mere p\u00e5</p> <p>https://docs.microsoft.com/en-us/dotnet/api/system.numerics.complex</p>"},{"location":"040_simplevariabler.html#formatering-af-tal","title":"Formatering af tal","text":"<p>Mange muligheder</p> <ul> <li>Brug af ToString()</li> <li>Formateringstegn hos MS Standard Numeric Format Strings</li> </ul> <pre><code>double tal = 20034.3347;                  // g\u00e6lder ogs\u00e5 for heltal\nConsole.WriteLine(tal.ToString());        // r\u00e5 konvertering\nConsole.WriteLine(tal.ToString(\"N2\"));    // Brug af tusindtalsseparator og decimaler\nConsole.WriteLine(tal.ToString(\"N3\"));    // Brug af tusindtalsseparator og decimaler\nConsole.WriteLine(tal.ToString(\"F2\"));    // Decimaler\nConsole.WriteLine(tal.ToString(\"C2\"));    // Bel\u00f8b\ndouble pct = 0.25;\nConsole.WriteLine(pct.ToString(\"P2\"));    // Procent og decimaler\n// til en-US\nConsole.WriteLine(\ntal.ToString(\"N2\",\nnew System.Globalization.CultureInfo(\"en-US\")));  // 20,034.33\n// Du kan ogs\u00e5 overveje at s\u00e6tte kultur p\u00e5 selve applikationen (tr\u00e5den)\nSystem.Threading.Thread.CurrentThread.CurrentCulture =\nnew System.Globalization.CultureInfo(\"en-US\");\n// Herefter er alt p\u00e5 amerikansk\n</code></pre>"},{"location":"040_simplevariabler.html#sand-eller-falsk","title":"Sand eller falsk","text":"<p>System.Boolean er typenavnet men man bruger typisk bool</p> .NET C# Forklaring System.Boolean bool True/False (8 bit)"},{"location":"040_simplevariabler.html#standard-operatorer","title":"Standard operatorer","text":"<p>| Operatorer | Forklaring           | | ---------- | -------------------- | \u2014 | ----------- | | ==         | Lig med              | | !=         | Forskellig fra       | | &gt;          | St\u00f8rre end           | | &lt;          | Mindre end           | | &gt;=         | St\u00f8rre end og ligmed | | &lt;=         | Mindre end og ligmed | | &amp;&amp;         | And (logisk)         | | <code>|                      |</code>   | Or (logisk) | | !          | Not (modsat)         |</p>"},{"location":"040_simplevariabler.html#bit-relaterede-operatorer","title":"Bit relaterede operatorer","text":"<p>| Operatorer | Forklaring  | | ---------- | ----------- | -------- | | &amp;          | And (bit)   | | <code>|</code>           | Or (bit) | | <code>^</code>        | Xor (bit)   | | &gt;&gt;         | Shift (bit) | | &lt;&lt;         | Shift (bit) |</p> <pre><code>bool a;\na = true;\nbool b = false;\nbool c = !b;\nbool d = a &amp;&amp; b;\nbool e = a || b;\nif (a == true) { }\nif (a) { }\nif (b == false) { }\nif (!b) { }\nif (1 == 0 &amp;&amp; 2 == 2)\n{\n}\nif (a == b || c == false)\n{\n}\nif ((a == b || c == false) &amp;&amp; e == true)\n{\n}\n// Avanceret\nint t1 = 10;        // 00001010 = 10\nint t2 = 22;        // 00010110 = 22\nint f = t1 &amp; t2;    // 00000010 = 2  (AND)\nint g = t1 | t2;    // 00011110 = 30 (OR)\nint h = t1 ^ t2;    // 00011100 = 28 (XOR)\nint i = t1 &lt;&lt; 1;    // 00010100 = 20 (shift left)\nint j = t1 &gt;&gt; 1;    // 00000101 = 5 (shift right)\nConsole.WriteLine($\"a = {a}\");\nConsole.WriteLine($\"b = {b}\");\nConsole.WriteLine($\"c = {c}\");\nConsole.WriteLine($\"d = {d}\");\nConsole.WriteLine($\"e = {e}\");\nConsole.WriteLine($\"f = {f}\");\nConsole.WriteLine($\"g = {g}\");\nConsole.WriteLine($\"h = {h}\");\nConsole.WriteLine($\"i = {i}\");\nConsole.WriteLine($\"j = {j}\");\n/*\n ---------- Output: ----------\na = True\nb = False\nc = True\nd = False\ne = True\nf = 2\ng = 30\nh = 28\ni = 20\nj = 5\n*/\n</code></pre>"},{"location":"040_simplevariabler.html#bonus-info-det-behver-du-ikke-vide-men","title":"Bonus info (det beh\u00f8ver du ikke vide\u2026 men\u2026 )","text":"<p>Check lige George Boole (1815-1864) - ham alle IT udviklere b\u00f8r kende til.</p> <ul> <li>Far til boolsk algebra<ul> <li>Logiske beregninger/formler med klasser/set af elementer (ikke tal) og operatorer som eksempelvis + (or), x (and) og 1 (not)</li> </ul> </li> </ul> <p>Og check Claude Shannon (1916-2001), som videre udviklede George Boole\u2019s tanker til elektroniske kredsl\u00f8b omkring 1937.</p> <p>Og medens du er igang - John Bardeen (1908-1991), William Bradford Shockley (1910-1989) and Walter Houser Brattain (1902-1987) - som fik Nobel prisen i Fysik i 1956 for deres arbejde indenfor halvledere og transitorer.</p> <p>Og sluttelig Jack Kilby (1923-2005) som opfandt IC kredse i 1950\u2019erne (Nobel prisen i fysik i 2000).</p> <p>Fra George Boole til moderne CPU\u2019er - s\u00e5 der er en grund til at en bool hedder en bool ;)</p>"},{"location":"040_simplevariabler.html#dato-og-tid","title":"Dato og tid","text":"<p>System.DateTime</p> <ul> <li>ticks (100 nanosekunder) fra og med 1. januar i \u00e5r 1,</li> <li>intet alias (som System.Int32=int)</li> </ul> .NET C# Forklaring System.DateTime (findes ikke) ticks fra 1/1/1 (64 bit) <pre><code>System.DateTime a;\na = DateTime.Now;   // nu\n// eller System.DateTime a = DateTime.Now;\n// ingen dato-literal ala (endnu)\n// DateTime x = #2017-5-5#; (VIRKER IKKE)\n// man skal bruge new DateTime(...)\nSystem.DateTime b;\nb = new DateTime(2017, 12, 24, 18, 30, 00);     // angivet dato og tid\nSystem.DateTime c = new DateTime(2017, 12, 24); // angivet dato\n*/\n</code></pre> <p>Mange metoder og egenskaber til datoberegninger</p> <ul> <li>DateTime Struct - MS ref</li> <li>Formatering af datoer (MS): Custom Date and Time Format Strings</li> </ul> <pre><code>System.DateTime a;\na = DateTime.Now;   // nu\nConsole.WriteLine($\"a = {a.ToString()}\");\na = a.AddDays(1);\nConsole.WriteLine($\"a = {a.ToString()}\");\na = a.AddHours(26);\nConsole.WriteLine($\"a = {a.ToString()}\");\na = a.AddSeconds(2000);\nConsole.WriteLine($\"a = {a.ToString()}\");\nConsole.WriteLine($\"M\u00e5ned {a.Month}\");\nConsole.WriteLine($\"Dag {a.Day}\");\nConsole.WriteLine($\"\u00c5r {a.Year}\");\nConsole.WriteLine($\"Dag p\u00e5 \u00e5ret {a.DayOfYear}\");\nConsole.WriteLine($\"Ugedag {a.DayOfWeek.ToString()}\");\nConsole.WriteLine($\"Lille dato streng {a.ToShortDateString()}\");\nConsole.WriteLine($\"Stor dato streng {a.ToLongDateString()}\");\nConsole.WriteLine($\"Lille tid streng {a.ToShortTimeString()}\");\nConsole.WriteLine($\"Stor tid streng {a.ToLongTimeString()}\");\n// Brug af ToString med forskellige formateringstegn\nConsole.WriteLine($\"dd-MM-yyyy HH:ss {a.ToString(\"dd-MM-yyyy HH:ss\")}\");\nConsole.WriteLine($\"MMMMM {a.ToString(\"MMMMM\")}\");\nConsole.WriteLine($\"MMM {a.ToString(\"MMM\")}\");\n// Ugenummer (brug Calendar for den konkrete kultur)\nvar c = new System.Globalization.CultureInfo(\"da-DK\");\nvar nr = c.Calendar.GetWeekOfYear(DateTime.Now,\nSystem.Globalization.CalendarWeekRule.FirstDay,\nDayOfWeek.Monday);\nConsole.WriteLine($\"Ugenummer {nr}\");\n</code></pre>"},{"location":"040_simplevariabler.html#forskel-mellem-to-datetime-variabler","title":"Forskel mellem to DateTime-variabler","text":"<p>Brug System.TimeSpan.</p> <ul> <li>Kan ogs\u00e5 bruges til at repr\u00e6sentere tid uden dato.</li> </ul> <pre><code>// Beregninger\nSystem.DateTime a;\na = new DateTime(2017, 6, 1, 0, 0, 0);\nSystem.DateTime b;\nb = new DateTime(2017, 12, 24, 18, 30, 00);\nSystem.TimeSpan c = b.Subtract(a);  // Forskellen mellem a og b\nConsole.WriteLine($\"Forskel mellem a og b i dage = {c.TotalDays}\");\nConsole.WriteLine($\"Forskel mellem a og b i timer = {c.TotalHours}\");\nConsole.WriteLine($\"Forskel mellem a og b i minutter = {c.TotalMinutes}\");\n// Tid\nSystem.DateTime d = System.DateTime.Now;\nTimeSpan e = d.TimeOfDay;\nConsole.WriteLine($\"e = {e.ToString()}\");\nTimeSpan f = new TimeSpan(13, 0, 0);\nConsole.WriteLine($\"f = {f.ToString()}\");\nf = f + new TimeSpan(1, 30, 0);\nConsole.WriteLine($\"f = {f.ToString()}\");\n// Hvis man \u00f8nsker at formatere et TimeSpan er det (af en eller anden grund)\n// nemmest at konvertere til en DateTime, og s\u00e5 benytte almindelige formateringstegn\nTimeSpan a1 = new TimeSpan(9, 23, 0);\nDateTime b1 = new DateTime(a1.Ticks);\nConsole.WriteLine($\"b1 = {b1.ToString(\"HH:mm\")}\");\n/*\n ---------- Output: ----------\nForskel mellem a og b i dage = 206,770833333333\nForskel mellem a og b i timer = 4962,5\nForskel mellem a og b i minutter = 297750\ne = 16:01:39.0850165\nf = 13:00:00\nf = 14:30:00\nb1 = 09:23\n*/\n</code></pre>"},{"location":"040_simplevariabler.html#datetimeoffset","title":"DateTimeOffset","text":"<p>Der findes ligeledes en DateTimeOffset-struktur, som minder meget om DateTime-strukturen. Den kan benyttes hvis man \u00f8nsker st\u00f8rre kontrol over tidzoner. Se mere p\u00e5 https://docs.microsoft.com/en-us/dotnet/standard/datetime/choosing-between-datetime.</p>"},{"location":"040_simplevariabler.html#dateonly-og-timeonly","title":"DateOnly og TimeOnly","text":"<p>I C# 10 kom DateOnly og TimeOnly der som navnet antyder udelukkende indeholder dato og tid.</p> <p>Her er DateOnly i brug:</p> <pre><code>DateOnly d1 = new DateOnly(2021, 5, 31);\nConsole.WriteLine(d1.Year);      // 2021\nConsole.WriteLine(d1.Month);     // 5\nConsole.WriteLine(d1.Day);       // 31\nConsole.WriteLine(d1.DayOfWeek); // Mandag\n// Manipulation\nDateOnly d2 = d1.AddMonths(1);\nConsole.WriteLine(d2);\nint days = d2.DayNumber - d1.DayNumber;\nConsole.WriteLine($\"{days} dage mellem {d1} og {d2}\");\nDateOnly d3 = DateOnly.ParseExact(\"24 Dec 2021\", \"dd MMM yyyy\", System.Globalization.CultureInfo.InvariantCulture);\nConsole.WriteLine(d3);\nDateOnly nu = DateOnly.FromDateTime(DateTime.Today);\nConsole.WriteLine(nu);\nDateTime dt = d3.ToDateTime(new TimeOnly(0, 0));\nConsole.WriteLine(dt);\n</code></pre> <p>Og her TimeOnly</p> <pre><code>TimeOnly t1 = new TimeOnly(16, 30);\nConsole.WriteLine(t1.Hour);      // 16\nConsole.WriteLine(t1.Minute);    // 30\nConsole.WriteLine(t1.Second);    // 0\nTimeOnly t2 = t1.AddHours(10);  // 02:30\n// Hvor mange dage er der i 'overskud'\nTimeOnly t3 = t2.AddMinutes(5000, out int wrappedDays); // 13:50, 3 (3 dage efter)\n// Pas p\u00e5 r\u00e6kkef\u00f8lge n\u00e5r der tr\u00e6kkes fra\nTimeOnly t4 = new TimeOnly(2, 0);\nTimeOnly t5 = new TimeOnly(21, 0);\nTimeSpan x = t5 - t4;   // 19\nTimeSpan y = t4 - t5;   // 5\nTimeOnly t6 = TimeOnly.ParseExact(\"5:00 pm\", \"h:mm tt\", System.Globalization.CultureInfo.InvariantCulture);  // 17:00\n// Til TimeSpan\nTimeSpan ts = t6.ToTimeSpan();      // \"17:00:00\"\n// Til DateTime\nDateTime dt = new DateOnly(1970, 1, 1).ToDateTime(t6);\nTimeOnly nu = TimeOnly.FromDateTime(DateTime.Now);\n// I mellem ...\nif (nu.IsBetween(t1, t2))\n{\n}\nelse\n{\n}\n</code></pre> <p>Info</p>"},{"location":"040_simplevariabler.html#opgave-40-2","title":"Opgave 40-2","text":"<p>Opret og beregn p\u00e5 b\u00e5de DateTime og TimeSpan-variabler (kode til s\u00f8gning: EAC)</p> <p>Se opgave</p>"},{"location":"040_simplevariabler.html#implicit-typekonvertering","title":"Implicit typekonvertering","text":"<p>Konvertering fra en lille datatype til en stor datatype</p> <p></p> Datatype Kan implicit konverteres til byte short, int, long, float, double eller decimal short int, long, float, double eller decimal int long, float, double eller decimal long float, double eller decimal float double <pre><code>// Implicit (fra lille til stor)\nint lilleHeltal = 3000000;\nlong stortHeltal = lilleHeltal;\ndouble reeltTal = lilleHeltal;\n</code></pre>"},{"location":"040_simplevariabler.html#explicit-typekonvertering","title":"Explicit typekonvertering","text":"<p>Konvertering fra en stor datatype til en lille datatype</p> <p></p> <p>brug System.Convert som indeholder en masse konverteringsmetoder.</p> <ul> <li>ToInt32()</li> <li>ToDouble()</li> <li>ToBoolean()</li> <li>ToChar()</li> </ul> <p>og mange flere.</p> <pre><code>double a = 4030.75;\nint b = System.Convert.ToInt32(a);  // 4.031\nstring c = \"100\";\nint d = System.Convert.ToInt32(c);  // 100\n// foruds\u00e6tter afvikling p\u00e5 en dansk maskine\nstring e = \"23,45\";\ndouble f = System.Convert.ToDouble(e);  // 23.45\nstring g = \"2012-7-23\";\nDateTime h = System.Convert.ToDateTime(g);  // 2012-07-23\nstring i = \"2019-8-1 15:35\";\nDateTime j = System.Convert.ToDateTime(i);  // 2019-08-01 15:15\n</code></pre>"},{"location":"040_simplevariabler.html#lidt-mere-avanceret","title":"Lidt mere avanceret","text":"<p>De fleste simple typer indeholder ogs\u00e5 en <code>[type].Parse</code>:</p> <pre><code>string a = \"434\";\nint b = int.Parse(a);\ndouble c = double.Parse(a);\n</code></pre> <p>Konvertering en af tekst som indeholder en dato kan v\u00e6re ret kompleks. Derfor indeholder DateTime-typen en statisk metode ParseExact, som kan v\u00e6re brugbar. Den konverterer en streng til en dato ved hj\u00e6lp af en skabelon og en evt kultur (typisk bruge CultureInfo.InvariantCulture (format er ikke er bundet til en kultur), men man kan benytte en specifik kultur).</p> <pre><code>using System.Globalization;\nstring tekst, format;\nDateTime res;\ntekst = \"2022|07\";\nformat = \"yyyy|MM\";\nres = DateTime.ParseExact(tekst, format, CultureInfo.InvariantCulture);\nConsole.WriteLine(res);\ntekst = \"10. juli 2022\";\nformat = \"D\";\nres = DateTime.ParseExact(tekst, format, new CultureInfo(\"da-DK\"));\nConsole.WriteLine(res);\n</code></pre> <p>Alternativt kan man i nogen sammenh\u00e6ng benytte <code>([type])</code> ved konvertering - men pas p\u00e5 ved tal. Benyttes mest ved referencebaserede variabler:</p> <pre><code>double a = 4030.75;\nint b = (int)a;  // 4.030 -- PAS P\u00c5\n</code></pre> <p>Info</p> <p>Vi ser n\u00e6rmere p\u00e5 de simple variabler i modul om hukommelsesteori senere</p>"},{"location":"040_simplevariabler.html#opgave-40-3","title":"Opgave 40-3","text":"<p>Brug af System.Convert samt ToString/Formatering (l\u00f8sning med video) (kode til s\u00f8gning: EAD)</p> <p>Se opgave</p>"},{"location":"045_tegnogtekster.html","title":"Tegn og tekster","text":""},{"location":"045_tegnogtekster.html#om-modulet","title":"Om modulet","text":"<p>I dette modul l\u00e6rer du om om tegn og tekster (strenge).</p> <p>Det er vigtigt at du f\u00e5r skrevet s\u00e5 meget kode som muligt - b\u00e5de ved at \u201clege\u201d med eksemplerne fra sektionerne (kopier, k\u00f8r og v\u00e6r nysgerrig) samt ved at l\u00f8se opgaverne.</p>"},{"location":"045_tegnogtekster.html#enkelt-tegn-char","title":"Enkelt tegn (char)","text":".NET C# Forklaring System.Char char UniCode tegn (16 bit) <p>Enkelt tegn</p> <ul> <li>System.Char</li> <li>char</li> <li>omkranset af \u2018 (ikke \u201c)</li> </ul> <p></p> <pre><code>char a;\na = 'a';\nConsole.WriteLine($\"a = {a}\");\n// a = 'ss';  = fejl\n// a = \"a\";   = fejl\n// ASCII v\u00e6rdi\nint nr = Convert.ToInt32(a);\nConsole.WriteLine(nr);\n// eller\nnr = (int)'A';\nConsole.WriteLine(nr);\n// den anden vej\nchar b = Convert.ToChar(65);\nConsole.WriteLine(b);\n/*\n ---------- Output: ----------\na = a\n97\n65\nA\n*/\n</code></pre>"},{"location":"045_tegnogtekster.html#tekster-string","title":"Tekster (string)","text":".NET C# Forklaring System.String string UniCode tekst <ul> <li>Tekst (2 gb)</li> <li>omkranset af \u201d (og ikke \u2018)</li> </ul> <pre><code>string a;\na = \"a\";\na = \"Kort s\u00e6tning\";\na = \"Noget l\u00e6ngere s\u00e6tning - i \u00f8vrigt med danske tegn\";\n// erkl\u00e6ring og initialisering\nstring b = \"test\";\n</code></pre>"},{"location":"045_tegnogtekster.html#operatorer-til-manipulering","title":"Operatorer til manipulering","text":"<p>Brug</p> <ul> <li>brug ligmed til tildeling</li> <li>brug ligmed ligmed (==) til sammenligning</li> <li>alternativt String.Compare() - der returerer -1, 0 eller 1</li> <li>brug plus til at sammenl\u00e6gge</li> <li>men pas p\u00e5 i l\u00f8kker!!</li> </ul> <pre><code>// Tildeling\nstring a;\na = \"a\";\nConsole.WriteLine($\"a = {a}\");\n// Sammenligning\nbool test;\ntest = a == \"a\";\nConsole.WriteLine($\"test {test}\");\nConsole.WriteLine($\"ny test {a == \"b\"}\");\nstring b = \"b\", c = \"c\";\nint res = string.Compare(b, c);\nConsole.WriteLine($\"Sammenlign b med c = {res}\");\nres = string.Compare(c, b);\nConsole.WriteLine($\"Sammenlign c med b = {res}\");\nres = string.Compare(c, c);\nConsole.WriteLine($\"Sammenlign c med c = {res}\");\n// Sammenl\u00e6gning\na = a + \" b\";\nConsole.WriteLine($\"a = {a}\");\na += \" c\";\nConsole.WriteLine($\"a = {a}\");\n</code></pre>"},{"location":"045_tegnogtekster.html#masse-metoder-til-streng-manipulering","title":"Masse metoder til streng manipulering","text":"<pre><code>string a;\na = \"  Dette er en l\u00e6ngere s\u00e6tning  \";\nConsole.WriteLine($\"Length = {a.Length}\");\nConsole.WriteLine($\"Contains = {a.Contains(\"s\u00e6tning\")}\");\nConsole.WriteLine($\"EndWith = {a.EndsWith(\"ning  \")}\");\nConsole.WriteLine($\"StartWith = {a.StartsWith(\"Test\")}\");\nConsole.WriteLine($\"ToUpper = {a.ToUpper()}\");\nConsole.WriteLine($\"ToLower = {a.ToLower()}\");\nConsole.WriteLine($\"Trim = {a.Trim()}\");\nConsole.WriteLine($\"SubString = {a.Substring(2, 2)}\");  // fra pos 2 og 2 frem\n/*\n ---------- Output: ----------\nLength = 31\nContains = True\nEndWith = True\nStartWith = False\nToUpper =   DETTE ER EN L\u00c6NGERE S\u00c6TNING  \nToLower =   dette er en l\u00e6ngere s\u00e6tning  \nTrim = Dette er en l\u00e6ngere s\u00e6tning\nSubString = De\n*/\n</code></pre> <p>Alle metoder returnerer en ny streng!!</p> <pre><code>string a = \"abc\";\na.ToUpper();            // resultat benytte ikke\nConsole.WriteLine(a);   // abc\na = a.ToUpper();\nConsole.WriteLine(a);   // ABC\n</code></pre>"},{"location":"045_tegnogtekster.html#specialtegn","title":"Specialtegn","text":"<p>foranstillet \\</p> Tegn Forklaring \\b Backspace \\f Formfeed \\n New line \\r Carriage return \\t Horizontal tab \\\u2018 Enkelt pling \\\u201c Dobbelt pling \\ Backslash \\x hhhh Unicode karakter <pre><code>string a;\n// Tab\na = \"\\t1\\t2\";\nConsole.WriteLine($\"a = {a}\");\n// Backslash\na = \"c:\\\\temp\\\\fil.txt\";\nConsole.WriteLine($\"a = {a}\");\n// Ny linje\na = \"\\r\\nLinje1\\r\\nLinje2\\r\\nLinje3\\r\\n\";\nConsole.WriteLine($\"a = {a}\");\n// Brug af @ for at f\u00e5 C# til at ignorere escape karaktere\na = @\"c:\\temp\\fil.txt\";\nConsole.WriteLine($\"a = {a}\");\n/*\n ---------- Output: ----------\na =     1   2\na = c:\\temp\\fil.txt\na = \nLinje1\nLinje2\nLinje3\na = c:\\temp\\fil.txt\n*/\n</code></pre>"},{"location":"045_tegnogtekster.html#interpolerede-strenge-template","title":"Interpolerede strenge (template)","text":"<p>Brug \\$ for at skabe en template:</p> <pre><code>string navn = \"Mathias\";\nstring res = $\"Hej - mit navn er {navn}\";\nConsole.WriteLine(res);\nint pris = 100;\nDateTime dato = new DateTime(2018, 1, 1);\nstring res2 = $\"Prisen er {pris} pr {dato}\";\nConsole.WriteLine(res2);\nstring res3 = $\"Prisen er {pris:n2} pr {dato:dd-MM-yyyy}\";\nConsole.WriteLine(res3);\nstring res4 = $\"Prisen er {pris.ToString(\"N2\"), 10} pr {dato.ToString(\"dd-mm\"),-10} og kan ikke forhandles.\";\nConsole.WriteLine(res4);\n/*\n ---------- Output: ----------\nHej - mit navn er Mathias\nPrisen er 100 pr 01-01-2018 00:00:00\nPrisen er 100,00 pr 01-01-2018\nPrisen er     100,00 pr 01-00      og kan ikke forhandles.\n*/\n</code></pre> <p>Info</p>"},{"location":"045_tegnogtekster.html#opgave-45-1","title":"Opgave 45-1","text":"<p>Simpel opgave i brug af strenge (kode til s\u00f8gning: EFB)</p> <p>Se opgave</p>"},{"location":"045_tegnogtekster.html#strenge-er-en-reference-type","title":"Strenge er en reference type","text":"<p>Strenge er egentlig en refencetype s\u00e5 null kan forekomme. Derfor b\u00f8r man checke om en streng er null inden brug:</p> <pre><code>string a = null;\nConsole.WriteLine(a.ToUpper());     // fejl\nif (a != null)\n{\nConsole.WriteLine(a.ToUpper()); // ok\n}\n</code></pre>"},{"location":"045_tegnogtekster.html#andre-operatorer","title":"Andre operatorer","text":"<p>Der findes et par andre operatorer man kan benytte for at forkorte koden:</p> Operator Beskrivelse ?. Tester om string er null ?? Tester om ref er null - ellers returneres v\u00e6rdi <pre><code>string a = null;\nConsole.WriteLine(a?.ToUpper());\n</code></pre> <pre><code>string a = null;\nstring b = a ?? \"\";\nConsole.WriteLine(b.ToUpper());\n</code></pre>"},{"location":"045_tegnogtekster.html#strenge-er-immutable","title":"Strenge er immutable","text":"<p>PAS P\u00c5 med manipulering af strenge i l\u00f8kker</p> <p>Strenge er immutable</p> <ul> <li>Immutabel (fast v\u00e6rdi / read only / kan ikke rettes)</li> <li>Alle operationer p\u00e5 strenge returnerer en kopi</li> <li>Performance kan v\u00e6re et problem</li> </ul> <p>F\u00f8lgende kode tager eksempelvis over 1 minut at afvikle p\u00e5 en standard PC:</p> <pre><code>// Stopur\nSystem.Diagnostics.Stopwatch s = new System.Diagnostics.Stopwatch();\ns.Start();\nstring a = \"\";\nfor (int i = 0; i &lt; 500_000; i++)\n{\na += \"*\";\n}\ns.Stop();\nConsole.WriteLine($\"ms = {s.ElapsedMilliseconds}\");\n</code></pre> <p>Brug System.Text.StringBuilder i stedet for (tager f\u00e5 millisekunder at afvikle):</p> <pre><code>// Stopur\nSystem.Diagnostics.Stopwatch s = new System.Diagnostics.Stopwatch();\nSystem.Text.StringBuilder sb = new System.Text.StringBuilder();\ns.Start();\nfor (int i = 0; i &lt; 500_000; i++)\n{\nsb.Append(\"*\");\n}\ns.Stop();\nConsole.WriteLine($\"ms = {s.ElapsedMilliseconds}\");\n</code></pre> <p>Se modul om hukommelsesteori for en visuel forklaring.</p>"},{"location":"045_tegnogtekster.html#systemtextstringbuilder","title":"System.Text.StringBuilder","text":"<p>Her er et par korte eksempler p\u00e5 brug af System.Text.StringBuilder:</p> <pre><code>System.Text.StringBuilder sb = new System.Text.StringBuilder();\nsb.AppendLine(\"Linje 1\");\nsb.AppendLine(\"Linje 2\");\nsb.Insert(3, \"**\");\nsb.Replace(\"**\", \"!!\");\nsb.Append(\"@@\");\nConsole.WriteLine($\"L\u00e6ngde: {sb.Length}\");\nConsole.WriteLine($\"Indhold:\\r\\n{sb.ToString()}\");\n/*\n ---------- Output: ----------\nL\u00e6ngde: 22\nIndhold:\nLin!!je 1\nLinje 2\n@@\n*/\n</code></pre>"},{"location":"045_tegnogtekster.html#nuget-pakker","title":"NuGet-pakker","text":"<p>Der findes en del forskellige pakker relateret til brug af strenge. Se eksempelvis Humanizr/Humanizer (pakken hedder Humanizer og den lokaliserede del hedder Humanizer.Core.Da) for yderligere streng funktionalitet, samt Handlebars-Net/Handlebars.Net (pakken hedder Handlebars.Net) for brug af skabeloner.</p> <p>Eksempler p\u00e5 brug af Humanizer (bem\u00e6rk - dansk er ikke fuldt oversat):</p> <pre><code>using System;\nusing System.Globalization;\nusing Humanizer;\nnamespace NuGetTest\n{\ninternal class Program\n{\nstatic void Main(string[] args)\n{\n// S\u00e6t kultur (ikke fuld oversat)\nSystem.Threading.Thread.\nCurrentThread.CurrentUICulture =\nnew CultureInfo(\"da-DK\");\nstring a = DateTime.Now.AddDays(-10).Humanize();\nConsole.WriteLine(a);\nstring c = \"Lang tekst som skal forkortes\".Truncate(15, \" ...\");\nConsole.WriteLine(c);\nTimeSpan d = TimeSpan.FromMinutes(60);\nConsole.WriteLine(d.Humanize());\nConsole.WriteLine((360.0).ToHeading(HeadingStyle.Full));\nConsole.WriteLine((130.0).ToHeading(HeadingStyle.Full));\n}\n}\n}\n</code></pre>"},{"location":"048_Konstanter.html","title":"Konstanter","text":""},{"location":"048_Konstanter.html#om-modulet","title":"Om modulet","text":"<p>I dette modul vil du l\u00e6re om de forskellige typer af konstaner i C#.</p>"},{"location":"048_Konstanter.html#almindelige-konstanter","title":"Almindelige konstanter","text":"<p>Faste v\u00e6rdier (kan ikke tilrettes efter tildeling)</p> <ul> <li>variabler tildeles en v\u00e6rdi ved oprettelse</li> <li>variabler kan ikke tildeles ny v\u00e6rdi</li> <li>brug af const</li> </ul> <pre><code>const int antalM\u00e5nederPr\u00c5r = 12;\nconst string applikationsNavn = \"Min applikation\";\nConsole.WriteLine($\"antalM\u00e5nederPr\u00c5r = {antalM\u00e5nederPr\u00c5r}\");\nConsole.WriteLine($\"applikationsNavn = {applikationsNavn}\");\n// brug af indbyggede konstanter\n// dette er nemmere (og mere sikkert)\ndouble omkreds1 = System.Math.PI * 25;\nConsole.WriteLine($\"omkreds1 = {omkreds1}\");\n// end dette\ndouble omkreds2 = 3.141592653589792 * 25;\nConsole.WriteLine($\"omkreds2 = {omkreds2}\");\n</code></pre>"},{"location":"048_Konstanter.html#relaterede-konstanter-enum","title":"Relaterede konstanter (enum)","text":"<p>enum kan bruges til at gruppere relaterede konstanter i en s\u00e5kaldt enumeration for at forbedre koden</p> <p>Vil gerne v\u00e6k fra dette:</p> <pre><code>string person1Navn = \"Mathias\";\nint person1Alder = 12;\nint person1K\u00f8n = 1; // antag 1 = mand\nstring person2Navn = \"Lene\";\nint person2Alder = 53;\nint person2K\u00f8n = 0; // antag 0 = kvinde\n</code></pre> <p>og i stedet benytte en enumeration (bem\u00e6rk - placeres typisk p\u00e5 namespace-niveau):</p> <pre><code>public enum K\u00f8n\n{\nKvinde, // = 0\nMand    // = 1\n}\n</code></pre> <p>kan bruges som</p> <pre><code>string person1Navn = \"Mathias\";\nint person1Alder = 12;\nMitNamespace.K\u00f8n person1K\u00f8n = K\u00f8n.Mand;\nstring person2Navn = \"Lene\";\nint person2Alder = 53;\nMitNamespace.K\u00f8n person2K\u00f8n = K\u00f8n.Kvinde;\n</code></pre>"},{"location":"048_Konstanter.html#typekonvertering","title":"Typekonvertering","text":"<pre><code>// Fra enum til nummer\nK\u00f8n k\u00f8n = K\u00f8n.Kvinde;\nint kode = Convert.ToInt32(k\u00f8n);\n// Fra nummer til enum\nkode = 1;\nK\u00f8n k\u00f8n2 = (K\u00f8n)kode;\n</code></pre>"},{"location":"048_Konstanter.html#andet-om-enums","title":"Andet om enums","text":"<p>V\u00e6rdier og type kan evt angives</p> <pre><code>namespace MitNamespace\n{\npublic enum KortFarve : byte\n{\nHjerter = 1,\nRuder = 2,\nSpar = 4,\nKl\u00f8r = 8\n}\n}\n</code></pre> <p>En del enums i frameworket</p> <pre><code>System.DayOfWeek dag = DayOfWeek.Saturday;                // ugedage\nSystem.ConsoleColor farve = ConsoleColor.Cyan;            // farve til konsol\nSystem.IO.DriveType t = System.IO.DriveType.Network;      // drev type\n</code></pre> <p>Info</p>"},{"location":"048_Konstanter.html#opgave-48-1","title":"Opgave 48-1","text":"<p>Brug en enum til at definere kul\u00f8r p\u00e5 et spillekort. (kode til s\u00f8gning: EIB)</p> <p>Se opgave</p>"},{"location":"048_Konstanter.html#enum-typen","title":"Enum-typen","text":"<p>Brug eventuelt Enum-typen til at genneml\u00f8be v\u00e6rdier eller navne</p> <pre><code>foreach (var item in Enum.GetNames(typeof(DayOfWeek)))\n{\n// string\nConsole.WriteLine(item);\n}\nforeach (var item in Enum.GetValues(typeof(DayOfWeek)))\n{\n// enum\nConsole.WriteLine((int)item);\n}\n</code></pre> <p>Enum-typen indeholder ogs\u00e5 en Parse til typekonvertering:</p> <pre><code>DayOfWeek d1 = (DayOfWeek)Enum.Parse(typeof(DayOfWeek), \"Monday\");\nDayOfWeek d2 = (DayOfWeek)Enum.Parse(typeof(DayOfWeek), \"monday\", true);\n</code></pre>"},{"location":"048_Konstanter.html#konstanter-fra-konfiguration","title":"Konstanter fra konfiguration","text":"<p>Der er mange m\u00e5der at arbejde med konfiguration p\u00e5 i .NET Core og en del NuGET-pakker der stiller funktionalitet til r\u00e5dighed - herunder <code>Microsoft.Extensions.Configuration</code>.</p> <p>Hvis man \u00f8nsker at arbejde med JSON konfigurationsfiler kan pakken <code>Microsoft.Extensions.Configuration.Json</code> benyttes.</p> <p>Se modul relateret til Konfiguration.</p>"},{"location":"050_flow.html","title":"Programflow","text":""},{"location":"050_flow.html#om-modulet","title":"Om modulet","text":"<p>I dette modul handler det om at styre programpointeren - flowkontrol - som er en del af alle programmeringsparadigmer, og alle h\u00f8jniveau programmeringssprog. Vi skal se p\u00e5 if, switch, for og do.</p> <p>Hvis du har erfaring fra andre sprog s\u00e5 kan du hurtigt komme igennem - kig p\u00e5 eksemplerne og pr\u00f8v dem evt selv.</p> <p>Hvis du er ny i programmering skal du bruge noget tid p\u00e5 at forst\u00e5 hvad det egentlig er du g\u00f8r - nemlig styrer hvilken instruktion der skal udf\u00f8res. Du g\u00f8r det nemmest ved at pr\u00f8ve s\u00e5 meget du kan og bruge debuggeren. S\u00e6t et breakpoint i starten af koden og step en instruktion af gangen. Se evt. tidligere modul. F\u00e5 ogs\u00e5 kigget p\u00e5 opgaverne s\u00e5 du selv koder de forskellige strukturer.</p>"},{"location":"050_flow.html#if","title":"If","text":"<p>If-strukturen er den simpleste og fuldst\u00e6ndig uundv\u00e6rlig</p> <ul> <li>if</li> <li>else<ul> <li>else if</li> </ul> </li> <li>Tuborgklammer er optional hvis der kun er en instruktion</li> <li>Brug snippet (if)</li> </ul> <pre><code>int i = 2;\nif (i == 2)\n{\n// kode\n}\n// eller\nif (i == 2)\n// kode\n// eller\nif (i == 2)\n{\n// kode\n}\nelse\n{\n// kode\n}\n// eller\nif (i == 2)\n{\n// kode\n}\nelse if (i == 3)\n{\n// kode\n}\nelse if (i == 4)\n{\n// kode\n}\nelse\n{\n// kode\n}\n</code></pre>"},{"location":"050_flow.html#mnstergenkendelse","title":"M\u00f8nstergenkendelse","text":"<p>I C# 9 er der nye former for m\u00f8nstergenkendelse relateret til udtryk. S\u00e5 istedet for at skrive</p> <pre><code>int x = 15;\nif(x &gt; 10 &amp;&amp; x &lt; 20)\n{ }\n</code></pre> <p>kan du benytte nye \u201cand\u201d og \u201cor\u201d kodeord og i stedet skrive</p> <pre><code>int x = 15;\nif(x is &gt; 10 and &lt; 20)\n{ }\n</code></pre> <p>Det kan v\u00e6re lidt nemmere.</p>"},{"location":"050_flow.html#switch","title":"Switch","text":""},{"location":"050_flow.html#alternatic-til-if","title":"Alternatic til if","text":"<ul> <li>Brug snippet (switch)</li> <li>break hopper ud</li> </ul> <pre><code>int i = 10;\nswitch (i)\n{\ncase 10:\nConsole.WriteLine(\"i er 10\");\nbreak;\ncase 20:\nConsole.WriteLine(\"i er 20\");\nbreak;\ndefault:\nConsole.WriteLine(\"i er ikke 10 eller 20\");\nbreak;\n}\n/*\n ---------- Output: ----------\ni er 10\n*/\n</code></pre>"},{"location":"050_flow.html#andet-eksempel","title":"Andet eksempel","text":"<pre><code>int i = 10;\nswitch (i)\n{\ncase 10:\ncase 20:\nConsole.WriteLine(\"i er 10 eller 20\");\nbreak;\ndefault:\nConsole.WriteLine(\"i er ikke 10 eller 20\");\nbreak;\n}\n/*\n ---------- Output: ----------\ni er 10 eller 20\n*/\n</code></pre>"},{"location":"050_flow.html#brug-ved-enums","title":"Brug ved enums","text":"<pre><code>switch (DateTime.Now.DayOfWeek)\n{\ncase DayOfWeek.Saturday:\ncase DayOfWeek.Sunday:\nConsole.WriteLine(\"Weekend\");\nbreak;\ncase DayOfWeek.Friday:\nConsole.WriteLine(\"N\u00e6sten weekend\");\nbreak;\ncase DayOfWeek.Monday:\ncase DayOfWeek.Thursday:\ncase DayOfWeek.Tuesday:\ncase DayOfWeek.Wednesday:\nConsole.WriteLine(\"Arbejde\");\nbreak;\n}\n/*\n ---------- Output: ----------\nArbejde\n*/\n</code></pre>"},{"location":"050_flow.html#mere-avanceret-brug-af-switch","title":"Mere avanceret brug af switch","text":"<p>Switch kan benytte pattern mathing (version 7, 8 og 9):</p> <p>F\u00f8lgende if-struktur</p> <pre><code>public static void Vis1(object o)\n{\nif (o is Person)\n{\nvar p = o as Person;\nConsole.WriteLine($\"Person hedder {p.Navn}\");\n}\nelse if (o is Bil)\n{\nvar b = o as Bil;\nConsole.WriteLine($\"Bil er en {b.M\u00e6rke}\");\n}\nelse\n{\nConsole.WriteLine($\"?\");\n}\n}\n</code></pre> <p>kan skrives anderledes</p> <pre><code>public static void Vis2(object o)\n{\nswitch (o)\n{\ncase Person p:\nConsole.WriteLine($\"Person hedder {p.Navn}\");\nbreak;\ncase Bil b:\nConsole.WriteLine($\"Bil er en {b.M\u00e6rke}\");\nbreak;\ndefault:\nConsole.WriteLine($\"?\");\nbreak;\n}\n}\n</code></pre> <p>eller mere avanceret ved brug af when:</p> <pre><code>public static void Vis3(object o)\n{\nswitch (o)\n{\ncase Person p when string.IsNullOrWhiteSpace(p.Navn):\nConsole.WriteLine($\"Person har ikke noget navn\");\nbreak;\ncase Person p:\nConsole.WriteLine($\"Person hedder {p.Navn}\");\nbreak;\ncase Bil b when b.M\u00e6rke != null &amp;&amp; b.M\u00e6rke.Length &lt;= 2:\nConsole.WriteLine($\"Bil har et m\u00e6rkeligt m\u00e6rke\");\nbreak;\ncase Bil b:\nConsole.WriteLine($\"Bil er en {b.M\u00e6rke}\");\nbreak;\ndefault:\nConsole.WriteLine($\"?\");\nbreak;\n}\n}\n</code></pre> <p>Her er et andet eksempel som kigger p\u00e5 en int:</p> <pre><code>int i = 10;\nswitch (i)\n{\ncase int n when (n &gt; 0 &amp;&amp; n &lt; 10):\nConsole.WriteLine($\"er n &gt; 0 &amp;&amp; n &lt; 10 : {n}\");\nbreak;\ncase int n when (n &gt;= 10 &amp;&amp; n &lt; 20):\nConsole.WriteLine($\"er n &gt;= 10 &amp;&amp; n &lt; 20 : {n}\");\nbreak;\ncase int n when (n &gt;= 20 &amp;&amp; n &lt; 30):\nConsole.WriteLine($\"er n &gt;= 20 &amp;&amp; n &lt; 30 :  {n}\");\nbreak;\ndefault:\nConsole.WriteLine(\"alt andet\");\nbreak;\n}\n</code></pre> <p>I C# 9 kan f\u00f8lgende ogs\u00e5 benyttes:</p> <pre><code>int x = 15;\nstring r = x switch\n{\n&lt; 10 =&gt; \"mindre end 10\",\n&gt; 10 and &lt; 20 =&gt; \"mellem 10 og 20\",\n_ =&gt; \"andet\"\n};\n</code></pre> <p>Her tildeles r en v\u00e6rdi gennem en lambda med de nye and/or kodeord.</p>"},{"location":"050_flow.html#for","title":"For","text":""},{"location":"050_flow.html#iteration","title":"Iteration","text":"<ul> <li>Brug snippet (for)</li> <li>T\u00e6llevariabel lever kun i l\u00f8kkens virkefelt</li> <li>Tuborgklammer er optional hvis der kun er en instruktion</li> </ul>"},{"location":"050_flow.html#normal-lkke","title":"normal l\u00f8kke","text":"<pre><code>for (int i = 0; i &lt; 10; i++)\n{\nConsole.WriteLine(i);\n}\nConsole.WriteLine();\nfor (int i = 0; i &lt; 3; i++)\nConsole.WriteLine(i);\n/*\n ---------- Output: ----------\n0\n1\n2\n3\n4\n5\n6\n7\n8\n9\n0\n1\n2\n*/\n</code></pre>"},{"location":"050_flow.html#hver-anden","title":"Hver anden","text":"<pre><code>for (int i = 0; i &lt; 10; i = i + 2)\n{\nConsole.WriteLine(i);\n}\n/*\n ---------- Output: ----------\n0\n2\n4\n6\n8\n*/\n</code></pre>"},{"location":"050_flow.html#bagfra","title":"Bagfra","text":"<pre><code>for (int i = 10; i &gt; 0; i--)\n{\nConsole.WriteLine(i);\n}\n/*\n ---------- Output: ----------\n10\n9\n8\n7\n6\n5\n4\n3\n2\n1\n*/\n</code></pre> <p>Info</p> <p>Info</p>"},{"location":"050_flow.html#opgave-50-1","title":"Opgave 50-1","text":"<p>Leg lidt med et par for-l\u00f8kker og en if-struktur (kode til s\u00f8gning: FAB)</p> <p>Se opgave</p>"},{"location":"050_flow.html#opgave-50-2","title":"Opgave 50-2","text":"<p>Brug et par for-l\u00f8kker og en if-struktur til at skabe en 10-tabel (kode til s\u00f8gning: FAC)</p> <p>Se opgave</p>"},{"location":"050_flow.html#do-while","title":"Do / While","text":"<p>L\u00f8ber indtil et udtryk er sand. Brug do eller while afh\u00e6ngig af om kode altid skal k\u00f8re en gang</p>"},{"location":"050_flow.html#while","title":"while","text":"<pre><code>DateTime tid = DateTime.Now.AddSeconds(1);\n// L\u00f8ber i 1 sekund\nwhile (DateTime.Now &lt; tid)\n{\n// kode\n}\n</code></pre>"},{"location":"050_flow.html#do","title":"do","text":"<pre><code>DateTime tid = DateTime.Now.AddSeconds(1);\n// L\u00f8ber i 1 sekund\ndo\n{\n// kode\n} while (DateTime.Now &lt; tid);\n</code></pre>"},{"location":"050_flow.html#continue-og-break","title":"Continue og Break","text":"<ul> <li>Styring af l\u00f8kker</li> </ul> <pre><code>for (int i = 0; i &lt;= 10; i++)\n{\n// hvis 2 og 6 - hop til n\u00e6ste iteration\nif (i == 2 || i == 6)\ncontinue;\n// hvis 8 - hop ud af l\u00f8kke\nif (i == 8)\nbreak;\nConsole.WriteLine(i);\n}\n/*\n ---------- Output: ----------\n0\n1\n3\n4\n5\n7\n*/\n</code></pre> <p>Info</p>"},{"location":"050_flow.html#opgave-50-3","title":"Opgave 50-3","text":"<p>En lille opgave s\u00e5 du kan lege lidt med break og continue. (kode til s\u00f8gning: FAD)</p> <p>Se opgave</p>"},{"location":"050_flow.html#goto","title":"Goto","text":"<p>Ind i mellem m\u00e5 man alts\u00e5 gerne bruge goto - men meget mere end et \u201cm\u00e6rke\u201d i koden g\u00f8r det uoverskueligt - s\u00e5 pas p\u00e5 med at bruge goto. Men nogen gange g\u00f8r det koden nemmere at forst\u00e5.</p> <pre><code>for (int y = 0; y &lt; 10; y++)\n{\nfor (int x = 0; x &lt; 10; x++)\n{\nif(x==5 &amp;&amp; y == 5) {\ngoto ud;\n}\n}\n}\nud:\nConsole.WriteLine(\"F\u00e6rdig\");\n</code></pre> <p>eller mere kompleks:</p> <pre><code>if (DateTime.Now.Millisecond % 2 == 0) {\nfor (int i = 0; i &lt; 10; i++)\n{\nif (DateTime.Now.Millisecond &gt; 500)\n{\ngoto ud;\n}\nConsole.WriteLine(i);\n}\n}\nelse {\nfor (int i = 0; i &lt; 5; i++)\n{\nConsole.WriteLine(i);\n}\n}\nud:\nConsole.WriteLine(\"F\u00e6rdig\");\n</code></pre>"},{"location":"060_metoder.html","title":"Metoder","text":""},{"location":"060_metoder.html#om-modulet","title":"Om modulet","text":"<p>I dette modul handler det (som forrige modul) ogs\u00e5 om at styre programpointeren - men nu ved hj\u00e6lp af metoder. Det g\u00f8r det nemt at udvikle, vedligeholde, genbruge og teste kode.</p> <p>Hvis du har erfaring fra andre sprog s\u00e5 kan du hurtigt komme igennem - kig p\u00e5 eksemplerne og pr\u00f8v dem evt selv.</p> <p>Hvis du er helt ny i programmering skal du bruge noget tid p\u00e5 de grundl\u00e6ggende eksempler. Det er vigtigt at forst\u00e5, at programpointeren automatisk kommer \u201cretur\u201d fra et metodekald. Brug debuggeren s\u00e5 meget som overhovedet muligt. Se evt. tidligere modul.</p>"},{"location":"060_metoder.html#grundlggende-om-metoder","title":"Grundl\u00e6ggende om metoder","text":"<ul> <li>Opdeling i mindre enheder</li> <li>Funktioner/rutiner/metoder<ul> <li>Alt i cs er objektorienteret = metoder</li> </ul> </li> </ul>"},{"location":"060_metoder.html#hvorfor-metoder","title":"Hvorfor metoder","text":"<pre><code>// Gentaget kode (ikke godt... - sv\u00e6rt at vedligeholde og overskue)\nfor (int i = 1; i &lt; 6; i++)\nConsole.WriteLine(i);\nfor (int i = 1; i &lt; 6; i++)\nConsole.WriteLine(i);\nfor (int i = 1; i &lt; 6; i++)\nConsole.WriteLine(i);\n// L\u00f8kker i l\u00f8kker (bedre ud - men kan ikke genbruges)\nConsole.WriteLine();\nfor (int x = 0; x &lt; 3; x++)\nfor (int i = 1; i &lt; 6; i++)\nConsole.WriteLine(i);\n// Goto (bedre, nu kan det genbruges - men igen - sv\u00e6rt at overskue)\nConsole.WriteLine();\nint programLinjeT\u00e6ller = 0;\nstart:\nif (programLinjeT\u00e6ller &lt; 3)\ngoto t\u00e6l;\nelse\ngoto slut;\nt\u00e6l:\nfor (int i = 1; i &lt; 6; i++)\nConsole.WriteLine(i);\nprogramLinjeT\u00e6ller++;\ngoto start;\nslut:\n// metoder (meget bedre - nemt at genbruge og kode lever i eget virkefelt)\nConsole.WriteLine();\nfor (int x = 0; x &lt; 3; x++)\n{\nT\u00e6l();\n}\nvoid T\u00e6l()  // kan nemt udvides til at t\u00e6lle til et vilk\u00e5rligt antal\n{\nfor (int i = 1; i &lt; 6; i++)\nConsole.WriteLine(i);\n}\n</code></pre>"},{"location":"060_metoder.html#den-traditionelle-visuelle-forklaring","title":"Den traditionelle visuelle forklaring","text":"<p>En metode kan ses som en boks med instuktioner. P\u00e5 venstre sider findes eventuelle v\u00e6rdier (argumenter) som sendes ind i boksen, og p\u00e5 h\u00f8jre side en eventuel v\u00e6rdi som kan hentes ud af boksen. Boksen med instruktioner er typisk gr\u00e5 eller sort for at indikere, at indholdet (instruktionerne) ikke er vigtige. Det er argumenter og returv\u00e6rdi der skal v\u00e6re fokus p\u00e5 n\u00e5r en metode kaldes.</p> <p></p> <p>Metoder uden returv\u00e6rdi hedder i C# en void-metode (void kan overs\u00e6ttes til tom).</p>"},{"location":"060_metoder.html#programpointeren","title":"Programpointeren","text":"<pre><code>F1();\nvoid F1() {\nConsole.WriteLine(\"I F1()\");\nF2();\n}\nvoid F2() {\nConsole.WriteLine(\"I F2()\");\nF3();\n}\nvoid F3() {\nConsole.WriteLine(\"I F3()\");\nF4();\n}\nvoid F4() {\nConsole.WriteLine(\"I F4()\");\nF5();\n}\nvoid F5() {\nConsole.WriteLine(\"I F5()\");\n// F1(); (puha - skaber rekursivt kald)\n}\n</code></pre>"},{"location":"060_metoder.html#definition-af-metoder","title":"Definition af metoder","text":"<pre><code>[synlighed] [[statisk]] [returtype] Navn ([argumenter - type navn])\n{\n    // kode\n    // return ...\n}\n</code></pre>"},{"location":"060_metoder.html#hvor-skal-metoder-placeres","title":"Hvor skal metoder placeres","text":"<ul> <li>Alt i C# er placeret i enten klasser (class) eller strukturer (struct)</li> <li>Metoder kan enten v\u00e6re instans- eller statiske metoder<ul> <li>Se senere</li> </ul> </li> </ul> <pre><code>class TestKlasse\n{\npublic void TestMetode1() { }\npublic static void TestMetode2() { }\n}\nstruct TestStruktur\n{\npublic void TestMetode1() { }\npublic static void TestMetode2() { }\n}\n</code></pre> <p>Metoderne kan nu kaldes som</p> <pre><code>// brug af instans metoder\nTestKlasse t1 = new TestKlasse();\nt1.TestMetode1();\nTestStruktur t2 = new TestStruktur();\nt2.TestMetode1();\n// brug af statiske metoder\nTestKlasse.TestMetode2();\nTestStruktur.TestMetode2();\n</code></pre> <p>Hvis man arbejder med konsol-applikationer arbejder man jo allerede i en klasse (Program), og Main-metoden er i sig selv statisk. Derfor er den nemmeste m\u00e5de at teste metoder p\u00e5, at skabe statiske metoder i Program-klassen.</p> <pre><code>namespace MinKonsolApp\n{\nclass Program\n{\nstatic void Main(string[] args)\n{\n// kald af metode\nTestMetode();\n}\nstatic void TestMetode() { }\n}\n}\n</code></pre>"},{"location":"060_metoder.html#synlighed","title":"Synlighed","text":"<ul> <li>public<ul> <li>Kan tilg\u00e5s b\u00e5de internt og eksternt</li> </ul> </li> <li>private<ul> <li>Kan kun tilg\u00e5s internt</li> </ul> </li> <li>(protected mv)</li> </ul> <p>Denne klasse viser b\u00e5de offentlige og private metoder:</p> <pre><code>public class Person\n{\npublic string Navn;\npublic int Alder;\n// offentlige metoder\npublic string NavnMedStort()\n{\nreturn this.Navn.ToUpper();\n}\npublic void GemPerson()\n{\n// Offentlige metoder kan godt kalde\n// private metoder\nCheckPerson();\n// kode til at gemme person\n}\n// private metoder\nprivate void CheckPerson()\n{\nif (Alder &lt; 0 || Alder &gt; 100 || Navn == null || Navn == \"\")\nthrow new ApplicationException(\"Forkerte data\");\n}\n}\n</code></pre>"},{"location":"060_metoder.html#definition-og-kald-af-metoder","title":"Definition og kald af metoder","text":"<ul> <li>Eksempler p\u00e5 funktioner i sin mest simple form<ul> <li>Her i Program-klassen (derfor static)</li> </ul> </li> </ul> <pre><code>class Program\n{\npublic static void Metode1()\n{\n}\n// Brug af return\npublic static void Metode2()\n{\n// kode\nif (true)\nreturn;\n// kode\n}\n// Argumenter\npublic static void Metode3(int a, int b, bool c)\n{\n// a, b og c lever udelukkende i metoden\n// Se dog senere omkring v\u00e6rdi- og reference\n// baserede variabler\n}\n// Returtype\npublic static int Metode4()\n{\n// Skal indeholde en return\nreturn 1;\n}\n// Returtype med argumenter\npublic static int Metode5(int a, int b)\n{\nreturn a + b;\n}\n// Returtype med argumenter (brug af return)\npublic static int Metode6(int a, int b)\n{\nif (a &lt; 10)\nreturn a + b;\nelse\nreturn a * b;\n}\nstatic void Main(string[] args)\n{\nMetode1();\nMetode2();\nMetode3(1, 1, true);\nint a = 1, b = 2;\nbool c = true;\nMetode3(a, b, c);\nint res1 = Metode4();\nMetode4();              // returv\u00e6rdi ignoreres\nint res2 = Metode5(2, 5);\nint res3 = Metode6(6, 7);\n}\n}\n</code></pre> <p>Info</p> <p>Info</p>"},{"location":"060_metoder.html#opgave-60-1","title":"Opgave 60-1","text":"<p>Brug af simple metoder (kode til s\u00f8gning: GAB)</p> <p>Se opgave</p>"},{"location":"060_metoder.html#opgave-60-2","title":"Opgave 60-2","text":"<p>Skab en metode der returnerer en nullable v\u00e6rdi (kode til s\u00f8gning: GAC)</p> <p>Se opgave</p>"},{"location":"060_metoder.html#stack-frames","title":"Stack frames","text":"<p>Her er en kort video omkring hvordan argumenter til metoder kan forst\u00e5s.</p> <p>Find eventuelt den Powerpoint-pr\u00e6sentation der ligger til grund for videoen her.</p>"},{"location":"060_metoder.html#statiskinstans-metode","title":"Statisk/instans metode","text":"<p>Ved brug af statiske metoder beh\u00f8ver man ikke skabe en instans!!</p> <pre><code>Console.WriteLine(\"Test\");\nSystem.IO.File.Delete(@\"c:\\temp\\test.txt\");\ndouble res = System.Math.Pow(10, 2);\n</code></pre> <p>Og man kan ogs\u00e5 skabe sine egne:</p> <pre><code>public class MetodeEksempelKlasse\n{\npublic void Metode1() { }\npublic static void Metode2() { }\n}\n</code></pre> <pre><code>// Brug af en instans metode\n// Kr\u00e6ver oprettelse af objekt\nMetodeEksempelKlasse o = new MetodeEksempelKlasse();\no.Metode1();\n// Brug af en statisk metode\n// Ingen er oprettelse af objekt\nMetodeEksempelKlasse.Metode2();\n</code></pre> <p>Info</p>"},{"location":"060_metoder.html#opgave-60-3","title":"Opgave 60-3","text":"<p>Brug af statiske metoder (kode til s\u00f8gning: GAD)</p> <p>Se opgave</p>"},{"location":"060_metoder.html#argumenter-som-ikke-behver-angives","title":"Argumenter som ikke beh\u00f8ver angives","text":"<ul> <li>Optional arguments</li> </ul> <pre><code>int res1 = Metode1(1, 1, 2, false);\nint res2 = Metode1(1, 1, 2);\nint res3 = Metode1(1, 1);\n// optional argumenter\nint Metode1(int a, int b, int c = 1, bool d = true)\n{\nif (d)\nreturn a + b + c;\nelse\nreturn a * b;\n}\n</code></pre>"},{"location":"060_metoder.html#navngivne-argumenter","title":"Navngivne argumenter","text":"<pre><code>Metode1(\"a\", 10, true, \"DK\");\nMetode1(alder: 10, erSmart: true, land: \"DK\", navn: \"a\");\nvoid Metode1(string navn, int alder, bool erSmart, string land)\n{\n}\n</code></pre>"},{"location":"060_metoder.html#metoder-med-samme-navn","title":"Metoder med samme navn","text":"<ul> <li>Overload</li> </ul> <pre><code>public class OverLoadEksempler\n{\npublic void Metode1() { }\npublic void Metode1(int a) { }\npublic void Metode1(int a, int b) { }\npublic int Metode1(int a, int b, int c) { return a + b + c; }\npublic void Metode1(int a, int b, bool c) { }\npublic static void Metode2() { }\npublic static void Metode2(int a) { }\npublic static void Metode2(int a, int b) { }\n}\n</code></pre> <pre><code>OverLoadEksempler o = new OverLoadEksempler();\no.Metode1();\no.Metode1(1);\no.Metode1(1, 1);\no.Metode1(1, 1, true);\nint res = o.Metode1(1, 1, 1);\nOverLoadEksempler.Metode2();\nOverLoadEksempler.Metode2(1);\nOverLoadEksempler.Metode2(1, 1);\n</code></pre> <p>Info</p>"},{"location":"060_metoder.html#opgave-60-4","title":"Opgave 60-4","text":"<p>Brug af overloaede metoder (kode til s\u00f8gning: GAE)</p> <p>Se opgave</p>"},{"location":"060_metoder.html#metoder-i-metoder","title":"Metoder i metoder","text":"<p>I nyere version af C# er det muligt at placere metoder i metoder.</p> <pre><code>void Main(string[] args)\n{\nint res = L\u00e6gSammen(1, 1);\nint L\u00e6gSammen(int a, int b)\n{\nreturn a + b;\n}\n}\n</code></pre> <p>Lidt mere avanceret (foruds\u00e6tter viden om delegates og lambda)</p> <pre><code>// brug af anonyme metoder\n// Lambda - se senere\nFunc&lt;int, int, int&gt; L\u00e6gSammen = (a, b) =&gt; a + b;\nint res = L\u00e6gSammen(1, 1);\nConsole.WriteLine($\"Resultat: {res}\");\n/*\n ---------- Output: ----------\nResultat: 2\n*/\n</code></pre>"},{"location":"060_metoder.html#introduktion-til-expression-body-methods","title":"Introduktion til Expression Body methods","text":"<p>Fra og med C# 6 har det v\u00e6ret muligt at benytte s\u00e5kaldte expression body members - herunder til definering af metoder der kun har en instruktion (med en implicit return). Den benytter lambda syntaksen (som gennemg\u00e5s senere), men giver mulighed for at skrive metoder meget hurtigt. Her er et par eksempler p\u00e5 brug af syntaksen:</p> <pre><code>private static double Gange(double a, double b) =&gt; a * b;\n</code></pre> <p>er det samme som</p> <pre><code>private static double Gange(double a, double b)\n{\nreturn  a * b;\n}\n</code></pre> <p>og</p> <pre><code>private static void Skriv(string t) =&gt; Console.WriteLine(t);\n</code></pre> <p>er det samme som</p> <pre><code>private static void Skriv(string t)\n{\nConsole.WriteLine(t);\n}\n</code></pre> <p>Som sagt - mere om Lambda i et senere modul.</p>"},{"location":"060_metoder.html#rekursive-metoder","title":"Rekursive metoder","text":"<ul> <li> <p>Metode der kalder sig selv</p> </li> <li> <p>Benyttes meget ved sortering og traversering</p> </li> </ul> <pre><code>RekusivMetode(1, 5);\nvoid RekusivMetode(int start, int stop) {\nConsole.WriteLine(start);\nif (start == stop)\nreturn;\nstart++;\nRekusivMetode(start, stop);\n}\n/*\n ---------- Output: ----------\n1\n2\n3\n4\n5\n*/\n</code></pre> <p>Info</p> <p>Info</p>"},{"location":"060_metoder.html#opgave-60-5","title":"Opgave 60-5","text":"<p>Udvikling af en simpel rekursiv metode. (kode til s\u00f8gning: GAF)</p> <p>Se opgave</p>"},{"location":"060_metoder.html#opgave-60-6","title":"Opgave 60-6","text":"<p>Udvikling af en rekursiv metode til at finde undermapper og filer. (kode til s\u00f8gning: GAG)</p> <p>Se opgave</p>"},{"location":"060_metoder.html#brug-af-in-ref-og-out-ved-metoder","title":"Brug af in, ref og out ved metoder","text":"<ul> <li>ref sender reference med til v\u00e6rdibaserede variabler<ul> <li>de skal v\u00e6re initialiserede</li> </ul> </li> </ul> <pre><code>int i = 10;\nConsole.WriteLine(i);\nMetode(ref i);\nConsole.WriteLine(i);\nvoid Metode(ref int a) {\na++;\n}\n/*\n ---------- Output: ----------\n10\n11\n*/\n</code></pre> <ul> <li>out sender reference med til v\u00e6rdibaserede variabler<ul> <li>de beh\u00f8ver ikke v\u00e6re initialiserede</li> </ul> </li> </ul> <pre><code>int i;\nMetode(out i);\nConsole.WriteLine(i);\nvoid Metode(out int a)\n{\na=10;\n}\n/*\n ---------- Output: ----------\n10\n*/\n</code></pre>"},{"location":"060_metoder.html#ref-ved-reference-variabler","title":"Ref ved reference variabler","text":"<ul> <li>Ved reference baserede argumenter kan man ikke ikke rette referencen (eksempelvis pege p\u00e5 et nyt objekt)</li> <li>Men ref give mulighed for helt at \u00e6ndre referencen</li> </ul> <pre><code>void Test1(Person p)\n{\n// der er overf\u00f8rt en kopi af p\n// s\u00e5 hvis man tildeler p en ny\n// reference har det ikke nogen\n// effekt i den kaldende metode\np = new Person();   // ingen betydning\n}\nvoid Test2(ref Person p)\n{\n// der er overf\u00f8rt den originale reference\n// s\u00e5 hvis man tildeler p en ny reference har\n// det betydning i den kaldende metode\np = new Person();   // betydning\n}\n</code></pre>"},{"location":"060_metoder.html#in","title":"in","text":"<p>in kan bruges ved structs til at sikre, at v\u00e6rdien ikke \u00e6ndres:</p> <pre><code>class TestKlasse\n{\npublic void Test(in Person a) {\na.Navn = \"\";    // fejl\n}\n}\nstruct Person {\npublic string Navn;\n}\n</code></pre> <p>Hvis in benyttes ved referencebaserede variabler betyder det blot, at referencen ikke kan \u00e6ndres.</p>"},{"location":"060_metoder.html#expression-bodied-members","title":"Expression-bodied members","text":"<p>Lambda syntaks til:</p> <ul> <li>methods</li> <li>read only property</li> <li>property</li> <li>constructor</li> <li>finalizer</li> <li>indexer</li> </ul> <pre><code>class Person\n{\n// Egenskab\nprivate string _navn;\npublic string Navn\n{\nget =&gt; _navn;\nset =&gt; _navn = value;\n}\n// Read only egenskab\nprivate int _alder;\npublic int Alder =&gt; _alder;\n// Metoder\npublic string NavnMedStort() =&gt; _navn?.ToUpper();\npublic string ForBogstav(bool medStort) =&gt; medStort?_navn?.Substring(0,1).ToUpper(): _navn?.Substring(0, 1).ToLower();\n// Constructor\npublic Person(string navn) =&gt; _navn = navn;\n// Finalizer\n~Person() =&gt; Console.WriteLine(\"Oprydning\");\n}\npublic class SportsGrene\n{\nprivate string[] typer = { \"H\u00e5ndbold\", \"Basketball\", \"Fodbold\", \"Tennis\",\"Volleyball\" };\n// Indexer\npublic string this[int i]\n{\nget =&gt; typer[i];\nset =&gt; typer[i] = value;\n}\n}\n</code></pre>"},{"location":"060_metoder.html#attributter","title":"Attributter","text":"<p>For at give yderligere information til eksempelvis kompiler eller frameworks som benytter en metode kan den beriges med [attributter]. Det vil tilf\u00f8jes ekstra metadata som kan afl\u00e6ses hvis det \u00f8nskes. Eksempelvis kan en metode markeres med en ObsolteAttribute for at indikere, at metoden ikke b\u00f8r benyttes:</p> <pre><code>[Obsolete()]\npublic void Test(){}\n// Pr\u00f8v evt [Obsolete(true)]\n</code></pre> <p>Nu vil eksempelvis Visual Studio markere metoden som obsolete (evt som fejl).</p> <p>Der m\u00e5 gerne tilf\u00f8jes mange attributter og man kan skabe dem selv, men lige nu skal du bare vide at det er en m\u00e5de at tilf\u00f8je ekstra information til metoder.</p>"},{"location":"060_metoder.html#introduktion-til-extension-methods","title":"Introduktion til Extension methods","text":"<p>Extension methods giver mulighed for at udvide eksisterende klasser med egne statiske metoder. Pr\u00f8v eksempelvis</p> <pre><code>using System;\nnamespace RetryPattern\n{\nclass Program\n{\nstatic void Main(string[] args)\n{\n// Array af tal\nint[] tal = { 5, 1, 5, 1, 6 };\n// tal.\n}\n}\n}\n</code></pre> <p>Pr\u00f8v i VS eller VSC at skrive tal. og se listen af mulige metoder. Pr\u00f8v herefter at tilf\u00f8je LINQ</p> <pre><code>using System;\nusing System.Linq;\nnamespace RetryPattern\n{\nclass Program\n{\nstatic void Main(string[] args)\n{\n// Array af tal\nint[] tal = { 5, 1, 5, 1, 6 };\n// tal.\n}\n}\n}\n</code></pre> <p>Pr\u00f8v at skrive tal. igen og bem\u00e6rk, at listen af muligheder er langt st\u00f8rre. Array-klassen er udvidet med extension methods fra System.Linq.</p> <p>I mere avanceret C# kan du selv udvikle egne extension methods.</p>"},{"location":"060_metoder.html#extension-methods","title":"Extension methods","text":"<ul> <li>Mulighed for at udvide eksisterende klasser med egne statiske metoder<ul> <li>Ogs\u00e5 selv det ikke er egne typer</li> </ul> </li> </ul> <p>Hj\u00e6lpebiblioteker</p> <ul> <li>Skal v\u00e6re offentlige statiske metoder i en statisk klasse</li> <li>Kan opfattes (og bruges) som et hj\u00e6lpebibliotek</li> <li>F\u00f8rste parameter skal v\u00e6re this</li> <li>M\u00e5 have s\u00e5 mange parametre man vil</li> <li>For at extension metoder skal v\u00e6re tilg\u00e6ngelige skal der importeres det korrekte namespace</li> </ul> <pre><code>using System;\nnamespace Extension\n{\npublic static class MineMetoder\n{\n// Udvider DateTime\npublic static bool IsWeekend(this DateTime d) {\nif (d.DayOfWeek == DayOfWeek.Sunday || d.DayOfWeek == DayOfWeek.Saturday)\nreturn true;\nreturn false;\n}\n// Udvider string\npublic static string LeftPartOfString(this string text, int number)\n{\ntext += new string(' ', number);\nreturn text.Substring(0, number);\n}\n}\n}\n</code></pre> <pre><code>var d1 = new DateTime(2018, 9, 1);\nvar d2 = new DateTime(2018, 9, 5);\nConsole.WriteLine($\"d1.IsWeekend = {d1.IsWeekend()}\");\nConsole.WriteLine($\"d2.IsWeekend = {d2.IsWeekend()}\");\nstring a = \"123\";\nConsole.WriteLine(a.Substring(0, 3));\n// Console.WriteLine(a.Substring(0, 4));   // Fejl - streng ikke lang nok\n// Denne virker\nConsole.WriteLine(a.LeftPartOfString(4));\n// Kan jo ogs\u00e5 kaldes direkte - som et hj\u00e6lpebibliotek\nConsole.WriteLine(Extension.MineMetoder.LeftPartOfString(\"123\", 4));\n/*\n ---------- Output: ----------\nd1.IsWeekend = True\nd2.IsWeekend = False\n123\n123\n123\n*/\n</code></pre> <p>Info</p>"},{"location":"060_metoder.html#opgave-60-7","title":"Opgave 60-7","text":"<p>Skab en extension-metode til System.String (kode til s\u00f8gning: GAH)</p> <p>Se opgave</p>"},{"location":"065_Fejlh%C3%A5ndtering.html","title":"Fejlh\u00e5ndtering","text":""},{"location":"065_Fejlh%C3%A5ndtering.html#om-modulet","title":"Om modulet","text":"<p>Dette modul vil introducere dig til fejlh\u00e5ndtering, og helt grundl\u00e6ggende skal du bare forst\u00e5 (og fors\u00f8ge selv) at omkranse kode med try/catch for at fange fejl. Der er et par opgaver du kan kaste dig over.</p>"},{"location":"065_Fejlh%C3%A5ndtering.html#mulige-fejl","title":"Mulige fejl","text":"<p>Til form\u00e5l at \u201cpr\u00f8ve kode af\u201d samt fange og h\u00e5ndtere eventuelle fejl. Her er eksempler p\u00e5 b\u00e5de kode- og runtime fejl:</p> <pre><code>using System;\nnamespace Eksempler.Fejl\n{\npublic class Fejl\n{\npublic void Fejl1()\n{\nstring tekst = null;\n// Vil generere en NullReferenceException\n// fordi tekst variablen ikke har en reference\n// til noget\nConsole.WriteLine(tekst.ToUpper());\n}\npublic void Fejl2()\n{\nstring indhold = System.IO.File.ReadAllText(@\"c:\\temp\\xyz.txt\");\n// Vil generere en FileNotFoundException\n// hvis filen ikke eksisterer\n}\npublic void Fejl3()\n{\nchecked\n{\nbyte b = byte.MaxValue;\nb++;\n}\n// Vil generere en OverflowException\n// fordi 255 + 1 ikke \"kan v\u00e6re\" i en\n// byte (og checked s\u00f8rger for at smide\n// en fejl i s\u00e5 fald)\n}\npublic void Fejl4()\n{\nint a = 10;\nint b = 0;\nint res = a / b;\n// DivideByZeroException\n}\n}\n}\n</code></pre>"},{"location":"065_Fejlh%C3%A5ndtering.html#hvorfor-hedder-en-fejl-en-bug","title":"Hvorfor hedder en fejl en bug?","text":"<p>L\u00e6s om Grace Hopper\u2019s kamp med et insekt i 1946 da hun arbejdede p\u00e5 rel\u00e6computeren Mark II.</p>"},{"location":"065_Fejlh%C3%A5ndtering.html#simpel-log","title":"Simpel log","text":"<p>Fejlh\u00e5ndtering b\u00f8r kombineres med log af en eller anden art, men det ligger uden for rammerne af dette modul at komme n\u00e6rmere ind p\u00e5 det. Du kan eventuelt benytte denne metode til test af log (IKKE produktion):</p> <pre><code>static void Log(string tekst, string fil = @\"c:\\temp\\log.txt\", bool skrivConsole = true)\n{\nstring txt = $\"{DateTime.Now:dd-MM-yy HH:mm:ss:ffff} {tekst.Replace(\"\\r\\n\", \"\")}\";\nSystem.IO.File.AppendAllText(fil, txt + \"\\r\\n\");\nif(skrivConsole)\nConsole.WriteLine(txt);\n}\nstatic void Log(Exception ex, string fil = @\"c:\\temp\\log.txt\", bool skrivConsole = true)\n{\nstring txt = $\"{DateTime.Now:dd-MM-yy HH:mm:ss:ffff} {ex.ToString()}\";\nSystem.IO.File.AppendAllText(fil, txt + \"\\r\\n\");\nif(skrivConsole)\nConsole.WriteLine(txt);\n}\n</code></pre>"},{"location":"065_Fejlh%C3%A5ndtering.html#brug-af-trycatch","title":"Brug af try/catch","text":"<ul> <li>Traditionel try/catch som det kendes fra andre sprog<ul> <li>snippet: try + 2 x tab<ul> <li>eller: ctrl K+S + try</li> </ul> </li> </ul> </li> </ul> <p>Simpel udgave af try/catch:</p> <pre><code>try\n{\nstring tekst = null;\n// NullReferenceException\nConsole.WriteLine(tekst.ToUpper());\n}\ncatch (Exception ex)\n{\nConsole.WriteLine(\"Der er sket en fejl\");\nConsole.WriteLine($\"Fejlen er {ex.Message}\");\n}\n/*\n ---------- Output: ----------\nDer er sket en fejl\nFejlen er Object reference not set to an instance of an object.\n*/\n</code></pre>"},{"location":"065_Fejlh%C3%A5ndtering.html#brug-af-finally","title":"Brug af finally","text":"<p>Afvikles altid - b\u00e5de ved fejl</p> <pre><code>try\n{\nstring tekst = null;\n// NullReferenceException\nConsole.WriteLine(tekst.ToUpper());\n}\ncatch (Exception ex)\n{\nConsole.WriteLine(\"Der er sket en fejl\");\nConsole.WriteLine($\"Fejlen er {ex.Message}\");\n}\nfinally\n{\nConsole.WriteLine(\"Dette kode afvikles altid\");\n}\n/*\n ---------- Output: ----------\nDer er sket en fejl\nFejlen er Object reference not set to an instance of an object.\nDette kode afvikles altid\n*/\n</code></pre> <p>og n\u00e5r der ikke sker fejl</p> <pre><code>try\n{\nstring tekst = \"mathias\";\nConsole.WriteLine(tekst.ToUpper());\n}\ncatch (Exception ex)\n{\nConsole.WriteLine(\"Der er sket en fejl\");\nConsole.WriteLine($\"Fejlen er {ex.Message}\");\n}\nfinally\n{\nConsole.WriteLine(\"Dette kode afvikles altid\");\n}\n/*\n ---------- Output: ----------\nMATHIAS\nDette kode afvikles altid\n*/\n</code></pre>"},{"location":"065_Fejlh%C3%A5ndtering.html#hvorfor-finally","title":"Hvorfor finally","text":"<p>Hvorfor dette:</p> <pre><code>try\n{\n// ..\n}\ncatch\n{\n// ..\n}\nfinally\n{\n// kode\n}\n</code></pre> <p>i stedet for:</p> <pre><code>try\n{\n// ..\n}\ncatch\n{\n// ..\n}\n// kode\n</code></pre> <p>Man bruger finally fordi kode i catch blokken kan risikere at smide en anden fejl eller m\u00e5ske returnerer ud af metoden. Ved brug af finally bliver koden i finally altid afviklet.</p>"},{"location":"065_Fejlh%C3%A5ndtering.html#fejl-og-call-stack","title":"Fejl og call stack","text":"<p>Fejl bobler op af call stack\u2019en s\u00e5 try/catch kan placeres i samtlige metoder</p> <ul> <li>I Metode4 hvis man \u00f8nsker at behandle fejlen lokalt</li> <li>I Metode1 hvis man \u00f8nsker en global lignende fejlh\u00e5ndtering</li> </ul> <pre><code>using System;\nnamespace Eksempler\n{\nclass FejlCallStack\n{\npublic void Metode1() {\nMetode2();\n}\npublic void Metode2() {\nMetode3();\n}\npublic void Metode3() {\nMetode4();\n}\npublic void Metode4() {\nstring tekst = null;\nConsole.WriteLine(tekst.ToUpper());\n}\n}\n}\n</code></pre> <p>Info</p>"},{"location":"065_Fejlh%C3%A5ndtering.html#opgave-65-1","title":"Opgave 65-1","text":"<p>Brug af try/catch (med video af l\u00f8sning) (kode til s\u00f8gning: GFB)</p> <p>Se opgave</p>"},{"location":"065_Fejlh%C3%A5ndtering.html#exception-klassen","title":"Exception-klassen","text":"<ul> <li>Venstre side af tr\u00e6et er fejl (exceptions) der smides af frameworket</li> <li>H\u00f8jre side er typisk reserveret til udviklere</li> </ul>"},{"location":"065_Fejlh%C3%A5ndtering.html#medlemmer-pa-en-exception","title":"Medlemmer p\u00e5 en Exception","text":"Medlem Beskrivelse Message Beskrivelse af fejl Source Assembly StackTrace Call stack TargetSite I hvilken metode skete fejlen InnerException Eventuel tidligere fejl (serie af fejl) Data Eventuelle yderligere data"},{"location":"065_Fejlh%C3%A5ndtering.html#flere-catch-blokke","title":"Flere catch-blokke","text":"<ul> <li>Nogen gange giver det mening af fange og behandle forskellige fejl</li> <li>Exception b\u00f8r v\u00e6re i bunden</li> </ul> <pre><code>try\n{\n// kald en metode hvor flere fejl kan ske\nMuligFejl();\n}\ncatch (System.IO.IOException ex)\n{\n// G\u00f8r noget\n}\ncatch (NullReferenceException ex)\n{\n// G\u00f8r noget\n}\ncatch (ArithmeticException ex)\n{\n// G\u00f8r noget\n}\ncatch (Exception ex)\n{\n// G\u00f8r noget\n}\n</code></pre>"},{"location":"065_Fejlh%C3%A5ndtering.html#innerexception","title":"InnerException","text":"<p>En Exception best\u00e5r ogs\u00e5 af en InnerException som kan indeholde yderligere informationer om en evt. anden exception. Denne kan m\u00e5ske v\u00e6re den rigtige synder:</p> <p>Pr\u00f8v evt selv med f\u00f8lgende metode, som pr\u00f8ver at konvertere en tekst fra en fil til et tal. Som udgangspunkt er en eventuel fejl, at den ikke kan konvertere til et tal, men det kan jo blandt andet skyldes, at filen ikke kan findes eller at der st\u00e5r n\u00e5r vr\u00f8vl i filen. Og denne information kan findes som en inner exception.</p> <pre><code>// denne metode kan placeres i Program-klassen\nprivate static int HentTalFraFil(string sti)\n{\ntry\n{\nstring talSomStreng = System.IO.File.ReadAllText(sti);\nint tal = Convert.ToInt32(talSomStreng);\nreturn tal;\n}\ncatch (Exception ex)\n{\nthrow new ApplicationException($\"Kan ikke konvertere tal fra {sti}\", ex);\n}\n}\n</code></pre> <p>og koden kan pr\u00f8ves i Main-metoden som:</p> <pre><code>try\n{\nint tal = HentTalFraFil(@\"c:\\temp\\tal.txt\");\nConsole.WriteLine($\"Tallet er {tal}\");\n}\ncatch (Exception ex)\n{\n// Egentlig er fejlen:\nConsole.WriteLine(ex.Message);\n// men m\u00e5ske er der en inner exception:\nif (ex.InnerException != null)\n{\nConsole.WriteLine(\" --&gt; \" + ex.InnerException.Message);\n}\n}\n</code></pre> <p>Bem\u00e6rk - en InnerException er en Exception som ogs\u00e5 kan have en InnerException (som ogs\u00e5 kan have en ....). Det er dog ikke s\u00e6rlig tit det forekommer. Man kan altid gemme <code>exception.ToString()</code> s\u00e5 er alle \u201clag\u201d med. Alternativt <code>exception.GetBaseException().ToString()</code> som returnerer den f\u00f8rste Exception (dybeste inner exception eller den aktuelle exception hvis den ikke har nogle inner exceptions)</p>"},{"location":"065_Fejlh%C3%A5ndtering.html#brug-af-throw","title":"Brug af throw","text":"<p>Man kan ogs\u00e5 selv \u201csmide\u201d en fejl (exception) i sin egen kode. Det kan v\u00e6re ret praktisk vil man \u00f8nsker at fort\u00e6lle dem som benytter koden at der er sket en fejl. S\u00e5 kan de selv v\u00e6lge hvordan de \u00f8nsker at behandle fejl.</p> <p>Det sker ved hj\u00e6lp af <code>throw</code>, som kan benyttes p\u00e5 flere m\u00e5der. Hvis den bruges alene:</p> <pre><code>try\n{\n}\ncatch (Exception)\n{\n// evt log\nthrow;\n}\n</code></pre> <p>smider den blot en fejl videre.</p> <p>Men den kan ogs\u00e5 bruges med en reference til et nyt eller eksisterende Exception-objekt.</p> <pre><code>throw new ApplicationException();\nthrow new ApplicationException(\"Der er sket en fejl\");\nthrow new ApplicationException(\"Der er sket en fejl\", andenException);\nthrow new ArgumentException();\nthrow new NotImplementedException();\n</code></pre> <p>Man kan alts\u00e5 selv smide en Exception - typisk en ApplicationException (selvom der er lidt uenighed om best pratice) - hvis man \u00f8nsker at afbryde et flow. Eksempelvis i en metode:</p> <pre><code>bool ValiderCpr(string cpr)\n{\n// Smid en fejl (og hop ud) hvis...\nif (cpr == null)\n{\nthrow new ApplicationException(\"CPR m\u00e5 ikke v\u00e6re null\");\n}\nif (cpr.Length != 10)\n{\nthrow new ApplicationException(\"CPR har ikke den rigtige l\u00e6ngde\");\n}\ntry\n{\n// validering... kode mangler\nreturn true;\n}\ncatch (Exception ex)\n{\n// log\nthrow new ApplicationException(\"Fejl ved validering af CPR\", ex);\n}\n}\n</code></pre> <p>Dem der benytter metoden kan jo s\u00e5 v\u00e6lge om de \u00f8nsker at placere kaldet i en try/catch og behandle eventuelle fejl.</p> <p>Info</p> <p>Info</p>"},{"location":"065_Fejlh%C3%A5ndtering.html#opgave-65-2","title":"Opgave 65-2","text":"<p>Brug ApplicationException til at kaste en fejl ved forkert kald til en metode (kode til s\u00f8gning: GFC)</p> <p>Se opgave</p>"},{"location":"065_Fejlh%C3%A5ndtering.html#opgave-65-3","title":"Opgave 65-3","text":"<p>Noget mere kompleks opgave i brugen af flere catch-blokke, samt brug af ApplicationException. (kode til s\u00f8gning: GFD)</p> <p>Se opgave</p>"},{"location":"065_Fejlh%C3%A5ndtering.html#brug-af-log-systemer","title":"Brug af Log-systemer","text":"<p>Frem for at kode selv skal du bruge et af de mange log systemer:</p> <ul> <li>TraceSource (indbygget i frameworket)</li> <li>NLog</li> <li>Log4Net</li> <li>Serilog</li> </ul> <p>Se devcronberg/SerilogConsoleDemo for en (.NET 6) demo af Serilog. Hvis du vil vide lidt om log s\u00e5 kig eksempelvis p\u00e5 NLog\u2019s tutorial, som er ret god.</p>"},{"location":"065_Fejlh%C3%A5ndtering.html#polly","title":"Polly","text":"<p>Bem\u00e6rk! Sektion kr\u00e6ver viden om lambda mv s\u00e5 dette er blot til info</p> <p>Der findes flere frameworks som kan benyttes til mere avanceret fejlh\u00e5ndtering. Et framework som Polly kan eksempelvis h\u00e5ndtere timeout\u2019s, retry\u2019s og meget mere.</p> <p>Se eksempelvis dette eksempel (inspireret/klippet fra en glimrende artikel: Retry Pattern using Polly in C#), hvor der hentes data fra HttpBin over nettet via HttpClient. Deres services kan bruges til at teste http kald, og dette kald returnerer enten en status kode 200 eller en status kode 408 (RequestTimeout).</p> <p>I koden foretages kald og status koden udskrives - ligegyldigt om det er 200 eller 408.</p> <pre><code>using System;\nusing System.Net.Http;\nusing System.Threading.Tasks;\nnamespace ConsoleApp3\n{\nclass Program\n{\nstatic async Task Main(string[] args)\n{\nvar httpClient = new HttpClient();\nvar response = await httpClient.PostAsync(\"https://httpbin.org/status/200,408\", null);\nif (response.IsSuccessStatusCode)\nConsole.WriteLine(\"Status 200\");\nelse\nConsole.WriteLine(\"Status 408\");\n}\n}\n}\n</code></pre> <p>Her er samme kode men nu pakket ind i Polly, som s\u00f8rger for at gentage kald tre gange med et sekunds interval indtil en eventuel status 200.</p> <pre><code>using System;\nusing System.Net.Http;\nusing System.Threading.Tasks;\nusing Polly;\nnamespace RetryPattern\n{\nclass Program\n{\nstatic async Task Main(string[] args)\n{\nvar httpClient = new HttpClient();\nvar response = await Policy\n.HandleResult&lt;HttpResponseMessage&gt;(message =&gt; !message.IsSuccessStatusCode)\n.WaitAndRetryAsync(new[]\n{\nTimeSpan.FromSeconds(1),\nTimeSpan.FromSeconds(1),\nTimeSpan.FromSeconds(1)\n}, (result, timeSpan, retryCount, context) =&gt; {\nConsole.WriteLine($\"Request failed with {result.Result.StatusCode}. Retry count = {retryCount}. Waiting {timeSpan} before next retry. \");\n})\n.ExecuteAsync(() =&gt; httpClient.PostAsync(\"https://httpbin.org/status/200,408\", null));\nif (response.IsSuccessStatusCode)\nConsole.WriteLine(\"Status 200\");\nelse\nConsole.WriteLine(\"Status 408\");\n}\n}\n}\n</code></pre> <p>Koden er lidt avanceret og kr\u00e6ver viden om asynkron kode, lambda, delegates mv, men princippet er at Polly kan hj\u00e6lpe med \u201cgenerisk fejlcheck\u201d p\u00e5 mange forskellige m\u00e5der. Se @App-vNext.</p>"},{"location":"070_Arrays.html","title":"Arrays","text":""},{"location":"070_Arrays.html#om-modulet","title":"Om modulet","text":"<p>Dette modul handler om klassiske arrays som naturligvis er tilg\u00e6ngelige i C#. Du skal ikke bruge for lang tid p\u00e5 arrays for man benytter typisk mere avancerede og moderne datastrukturer - eksempelvis generiske samlinger som vi ser p\u00e5 i et kommende modul. Men du vil sikkert falde over brugen af arrays i forskellige projekter s\u00e5 det godt at have en grundl\u00e6ggende forst\u00e5else.</p> <p>Hvis du kommer til C# fra andre sprog kan du n\u00f8jes med at l\u00f8be eksemplerne igennem, og lige se den korte \u201ckode-video\u201d om hukommelsesteori.</p>"},{"location":"070_Arrays.html#traditionelt-array","title":"Traditionelt array","text":"<ul> <li>Tilg\u00e6ngelig i n\u00e6sten alle sprog</li> <li>Gemmer sammensatte v\u00e6rdier i en datastruktur hvor data kan tilg\u00e5s gennem et indeks</li> <li> <p>I C# er arrays nulbaseret (index starter fra 0)</p> </li> <li> <p>Vil gerne undg\u00e5 kode som</p> </li> </ul> <pre><code>double nedb\u00f8rM\u00e5ned1 = 4;\ndouble nedb\u00f8rM\u00e5ned2 = 12;\ndouble nedb\u00f8rM\u00e5ned3 = 2;\ndouble nedb\u00f8rM\u00e5ned4 = 8;\ndouble sum = nedb\u00f8rM\u00e5ned1 + nedb\u00f8rM\u00e5ned2 + nedb\u00f8rM\u00e5ned3 + nedb\u00f8rM\u00e5ned4;\nConsole.WriteLine($\"Sum {sum:N2}\");\ndouble gns = sum / 4;\nConsole.WriteLine($\"Gennemsnit {gns:N2}\");\n/*\n ---------- Output: ----------\nSum 26,00\nGennemsnit 6,50\n*/\n</code></pre> <ul> <li>men i stedet bruge arrays for det er meget nemmere at arbejde med</li> </ul> <pre><code>double[] nedb\u00f8r = { 4, 12, 2, 8 };\ndouble sum = 0;\nfor (int i = 0; i &lt; nedb\u00f8r.Length; i++)\nsum += nedb\u00f8r[i];\nConsole.WriteLine($\"Sum {sum:N2}\");\ndouble gns = sum / nedb\u00f8r.Length;\nConsole.WriteLine($\"Gennemsnit {gns:N2}\");\n/*\n ---------- Output: ----------\nSum 26,00\nGennemsnit 6,50\n*/\n</code></pre>"},{"location":"070_Arrays.html#opret-array","title":"Opret array","text":"<ul> <li> <p>Benytter [] i syntaks</p> </li> <li> <p>Arrays er en referencebaseret variabel</p> </li> </ul> <pre><code>// opret en variabel p\u00e5 stack der kan pege\n// p\u00e5 et array af ints\nint[] array1;\n// skab et nyt array (her fem elementer) p\u00e5 heap og bind de\n// to sammen\narray1 = new int[5];\n// samme - bare p\u00e5 en linje\nint[] array2 = new int[5];\n// Bem\u00e6rk - st\u00f8rrelsen p\u00e5 array\n// har kun betydning i allokering af plads p\u00e5 heap.\n// Variablen array1/array2 er den samme - den\n// kan blot \"pege\" p\u00e5 et int array\n</code></pre>"},{"location":"070_Arrays.html#initialisering-af-array","title":"Initialisering af array","text":"<pre><code>// Oprettes og initialiseres med det samme\ndouble[] a3 = new double[] { 5.5, 2.3, 10.45, 5 };\n// Husk at ovenn\u00e6vnte betyder...\n// opret en variabel a3 p\u00e5 stack der kan pege p\u00e5 et double-array\n// opret et double-array p\u00e5 heap og tildel v\u00e6rdier\n// bind de to sammen\n</code></pre>"},{"location":"070_Arrays.html#tilgang-til-array-elementer","title":"Tilgang til array elementer","text":"<ul> <li>Brug []</li> </ul> <pre><code>int[] a1 = new int[3];  // initialiseret til default v\u00e6rdier [0,0,0]\na1[0] = 4;\na1[1] = 8;\na1[2] = 10;\n// a1[3] = 20; // fejl... kun 0,1,2\nstring[] a2 = new string[2];    // initialiseret til [null, null]\na2[0] = \"Mikkel\";\na2[1] = \"Mathias\";\n// l\u00f8b array igennem p\u00e5 forskellig vis\nfor (int i = 0; i &lt; a2.Length; i++)\nConsole.WriteLine(a2[i]);\nConsole.WriteLine();\nforeach (string item in a2)\nConsole.WriteLine(item);\n// avanceret og funktionel m\u00e5de at genneml\u00f8be\n// et array\nConsole.WriteLine();\nSystem.Array.ForEach(a2, i =&gt; Console.WriteLine(i));\n/*\n ---------- Output: ----------\nMikkel\nMathias\nMikkel\nMathias\nMikkel\nMathias\n*/\n</code></pre> <p>Info</p>"},{"location":"070_Arrays.html#opgave-70-1","title":"Opgave 70-1","text":"<p>Simpel opgave i brugen af et array (kode til s\u00f8gning: HAB)</p> <p>Se opgave</p>"},{"location":"070_Arrays.html#manipulering-af-arrays","title":"Manipulering af arrays","text":""},{"location":"070_Arrays.html#instans-metoder","title":"Instans metoder","text":"<pre><code>int[] a = new int[] { 10, 5, 1, 7, 1, 6 };\nConsole.WriteLine(string.Join(' ', a));\nConsole.WriteLine($\"Length: {a.Length}\");\n// Kopi af array til et nyt p\u00e5 heap\nint[] b = a.Clone() as int[];\nConsole.WriteLine();\nConsole.WriteLine(string.Join(' ', a));\nConsole.WriteLine(string.Join(' ', b));\nb[0] = 20;\nConsole.WriteLine();\nConsole.WriteLine(string.Join(' ', a));\nConsole.WriteLine(string.Join(' ', b));\n// Kopiering af v\u00e6rdier\nint[] c = new int[10];\na.CopyTo(c, 0);\nConsole.WriteLine();\nConsole.WriteLine(string.Join(' ', c));\nint[] d = new int[10];\na.CopyTo(d, 4);\nConsole.WriteLine();\nConsole.WriteLine(string.Join(' ', d));\n/*\n ---------- Output: ----------\n10 5 1 7 1 6\nLength: 6\n10 5 1 7 1 6\n10 5 1 7 1 6\n10 5 1 7 1 6\n20 5 1 7 1 6\n10 5 1 7 1 6 0 0 0 0\n0 0 0 0 10 5 1 7 1 6\n*/\n</code></pre>"},{"location":"070_Arrays.html#statiske-metoder","title":"Statiske metoder","text":"<ul> <li>Mange forskellige metoder og muligheder</li> </ul> <pre><code>int[] a = new int[] { 10, 5, 1, 7, 1, 6 };\nConsole.WriteLine(string.Join(' ', a));\nSystem.Array.Resize(ref a, 10);\nConsole.WriteLine(string.Join(' ', a));\n// Husk - det er en reference variabel\n// s\u00e5 v\u00e6rdier swappes rundt p\u00e5 heap\nSystem.Array.Sort(a);\nConsole.WriteLine(string.Join(' ', a));\nSystem.Array.Reverse(a);\nConsole.WriteLine(string.Join(' ', a));\n// Mere avanceret (funktionsorienteret)\nint[] b = new int[] { 10, 5, 1, 7, 1, 6 };\nConsole.WriteLine(string.Join(' ', a));\nint res = System.Array.Find(a, i =&gt; i &lt; 5);\nConsole.WriteLine($\"Find f\u00f8rst &lt;5: {res}\");\nbool res2 = System.Array.TrueForAll(a, i =&gt; i &lt; 5);\nConsole.WriteLine($\"Er alle &lt;5: {res2}\");\n/*\n ---------- Output: ----------\n10 5 1 7 1 6\n10 5 1 7 1 6 0 0 0 0\n0 0 0 0 1 1 5 6 7 10\n10 7 6 5 1 1 0 0 0 0\n10 7 6 5 1 1 0 0 0 0\nFind f\u00f8rst &lt;5: 1\nEr alle &lt;5: False\n*/\n</code></pre>"},{"location":"070_Arrays.html#hvad-med-metoder","title":"Hvad med metoder?","text":"<ul> <li>Igen - arrays er en reference baseret variabel s\u00e5 hvis du sender en s\u00e5dan med til en metode s\u00e5 kan du foretage rettelser i v\u00e6rdierne. Det er jo ikke sikkert at den der kalder din metode er glad for det.</li> </ul> <pre><code>int[] a = { 5, 1, 7 };\nConsole.WriteLine($\"a = {string.Join(' ', a)}\");\nConsole.WriteLine($\"Mindste v\u00e6rdi: { FindMindsteV\u00e6rdi_FEJL(a)}\");\nConsole.WriteLine($\"a = {string.Join(' ', a)}\");\nConsole.WriteLine();\nint[] b = { 5, 1, 7 };\nConsole.WriteLine($\"b = {string.Join(' ', b)}\");\nConsole.WriteLine($\"Mindste v\u00e6rdi: { FindMindsteV\u00e6rdi(b)}\");\nConsole.WriteLine($\"b = {string.Join(' ', b)}\");\nint FindMindsteV\u00e6rdi_FEJL(int[] array)\n{\n// Sorterer det oprindelige array!!!\nSystem.Array.Sort(array);\nreturn array[0];\n}\nint FindMindsteV\u00e6rdi(int[] array)\n{\nint[] kopi = array.Clone() as int[];\nSystem.Array.Sort(kopi);\nreturn kopi[0];\n}\n/*\n ---------- Output: ----------\na = 5 1 7\nMindste v\u00e6rdi: 1\na = 1 5 7\nb = 5 1 7\nMindste v\u00e6rdi: 1\nb = 5 1 7\n*/\n</code></pre>"},{"location":"070_Arrays.html#flere-dimensioner","title":"Flere dimensioner","text":"<ul> <li>Kan arbejde med mange dimensioner</li> </ul> <pre><code>string[,] skakBr\u00e6t = new string[8, 8];\nskakBr\u00e6t[0, 0] = \"Ts\";\nskakBr\u00e6t[0, 1] = \"Hs\";\nskakBr\u00e6t[0, 2] = \"Ls\";\nskakBr\u00e6t[0, 3] = \"Ds\";\nskakBr\u00e6t[0, 4] = \"Ks\";\nskakBr\u00e6t[0, 5] = \"Ls\";\nskakBr\u00e6t[0, 6] = \"Hs\";\nskakBr\u00e6t[0, 7] = \"Ts\";\nfor (int i = 0; i &lt; 8; i++)\n{\nskakBr\u00e6t[1, i] = \"Bs\";\nskakBr\u00e6t[6, i] = \"Bh\";\nskakBr\u00e6t[7, i] = skakBr\u00e6t[0, i].Replace(\"s\", \"h\");\n}\nfor (int r\u00e6kke = 0; r\u00e6kke &lt; 8; r\u00e6kke++)\n{\nfor (int kolonne = 0; kolonne &lt; 8; kolonne++)\n{\nConsole.Write(skakBr\u00e6t[r\u00e6kke, kolonne] + \" \");\n}\nConsole.WriteLine();\n}\n/*\n ---------- Output: ----------\nTs Hs Ls Ds Ks Ls Hs Ts\nBs Bs Bs Bs Bs Bs Bs Bs\nBh Bh Bh Bh Bh Bh Bh Bh\nTh Hh Lh Dh Kh Lh Hh Th\n*/\n</code></pre> <p>Info</p>"},{"location":"070_Arrays.html#opgave-70-2","title":"Opgave 70-2","text":"<p>Opgave som benytter et to dimensionelt array og en tilh\u00f8rende metode (kode til s\u00f8gning: HAC)</p> <p>Se opgave</p>"},{"location":"070_Arrays.html#split-en-streng","title":"Split en streng","text":"<ul> <li>Brug split til at splitte en streng til et array</li> </ul> <pre><code>string csv = \"1;5;7;65\";\nstring[] data = csv.Split(';');\nConsole.WriteLine(string.Join(\",\", data));\n/*\n ---------- Output: ----------\n1,5,7,65\n*/\n</code></pre> <p>Info</p>"},{"location":"070_Arrays.html#opgave-70-3","title":"Opgave 70-3","text":"<p>Brug af Split-metoden til at skabe et array (kode til s\u00f8gning: HAD)</p> <p>Se opgave</p>"},{"location":"070_Arrays.html#sammenst-et-array-til-en-streng","title":"Sammens\u00e6t et array til en streng","text":"<p>String-klassen har en statisk Join metode man kan bruge til at sammens\u00e6tte et array til en streng:</p> <pre><code>int[] w = { 51, 4, 1, 6, 5 };\nstring q = string.Join(' ', w);\nConsole.WriteLine(q);               // \"51 4 1 6 5\"\n</code></pre>"},{"location":"070_Arrays.html#brug-af-foreach","title":"Brug af ForEach","text":"<p>Speciel l\u00f8kke der blandt brug til at iterere over samlinger og arrays.</p> <pre><code>int[] tal = { 5, 1, 3, 1, 6, 7, 1, 6, 8 };\nforeach (int t in tal)\n{\nConsole.WriteLine(t);\n}\n/*\n ---------- Output: ----------\n5\n1\n3\n1\n6\n7\n1\n6\n8\n*/\n</code></pre>"},{"location":"070_Arrays.html#en-konsol-applikation-med-parametre","title":"En konsol applikation med parametre","text":"<p>Hvis en konsol applikation startes med parametre kan det fanges i args-arrayet:</p> <pre><code>test.exe a b c\n</code></pre> <p>eller</p> <pre><code>dotonet test a b c\n</code></pre> <p>Parametre kan findes i args:</p> <pre><code>using System;\nnamespace DemoArgs\n{\nclass Program\n{\nstatic void Main(string[] args)\n{\nif (args != null)\nfor (int i = 0; i &lt; args.Length; i++)\nConsole.WriteLine($\"{i} = {args[i]}\");\n}\n}\n}\n</code></pre> <p>PS argumenter kan ogs\u00e5 s\u00e6ttes under Debug-fanen i egenskaberne til projektet (h\u00f8jreklik p\u00e5 projektet). PS brug eventuelt en af de mange NuGet-pakker for at g\u00f8re tilgang til argumenter nemmere - CommandLineArgumentsParser</p>"},{"location":"070_Arrays.html#avancerede-metoder","title":"Avancerede metoder","text":"<p>Der findes en del statiske metoder p\u00e5 System.Array, som egner sig bedst til brug af lambda. Flere v\u00e6lge dog at bruge LINQ men metoderne er tilg\u00e6ngelige.</p> <pre><code>int[] a = { 5, 4, 2, 1, 3, 6, 8, 12, 6, 3, 1 };\n// Skift type\nbyte[] b = Array.ConvertAll&lt;int, byte&gt;(a, (x) =&gt; (byte)x);\n// Genneml\u00f8b\nArray.ForEach(a, x =&gt; Console.WriteLine(x));\n// Findes element\nbool c = Array.Exists(a, x =&gt; x == 1);      // true\n// Find\nint d = Array.Find(a, x =&gt; x == 12);        // 7\n// Find alle\nint[] e = Array.FindAll(a, x =&gt; x &lt; 5);     // 4, 2, 1, 3, 3, 1\n// Er det sandt at alle elementer er ...\nbool f = Array.TrueForAll(a, x =&gt; x &lt; 20);  // true\n</code></pre>"},{"location":"070_Arrays.html#systemindex-og-systemrange","title":"System.Index og System.Range","text":"<p>Den lidt specielle ^ og .. syntaks der kendes fra andre sprog kan ogs\u00e5 bruges i C#</p> <ul> <li>^ betyder fra enden<ul> <li>System.Index</li> <li>^0 returnerer l\u00e6ngden</li> </ul> </li> <li>.. betyder range<ul> <li>System.Range</li> </ul> </li> </ul> <pre><code>int[] nr = new[] { 5, 7, 1, 3, 9, 10, 0, 1, 2, 7 };\nVisArray(nr[..]);           // 5 7 1 3 9 10 0 1 2 7\nVisArray(nr[..4]);          // 5 7 1 3\nVisArray(nr[4..]);          // 9 10 0 1 2 7\nVisArray(nr[1..5]);         // 7 1 3 9\n// Bagfra\nConsole.WriteLine(nr[^1]);  // 7\nConsole.WriteLine(nr[^5]);  // 10\nVisArray(nr[^2..]);         // 2 7\nVisArray(nr[^5..^3]);       // 10 0\nSystem.Index fra = ^4;\nSystem.Index til = ^2;\nVisArray(nr[fra..til]);     // 0 1\nSystem.Range r = 1..4;\nVisArray(nr[r]);            // 7 1 3\nvoid VisArray(int[] a)\n{\nConsole.WriteLine(string.Join(' ', a));\n}\n</code></pre>"},{"location":"070_Arrays.html#brug-af-params","title":"Brug af params","text":"<ul> <li>Brug evt params i argument listen til metoder</li> <li>Argumenter overf\u00f8res som array</li> </ul> <pre><code>Test1(1);\nTest1(1, 2);\nTest1(1, 2, 3);\nTest2(1, 1);\nTest2(1, 1, 2);\nTest2(1, 1, 2, 3);\nvoid Test1(params int[] args)\n{\nConsole.WriteLine($\"Kaldt med {String.Join(\", \", args)}\");\n}\nvoid Test2(int a, params int[] args)\n{\nConsole.WriteLine($\"Kaldt med a={a} og {String.Join(\", \", args)}\");\n}\n/*\n ---------- Output: ----------\nKaldt med 1\nKaldt med 1, 2\nKaldt med 1, 2, 3\nKaldt med a=1 og 1\nKaldt med a=1 og 1, 2\nKaldt med a=1 og 1, 2, 3\n*/\n</code></pre>"},{"location":"075_Samlinger.html","title":"Samlinger","text":""},{"location":"075_Samlinger.html#om-modulet","title":"Om modulet","text":"<p>Her skal du l\u00e6re om forskellige samlinger der kan bruges til at opbevare data. Der findes mange forskellige men du kan n\u00f8jes med at fokusere p\u00e5 de mest benyttede:</p> <ul> <li>System.Collections.Generic.List&lt;&gt;</li> <li>System.Collections.Generic.Queue&lt;&gt;</li> <li>System.Collections.Generic.Stack&lt;&gt;</li> <li>System.Collections.Generic.Dictionary&lt;&gt;</li> </ul> <p>De resterende klasser (under System.Collections og System.Collections.Generic) kan v\u00e6re meget effektive, men de er ikke brugt s\u00e5 meget i grundl\u00e6ggende C#.</p>"},{"location":"075_Samlinger.html#overordnet-om-samlinger","title":"Overordnet om samlinger","text":"<p>Der findes mange forskellige strukturer der kan benyttes til opbevare data i C#. System.Array (standard array) er en type, men C# tilbyder en masse andre og langt mere effektive strukturer. I de f\u00f8rste versioner af .NET var klasser under System.Collection de eneste tilg\u00e6ngelige, men i de senere versioner er samlinger (collections) under System.Collections.Generic dukket op. De er langt mere effektive end p\u00e5 arrays og \u201cde gamle\u201d collection-klasser, og du b\u00f8r derfor fokusere p\u00e5 disse.</p>"},{"location":"075_Samlinger.html#typesvage-samlinger","title":"Typesvage samlinger","text":"<ul> <li> <p>Findes en del Collection-klasser under System.Collection - bla</p> </li> <li> <p>ArrayList</p> </li> <li>HashTable</li> <li>SortedList</li> <li>Stack</li> <li> <p>Queue</p> </li> <li> <p>Benyttes ikke s\u00e5 meget mere fordi de er typesvage - brug i stedet System.Collections.Generic-klasser</p> </li> </ul> <pre><code>System.Collections.ArrayList lst =\nnew System.Collections.ArrayList();\nlst.Add(\"mathias\");\nlst.Add(\"mikkel\");\nlst.Add(12);\nlst.Add(true);\nforeach (var item in lst)\n{\nConsole.WriteLine(item);\n}\n/*\n ---------- Output: ----------\nmathias\nmikkel\n12\nTrue\n*/\n</code></pre>"},{"location":"075_Samlinger.html#typestrke-samlinger","title":"Typest\u00e6rke samlinger","text":"<p>Anderledes er det med de typest\u00e6rke collections fra System.Collections.Generics</p> <ul> <li>Benyt &lt;&gt; for at angive typen</li> <li>Mange forskellige muligheder</li> <li>List&lt;&gt;</li> <li>Stack&lt;&gt;</li> <li>Queue&lt;&gt;</li> <li>Hash&lt;&gt;</li> <li>Dictionary&lt;&gt;</li> <li>Hvis man har \u201cusing System.Linq;\u201d tilf\u00f8jes en masse ekstra metoder - mere om det senere. For at simplificere forst\u00e5elsen vil jeg anbefale, at du fjerner \u201cusing System.Linq;\u201d indtil du kender de enkelte collection-klasser.</li> </ul>"},{"location":"075_Samlinger.html#list","title":"List&lt;&gt;","text":"<p>En List&lt;&gt; kan sammenlignes med et dynamisk array, og indeholder en masse metoder. Collection-klassen er langt mere effektiv end arrays, og du vil sikkert benytte denne klasse til at opbevare data i 80-90 procent af tilf\u00e6ldene.</p> <pre><code>System.Collections.Generic.List&lt;string&gt; lst = new System.Collections.Generic.List&lt;string&gt;();\nlst.Add(\"a\"); // kan kun h\u00e5ndtere en streng\n// lst.Add(1);  fejl\nlst.Add(\"b\");\nstring c = \"c\";\nlst.Add(c);\nlst.Insert(1, \"*\");\nlst.InsertRange(2, new string[] { \"q\", \"ww\", \"ee\", \"rr\" });\nlst.Remove(\"*\");\nlst.RemoveAt(2);\nConsole.WriteLine($\"Findes q: {lst.Contains(\"q\")}\");\nConsole.WriteLine(\"Vis alle:\");\nforeach (var item in lst)   // item = string\n{\nConsole.WriteLine(item);\n}\nlst.Sort();\nConsole.WriteLine();\nConsole.WriteLine(\"Vis alle efter sort:\");\nforeach (var item in lst)   // item = string\n{\nConsole.WriteLine(item);\n}\n// avanceret (delegates/lambda - se senere)\nvar res = lst.FindAll(s =&gt; s.Length == 1);\nConsole.WriteLine($\"Hvor mange elementer har l\u00e6ngden 1: {res.Count}\");\n/*\n ---------- Output: ----------\nFindes q: True\nVis alle:\na\nq\nee\nrr\nb\nc\nVis alle efter sort:\na\nb\nc\nee\nq\nrr\nHvor mange elementer har l\u00e6ngden 1: 4\n*/\n</code></pre> <p>Info</p>"},{"location":"075_Samlinger.html#opgave-75-1","title":"Opgave 75-1","text":"<p>Simpel opgave i brugen af forskellige collections (kode til s\u00f8gning: HFB)</p> <p>Se opgave</p>"},{"location":"075_Samlinger.html#stack-lifo","title":"Stack&lt;&gt; (LIFO)","text":"<ul> <li>Last in - First out</li> <li>Forestil dig en stabel tallerkner</li> </ul> <pre><code>System.Collections.Generic.Stack&lt;int&gt; lst = new System.Collections.Generic.Stack&lt;int&gt;();\nlst.Push(1);\nlst.Push(2);\nlst.Push(3);\nvar tal = lst.Pop();\nforeach (var item in lst)\n{\nConsole.WriteLine(item);\n}\nConsole.WriteLine($\"Findes 2 p\u00e5 stack: {lst.Contains(2)}\");\n/*\n ---------- Output: ----------\n2\n1\nFindes 2 p\u00e5 stack: True\n*/\n</code></pre> <p>Info</p>"},{"location":"075_Samlinger.html#opgave-75-2","title":"Opgave 75-2","text":"<p>Dan en bunke af kort ved hj\u00e6lp af en Stack&lt;&gt; (kode til s\u00f8gning: HFC)</p> <p>Se opgave</p>"},{"location":"075_Samlinger.html#queue-fifo","title":"Queue&lt;&gt; (FIFO)","text":"<ul> <li>First In - First Out</li> <li>Forestil dig k\u00f8en ved en kasse i et supermarked</li> </ul> <pre><code>System.Collections.Generic.Queue&lt;int&gt; lst = new System.Collections.Generic.Queue&lt;int&gt;();\nlst.Enqueue(1);\nlst.Enqueue(2);\nlst.Enqueue(3);\nvar tal = lst.Dequeue();\nforeach (var item in lst)\n{\nConsole.WriteLine(item);\n}\nConsole.WriteLine($\"Findes 2 p\u00e5 k\u00f8: {lst.Contains(2)}\");\n/*\n ---------- Output: ----------\n2\n3\nFindes 2 p\u00e5 k\u00f8: True\n*/\n</code></pre>"},{"location":"075_Samlinger.html#dictionary","title":"Dictionary&lt;,&gt;","text":"<ul> <li>N\u00f8gle og v\u00e6rdi struktur</li> <li>Der skal b\u00e5de oprettes en type af n\u00f8glen og en type af v\u00e6rdien</li> </ul> <pre><code>// n\u00f8gle = int, v\u00e6rdi = string\nSystem.Collections.Generic.Dictionary&lt;string, int&gt; lst = new System.Collections.Generic.Dictionary&lt;string, int&gt;();\nlst.Add(\"a\", 1324);\nlst.Add(\"b\", 23);\nlst.Add(\"c\", 113);\nforeach (var item in lst)\n{\nConsole.WriteLine($\"{item}, {item.Key}, {item.Value}\");\n}\nint v = lst[\"b\"];\nConsole.WriteLine($\"v = {v}\");\n/*\n ---------- Output: ----------\n[a, 1324], a, 1324\n[b, 23], b, 23\n[c, 113], c, 113\nv = 23\n*/\n</code></pre>"},{"location":"075_Samlinger.html#initializers","title":"Initializers","text":"<pre><code>class Person {\npublic string Navn { get; set; }\npublic int Alder { get; set; }\n}\n</code></pre> <pre><code>List&lt;int&gt; tal = new List&lt;int&gt;() { 4, 5, 4, 2, 2, 4, 6, 6 };\nList&lt;Person&gt; personer = new List&lt;Person&gt;()\n{\nnew Person { Navn = \"a\", Alder = 1 },\nnew Person { Navn = \"b\", Alder = 2 }\n};\n</code></pre> <p>Fungerer udelukkende med klasser som har en Add() metode.</p>"},{"location":"075_Samlinger.html#ienumerable","title":"IEnumerable","text":"<p>Giver mulighed for, at en klasse kan itereres, og er implementeret af de fleste collection-klasser og arrays. Best\u00e5r af metoden GetEnumberator, som returnerer IEnumerator</p> <ul> <li>Current</li> <li>MoveNext() (returnerer false hvis der ikke er flere elementer)</li> <li>Reset()</li> </ul> <pre><code>static void Main(string[] args)\n{\nIEnumerable&lt;int&gt; tal = FindTal1();\nIEnumerator&lt;int&gt; enumerator = tal.GetEnumerator();\nwhile (enumerator.MoveNext())\nConsole.WriteLine(enumerator.Current);\n}\nstatic IEnumerable&lt;int&gt; FindTal1()\n{\nList&lt;int&gt; lst = new List&lt;int&gt;();\nint i = 0;\ndo\n{\ni++;\nlst.Add(i);\nConsole.WriteLine($\"Fundet {i} i FindTal1\");\nif (i == 3)\nbreak;\n} while (true);\nreturn lst;\n}\n</code></pre> <p>Men man kan ogs\u00e5 bruge interfacet selv.</p> <pre><code>class Person\n{\npublic string Navn { get; set; }\npublic int Alder { get; set; }\n}\nclass Personer : IEnumerable&lt;Person&gt;\n{\nprivate List&lt;Person&gt; _personer = new List&lt;Person&gt;();\npublic IEnumerator&lt;Person&gt; GetEnumerator()\n{\nreturn ((IEnumerable&lt;Person&gt;)_personer).GetEnumerator();\n}\npublic void Tilf\u00f8jPerson(Person p)\n{\n_personer.Add(p);\n}\nIEnumerator IEnumerable.GetEnumerator()\n{\nreturn ((IEnumerable&lt;Person&gt;)_personer).GetEnumerator();\n}\n}\n</code></pre> <pre><code>Personer lst = new Personer();\nlst.Tilf\u00f8jPerson(new Person { Navn = \"a\", Alder = 1 });\nlst.Tilf\u00f8jPerson(new Person { Navn = \"b\", Alder = 2 });\nlst.Tilf\u00f8jPerson(new Person { Navn = \"c\", Alder = 3 });\nforeach (var p in lst)\nConsole.WriteLine(p.Navn);\n</code></pre> <p>Info</p>"},{"location":"075_Samlinger.html#opgave-75-3","title":"Opgave 75-3","text":"<p>Brug af IEnumable og IComparable til at skabe en garage med biler (kode til s\u00f8gning: HFD)</p> <p>Se opgave</p>"},{"location":"075_Samlinger.html#indexer","title":"Indexer","text":"<p>Man kan tilf\u00f8je index\u2019er til arrays/lister i egne klasser:</p> <pre><code>class Hund { }\nclass Kennel {\nprivate List&lt;Hund&gt; lst = new List&lt;Hund&gt;();\npublic void HundInd(Hund h) =&gt; lst.Add(h);\npublic Hund this[int i]\n{\nget { return lst[i]; }\n// set { lst[i] = value; } skal det tillades\n}\n// Ny fancy syntaks\n//public Hund this[int i]\n//{\n//    get =&gt; lst[i];\n//    set =&gt; lst[i] = value;\n//}\n}\n</code></pre> <pre><code>Kennel k = new Kennel();\nk.HundInd(new Hund());\nk.HundInd(new Hund());\nvar h = k[0];\n</code></pre>"},{"location":"075_Samlinger.html#brug-af-yield","title":"Brug af yield","text":"<p>yield-kodeordet kan benyttes i metoder/egenskaber til at skabe et resultat (IEnumerable) der kan itereres. Der kan yield return fra en metode bruges til at returnere et element af gangen. Det kan benyttes til at returnere en str\u00f8m af data i stedet for en komplet datastruktur. Samtidigt skaber yield en statemachine som kan benyttes i forskellige alogritmer.</p> <p>Se f\u00f8lgende - og l\u00e6g m\u00e6rke til forskellen i de to m\u00e5der at danne tal</p> <pre><code>static void Main(string[] args)\n{\n{\nIEnumerable&lt;int&gt; tal = FindTal1();\nIEnumerator&lt;int&gt; enumerator = tal.GetEnumerator();\nwhile (enumerator.MoveNext())\nConsole.WriteLine(enumerator.Current);\n}\nConsole.WriteLine();\n{\nIEnumerable&lt;int&gt; tal = FindTal2();\nIEnumerator&lt;int&gt; enumerator = tal.GetEnumerator();\nwhile (enumerator.MoveNext())\nConsole.WriteLine(enumerator.Current);\n}\nConsole.WriteLine();\n// exit\n{\nIEnumerable&lt;int&gt; tal = FindTal2();\nIEnumerator&lt;int&gt; enumerator = tal.GetEnumerator();\nint i = 0;\nwhile (enumerator.MoveNext())\n{\nConsole.WriteLine(enumerator.Current);\nif (i++ == 1)\nbreak;\n}\n}    // kan ogs\u00e5 implementeres med foreach\nConsole.WriteLine();\n{\nforeach (var item in FindTal1())\nConsole.WriteLine(item);\n}\nConsole.WriteLine();\n{\nforeach (var item in FindTal2())\nConsole.WriteLine(item);\n}\n}\nstatic IEnumerable&lt;int&gt; FindTal1()\n{\nList&lt;int&gt; lst = new List&lt;int&gt;();\nint i = 0;\ndo\n{\ni++;\nlst.Add(i);\nConsole.WriteLine($\"Fundet {i} i FindTal1\");\nif (i == 3)\nbreak;\n} while (true);\nreturn lst;\n}\nstatic IEnumerable&lt;int&gt; FindTal2()\n{\nint i = 0;\ndo\n{\ni++;\nConsole.WriteLine($\"Fundet {i} i FindTal2\");\nyield return i;\nif (i == 3)\nyield break;\n} while (true);\n}\n</code></pre> <p>Her er et andet eksempel p\u00e5 brug af yield til at finde data (fra db, fil, logik mv)</p> <pre><code>class Person\n{\npublic string Navn { get; set; }\npublic int Alder { get; set; }\n}\nclass Personer : IEnumerable&lt;Person&gt;\n{\nprivate List&lt;Person&gt; _personer = new List&lt;Person&gt;();\npublic IEnumerator&lt;Person&gt; GetEnumerator()\n{\nreturn ((IEnumerable&lt;Person&gt;)_personer).GetEnumerator();\n}\npublic void Tilf\u00f8jPerson(Person p)\n{\n_personer.Add(p);\n}\npublic IEnumerable&lt;Person&gt; FindAllePersoner()\n{\nforeach (var p in _personer)\nyield return p;\n}\npublic IEnumerable&lt;Person&gt; FindPersonerUnderAlder(int alder)\n{\nforeach (var p in _personer)\nif (p.Alder &lt; alder)\nyield return p;\n}\nIEnumerator IEnumerable.GetEnumerator()\n{\nreturn ((IEnumerable&lt;Person&gt;)_personer).GetEnumerator();\n}\n}\n</code></pre> <pre><code>Personer lst = new Personer();\nlst.Tilf\u00f8jPerson(new Person { Navn = \"a\", Alder = 1 });\nlst.Tilf\u00f8jPerson(new Person { Navn = \"b\", Alder = 2 });\nlst.Tilf\u00f8jPerson(new Person { Navn = \"c\", Alder = 3 });\nforeach (var p in lst)\nConsole.WriteLine(p.Navn);\nforeach (var p in lst.FindAllePersoner())\nConsole.WriteLine(p.Navn);\nforeach (var p in lst.FindPersonerUnderAlder(2))\nConsole.WriteLine(p.Navn);\n</code></pre> <p>Info</p> <pre><code>\n</code></pre>"},{"location":"075_Samlinger.html#opgave-75-4","title":"Opgave 75-4","text":"<p>Brug af yield return til at skabe Fibonacci-numre (kode til s\u00f8gning: HFE)</p> <p>Se opgave</p>"},{"location":"080_Klasser.html","title":"Klasser","text":""},{"location":"080_Klasser.html#om-modulet","title":"Om modulet","text":"<p>I dette modul vil du l\u00e6re den helt grundl\u00e6ggende teori bag klasser. Du skal have en forst\u00e5else for de forskellige typer af medlemmer du kan bruge til at designe dine klasser, og \u00f8ve dig i at kunne finde entiteter i en applikation, og abstrahere disse til klasser. Dem kan du s\u00e5 bruge til at skabe objekter af.</p> <p>Der er en del opgaver i dette modul som du b\u00f8r bruge lidt tid p\u00e5.</p>"},{"location":"080_Klasser.html#grundlggende-om-klasser","title":"Grundl\u00e6ggende om klasser","text":"<p>Klasse er en skabelon for instanser (typisk kaldet objekter)</p> <ul> <li>En skabelon kan bruges til mange objekter</li> <li>Den eneste forskel p\u00e5 objekter af samme type er data (tilstand)</li> </ul> <p>Abstraktion over element og proces</p> <ul> <li>Yatzy-spil</li> <li>Terning, B\u00e6ger, Spilleplade, Spillere, Spil/regler</li> <li>Shop</li> <li>Kunde, Vare, Lager, Faktura, FakturaLinje</li> <li>Vagtplan</li> <li>Medarbejder, Leder, Butikker, \u00c5bningstider</li> </ul> <p>En type best\u00e5r af</p> <p></p> <p>Synlighed</p> <ul> <li>internal (kun typer som ikke er placeret i en anden type)</li> <li>private</li> <li>public</li> <li>protected</li> </ul>"},{"location":"080_Klasser.html#definition-af-klasser","title":"Definition af klasser","text":"<ul> <li>Brug class-kodeordet</li> <li>Navngivning (som variabler)</li> <li>Synlighed</li> <li>internal (internt i projektet)</li> <li>public (alle der skaber en reference til projektet kan se typen)</li> <li>(private) kun ved brug i \u201cklasser i klasser\u201d</li> <li>(protected) kun ved nedarvning - se senere</li> </ul> <pre><code>namespace Klasser1\n{\n// public eller internal (private, protected)\ninternal class Person\n{\n// medlemmer\n}\n}\n</code></pre>"},{"location":"080_Klasser.html#oprettelse-af-objekter","title":"Oprettelse af objekter","text":"<p>N\u00e5r man skal oprette et objekt af en klasse benytter man new-kodeordet, og referencen skal gemmes i en variabel af den korrekte type. HUSK - at klasser er en reference baseret variabel.</p> <pre><code>// variabel som kan pege p\u00e5 et objekt\nKlasser1.Person p1;\n// Nyt objekt p\u00e5 heap og bind ref til p1\np1 = new Klasser1.Person();\n// eller p\u00e5 samme linje\nKlasser1.Person p2 = new Klasser1.Person();\n// men p2 er stadig en variabel der kan pege p\u00e5 et Person-objekt\n// derfor kan man\np1 = p2;\n// hvorefter det p1 tidligere pegede p\u00e5 er v\u00e6k\n// Fra C# 9 kan man ogs\u00e5\nKlasser1.Person p3 = new ();\n</code></pre> <p>Her er en kort animieret gif - en gul linje viser at der skal til at blive afviklet! Du skal v\u00e6re helt skarp p\u00e5 hvad der sker:</p> <ul> <li>En variabel p\u00e5 stack\u2019en (del af hukommelse) kan pege p\u00e5 et objekt p\u00e5 heap (anden del af hukommelse)</li> <li>new-kodet skaber objektet p\u00e5 heap\u2019en</li> <li>= gemmer referencen til objektet i variablen</li> <li>Hvis et objekt p\u00e5 heap\u2019en ikke er refereret bliver det automatisk fjernet</li> </ul> <p></p>"},{"location":"080_Klasser.html#systemobject","title":"System.Object","text":"<p>Alle referencebaserede typer arver fra System.Object, og alle v\u00e6rdibaserede typer er kompatible med System.ValueType, som arver fra System.Object.</p> <p></p> <p>Derfor best\u00e5r alle typer af metoderne:</p> Navn Beskrivelse (virtual) bool Equals Sammenligner to instanser (virtual) int GetHashCode Skaber en hash v\u00e6rdi til gruppering Type GetType Returnerer typen (virtual) string ToString Konverterer instans til en streng <pre><code>int a = 1;\nConsole.WriteLine(a.Equals(1));\nConsole.WriteLine(a.GetHashCode());\nConsole.WriteLine(a.GetType().Name);\nConsole.WriteLine(a.ToString());\nSystem.IO.FileInfo b = new System.IO.FileInfo(@\"c:\\temp\\test.txt\");\nSystem.IO.FileInfo c = b;\nConsole.WriteLine(b.Equals(c));\nConsole.WriteLine(b.GetHashCode());\nConsole.WriteLine(b.GetType().Name);\nConsole.WriteLine(b.ToString());\n</code></pre> <p>S\u00e5 hvis du undre dig over hvor eksempelvis ToString-metoden kommer fra p\u00e5 en ellers \u201ctom\u201d klasse er det derfor.</p>"},{"location":"080_Klasser.html#felter","title":"Felter","text":"<ul> <li>Felter (fields) er objekternes data</li> <li>kan v\u00e6re alle typer</li> </ul> <ul> <li>Synlighed</li> <li>private (default)<ul> <li>Kan kun tilg\u00e5s internt</li> </ul> </li> <li>public<ul> <li>Kan tilg\u00e5s b\u00e5de internt og eksternt</li> </ul> </li> </ul> <pre><code>namespace Klasser2\n{\npublic class Person\n{\npublic string navn;\nprivate int alder;\nprivate K\u00f8n k\u00f8n;\npublic void Test() {\n// her kan alle felter tilg\u00e5s - b\u00e5de private og public\n}\n}\npublic enum K\u00f8n {\nMand,\nKvinde\n}\n}\n</code></pre> <ul> <li>Felter tilg\u00e5s med punktumnotation</li> </ul> <pre><code>Klasser2.Person p1 = new Klasser2.Person();\np1.navn = \"Mikkel\";\nConsole.WriteLine(p1.navn);\n// p1.alder = 15; FEJL : alder kan ikke tilg\u00e5s - den er privat for klassen\n// Console.WriteLine(p1.alder);  Fejl: alder kan ikke tilg\u00e5s -den er privat for klassen\n/*\n ---------- Output: ----------\nMikkel\n*/\n</code></pre>"},{"location":"080_Klasser.html#readonly-felter","title":"readonly felter","text":"<ul> <li>Et readonly felt kan kun intialiseres i constructor eller ved intialisering og kan derefter ikke tilrettes</li> </ul> <pre><code>using System;\nnamespace Klasser14\n{\npublic class Person\n{\npublic readonly string Navn = \"\";\npublic Person(string navn)\n{\nthis.Navn = navn;\n}\npublic void Test() {\n// this.Navn = \"\"; fejl - m\u00e5 kun tildeles i constructor eller ved initialisering\n}\n}\n}\n</code></pre> <p>Det giver mulighed for at skabe immutable felter.</p>"},{"location":"080_Klasser.html#default-constructor","title":"Default constructor","text":"<ul> <li>Metode der automatisk afvikles ved brug af new</li> <li>Default constructor er uden argumenter og returv\u00e6rdi</li> <li>Der kan kun findes \u00e9n</li> <li>Typisk brug ved initialisering</li> <li>Brug evt \u201cctor\u201d snippet</li> </ul> <pre><code>using System;\nusing System.Collections.Generic;\nusing System.Text;\nnamespace Klasser3\n{\npublic class Person\n{\nprivate string navn;\nprivate int alder;\npublic Person()\n{\n// Valgfrit om man \u00f8nsker at benytte this-kodeordet\nthis.navn = \"\";\nalder = 0;\n}\n}\n}\n</code></pre>"},{"location":"080_Klasser.html#privat-constructor","title":"Privat constructor","text":"<ul> <li>Hvis man tilf\u00f8jer en privat default constructor kan man ikke skabe et objekt af klassen</li> <li>Singleton-m\u00f8nster</li> </ul> <pre><code>namespace Eksempler\n{\npublic class Singleton\n{\n// Man m\u00e5 ikke skabe en instans - kun HentSingleton er mulig\nprivate Singleton() { }\n// instans data (b\u00f8r ikke v\u00e6re offentligt felt)\npublic int Id;\n// mv...\nprivate static Singleton o = null;\npublic static Singleton HentSingleton() {\nif (o == null)\no = new Singleton();\nreturn o;\n}\n}\n}\n</code></pre> <p>Info</p>"},{"location":"080_Klasser.html#opgave-80-1","title":"Opgave 80-1","text":"<p>Avanceret opgave der viser singleton-m\u00f8nsteret (kode til s\u00f8gning: IAB)</p> <p>Se opgave</p>"},{"location":"080_Klasser.html#custom-constructor","title":"Custom constructor","text":"<ul> <li>Metode(r) der automatisk afvikles ved brug af new</li> <li>Har argumenter</li> <li>Bruges typisk til initialisering af private felter</li> <li>Man kan n\u00f8jes med en custom eller flere custom constructor\u2019s</li> </ul> <pre><code>namespace Klasser4\n{\npublic class Person\n{\nprivate string navn;\nprivate int alder;\npublic Person(string navn, int alder)\n{\nthis.navn = navn;\nthis.alder = alder;\n}\n// Man m\u00e5 gerne have flere\npublic Person(string navn)\n{\nthis.navn = navn;\nthis.alder = 0;\n}\n}\n}\n</code></pre> <ul> <li>S\u00e5 skal man benytte den/dem ved oprettelse af objekt</li> </ul> <pre><code>// Brug af custom construtor\nKlasser4.Person p1 = new Klasser4.Person(\"Mikkel\", 15);\nKlasser4.Person p2 = new Klasser4.Person(\"Mikkel\");\n// Klasser4.Person p1 = new Klasser4.Person(); Fejl: Default constructor findes ikke\n</code></pre> <ul> <li>Du kan v\u00e6lge b\u00e5de at have en default og custom constructor</li> </ul> <pre><code>namespace Klasser5\n{\npublic class Person\n{\nprivate string navn;\nprivate int alder;\npublic Person()\n{\nthis.navn = \"\";\nthis.alder = 0;\n}\npublic Person(string navn, int alder)\n{\nthis.navn = navn;\nthis.alder = alder;\n}\n// Man m\u00e5 gerne have flere\npublic Person(string navn)\n{\nthis.navn = navn;\nthis.alder = 0;\n}\n}\n}\n</code></pre> <ul> <li>S\u00e5 kan du frit v\u00e6lge ved oprettelse hvilken constructor du vil benytte</li> </ul> <pre><code>// Brug af forskellige constructors\nKlasser5.Person p1 = new Klasser5.Person();\nKlasser5.Person p2 = new Klasser5.Person(\"Mikkel\");\nKlasser5.Person p3 = new Klasser5.Person(\"Mikkel\", 15);\n</code></pre>"},{"location":"080_Klasser.html#genbrug-af-constructor","title":"Genbrug af constructor","text":"<ul> <li>Man kan binde flere constructors sammen for at undg\u00e5 kopi af (initaliserings- og validerings)kode</li> <li>Brug af this-kodeordet</li> </ul> <pre><code>namespace Klasser6\n{\npublic class Person\n{\nprivate string navn;\nprivate int alder;\n// \"mor\" for alle constructors\npublic Person(string navn, int alder)\n{\nthis.navn = navn;\nthis.alder = alder;\n}\npublic Person() : this(\"\", 0)\n{\n}\npublic Person(string navn) : this(navn, 0)\n{\n}\n}\n}\n</code></pre> <p>Info</p> <p>Info</p> <p>Info</p> <p>Info</p> <p>Info</p>"},{"location":"080_Klasser.html#opgave-80-2","title":"Opgave 80-2","text":"<p>Simpel klasse der repr\u00e6senterer en terning (kode til s\u00f8gning: IAC)</p> <p>Se opgave</p>"},{"location":"080_Klasser.html#opgave-80-3","title":"Opgave 80-3","text":"<p>Lidt avanceret klasse til at repr\u00e6sentere en terning (kode til s\u00f8gning: IAD)</p> <p>Se opgave</p>"},{"location":"080_Klasser.html#opgave-80-4","title":"Opgave 80-4","text":"<p>For at spille Yatzy skal vi bruge et b\u00e6ger - en m\u00e5de at skabe et b\u00e6ger er at benytte et array. (kode til s\u00f8gning: IAE)</p> <p>Se opgave</p>"},{"location":"080_Klasser.html#opgave-80-5","title":"Opgave 80-5","text":"<p>Lille opgave i erkl\u00e6ring og brug af en klasse og constructor (kode til s\u00f8gning: IAF)</p> <p>Se opgave</p>"},{"location":"080_Klasser.html#opgave-80-6","title":"Opgave 80-6","text":"<p>Skab en Konto-klasser der inderholder en liste af transaktioner. Her er der is\u00e6r fokus p\u00e5 (manglende) sikkerhed. (kode til s\u00f8gning: IAG)</p> <p>Se opgave</p>"},{"location":"080_Klasser.html#initialisering-ved-oprettelse-af-objekter","title":"Initialisering ved oprettelse af objekter","text":"<ul> <li>Man kan v\u00e6lge at initialisere objekter med data direkte ved oprettelse</li> </ul> <pre><code>Klasser9.Person p = new Klasser9.Person();\np.Navn = \"Mathias\";\np.Alder = 12;\nConsole.WriteLine($\"{p.Navn} er {p.Alder} \u00e5r gammel\");\n// eller\nKlasser9.Person p2 = new Klasser9.Person()\n{\nNavn = \"Mathias\",\nAlder = 12\n};\nConsole.WriteLine($\"{p.Navn} er {p.Alder} \u00e5r gammel\");\n/*\n ---------- Output: ----------\nMathias er 12 \u00e5r gammel\nMathias er 12 \u00e5r gammel\n*/\n</code></pre>"},{"location":"080_Klasser.html#statiske-medlemmer","title":"Statiske medlemmer","text":"<ul> <li>Ligesom diverse typer har instans og statiske metoder:</li> </ul> <pre><code>int i = 10;\n// Instans metode\nConsole.WriteLine(i.ToString());\n// Statisk metode\nConsole.WriteLine(int.MinValue);\n/*\n ---------- Output: ----------\n10\n-2147483648\n*/\n</code></pre> <ul> <li>kan klasser ogs\u00e5 have statiske medlemmer - typisk metoder (men egenskaber og felter kan ogs\u00e5 v\u00e6re statiske).</li> <li>giver mulighed for at skabe medlemmer som kan benyttes uden at skabe et objekt</li> <li>klasser kan ogs\u00e5 markeres som statiske (m\u00e5 kun indeholde statiske metoder)</li> </ul> <pre><code>namespace Klasser12\n{\npublic class Person\n{\n// instans medlemmer\npublic string Navn { get; set; }\npublic string StortNavn() {\nreturn this.Navn.ToUpper();\n}\npublic static string KonverterTilStortNavn(string navn) {\nreturn navn.ToUpper();\n}\n}\n}\n</code></pre> <ul> <li>brug af klasse</li> </ul> <pre><code>Klasser12.Person p = new Klasser12.Person() { Navn = \"mikkel\" };\nConsole.WriteLine(p.StortNavn());\nConsole.WriteLine(Klasser12.Person.KonverterTilStortNavn(\"mikkel\"));\n/*\n ---------- Output: ----------\nMIKKEL\nMIKKEL\n*/\n</code></pre> <ul> <li>Man kan ogs\u00e5 benytte statiske data og en evt tilh\u00f8rende statisk constructor</li> </ul> <pre><code>namespace Klasser12\n{\npublic class Vare\n{\n// Konstant\n// private static double momsPct = 0.25;\n// eller\nprivate static double momsPct = 0;\nstatic Vare() {\nmomsPct = .25;  // Kan komme fra en database\n}\n}\n}\n</code></pre> <ul> <li>Masser af medlemmer i frameworket er statiske</li> </ul> <pre><code>double res = System.Math.Cos(10.3);\nbool f = System.IO.File.Exists(\"c:\\\\temp\\\\test.txt\");\n</code></pre> <p>Info</p>"},{"location":"080_Klasser.html#opgave-80-7","title":"Opgave 80-7","text":"<p>Definition af en klasse med statiske metoder (kode til s\u00f8gning: IAH)</p> <p>Se opgave</p>"},{"location":"080_Klasser.html#attributter","title":"Attributter","text":"<p>For at give yderligere information til eksempelvis kompiler eller frameworks som benytter en klasse kan den beriges med [attributter]. Det vil tilf\u00f8jes ekstra metadata som kan afl\u00e6ses hvis det \u00f8nskes. Eksempelvis kan en klasse markeres med en SerializableAttribute for at indikere, at klassen kan benyttes i serialisering (mest brugt i \u00e6ldre kode):</p> <pre><code>[Serializable()]\npublic class Person\n{\n// ...\n}\n</code></pre> <p>Der m\u00e5 gerne tilf\u00f8jes mange attributter og man kan skabe dem selv, men lige nu skal du bare vide at det er en m\u00e5de at tilf\u00f8je ekstra information til klasser.</p>"},{"location":"080_Klasser.html#klassediagram","title":"Klassediagram","text":"<p>I Visual Studio har du mulighed for at inds\u00e6tte et klasse diagram der viser hvad en klasse best\u00e5r af og eventuelt sammenh\u00e6ng med andre klasser.</p> <p></p> <p>Du kan inds\u00e6tte et klassediagram ved at h\u00f8jreklikke p\u00e5 projektet, v\u00e6lge \u201cAdd\u201d og \u201cNew item\u2026\u201d - her skal du lede efter \u201cClass Diagram\u201d.</p> <p>Hvis du ikke kan finde klassediagrammet er det muligvis din installation mangler et kryds i en checkboks. \u00c5bn Visual Studio Installer, v\u00e6lg Modify, og under \u201cIndividual components\u201d skal du finde \u201cClass designer\u201d og s\u00e6tte kryds i checkboksen.</p>"},{"location":"080_Klasser.html#nullable-reference-types","title":"Nullable reference types","text":"<p>I C# 8 kan man anmode kompileren om at hj\u00e6lpe med at finde mulige null reference exceptions. Det kan sl\u00e5s til p\u00e5 flere m\u00e5der:</p> <pre><code>&lt;Project Sdk=\"Microsoft.NET.Sdk\"&gt;\n    &lt;PropertyGroup&gt;\n        &lt;OutputType&gt;Exe&lt;/OutputType&gt;        \n        &lt;TargetFramework&gt;net6.0&lt;/TargetFramework&gt;\n        &lt;Nullable&gt;enable&lt;/Nullable&gt;\n        &lt;WarningsAsErrors&gt;Nullable&lt;/WarningsAsErrors&gt;\n    &lt;/PropertyGroup&gt;\n&lt;/Project&gt;\n</code></pre> <p>eller direkte i kode</p> <pre><code>#nullable enable\n//\n#nullable restore\n</code></pre> <p>Nu vil eksempelvis f\u00f8lgende klasse skabe en warning omkring Navn</p> <pre><code>public class Hund\n{\n// Non-nullable property 'Navn' is uninitialized. Consider declaring the property as nullable.\npublic string Navn;\npublic int Alder;\npublic string NavnMedStort()\n{\nreturn this.Navn.ToUpper();\n}\n}\n</code></pre> <p>Warning kan fixes p\u00e5 flere m\u00e5der - initialisering med \u201c\u201d i erkl\u00e6ring eller constructor</p> <pre><code>public class Hund\n{\npublic string Navn;\npublic int Alder;\npublic Hund()\n{\nNavn = string.Empty;\n}\npublic string NavnMedStort()\n{\nreturn this.Navn.ToUpper();\n}\n}\n</code></pre> <p>Hvis du efterf\u00f8lgende fors\u00f8ger at tildele Navn v\u00e6rdien null, vil der dukke en ny warning op.</p> <pre><code>Hund d = new Hund();\n// Cannot convert null literal to non-nullable reference type.\nd.Navn = null;\n</code></pre> <p>Du kan eventuelt markere Navn som en null reference type, men nu vil der dukke en ny warning op.</p> <pre><code>public class Hund\n{\npublic string? Navn;\npublic int Alder;\npublic Hund()\n{\nNavn = string.Empty;\n}\npublic string NavnMedStort()\n{\n// Dereference of a possibly null reference\nreturn this.Navn.ToUpper();\n}\n}\n</code></pre> <p>Den m\u00e5 man s\u00e5 tage stilling og eventuelt fixe som:</p> <pre><code>public class Hund\n{\npublic string? Navn;\npublic int Alder;\npublic Hund()\n{\nNavn = string.Empty;\n}\npublic string NavnMedStort()\n{\nif (this.Navn == null)\nthrow new ApplicationException(\"Fejl i data\");\nreturn this.Navn.ToUpper();\n// eller noget ala\n// return this.Navn!.ToUpper();\n// return this.Navn == null ? \"\" : this.Navn.ToUpper();\n}\n}\n</code></pre> <p>Her er ! en ny operator der fort\u00e6ller kompileren at den skal blande sig uden om.</p>"},{"location":"080_Klasser.html#partial","title":"partial","text":"<ul> <li>Nogen gange kan det v\u00e6re en fordel af splitte en klasse over flere filer</li> <li>Brug af partial-kodeordet</li> </ul> <pre><code>namespace Klasser13\n{\npublic partial class Person\n{\npublic string navn;\n}\n// I en anden (eller samme) fil\npublic partial class Person\n{\npublic int alder;\n}\n}\n</code></pre>"},{"location":"080_Klasser.html#boxing-unboxing","title":"Boxing / Unboxing","text":"<ul> <li> <p>Boxing</p> </li> <li> <p>gem v\u00e6rdibaseret type i en reference baseret type</p> </li> <li> <p>Unboxing</p> </li> <li> <p>hent en v\u00e6rdibaseret type fra en reference baseret type</p> </li> <li> <p>kan skabe runtime fejl p\u00e5 runtime (kompiler kan ikke se fejl)</p> </li> <li>perfomance</li> <li>brug generics</li> </ul> <pre><code>int i = 10;\nConsole.WriteLine(i);\n// boxing\nobject o = i;\nConsole.WriteLine(o);\nint x = Convert.ToInt32(o);\nConsole.WriteLine(x);\n/*\n ---------- Output: ----------\n10\n10\n10\n*/\n</code></pre>"},{"location":"082_Stukturer.html","title":"Stukturer","text":""},{"location":"082_Stukturer.html#om-modulet","title":"Om modulet","text":"<p>Der er to former for skabeloner til at skabe typer i .NET. Klasser (class) er klart mest brugt, men man kan ogs\u00e5 benytte strukturer (struct). I grundl\u00e6ggende C# er egne strukturer ikke s\u00e5 meget brugt, men i mere avanceret kode kan man benytte struct\u2019s i blandt andet optimeringssammenh\u00e6ng.</p>"},{"location":"082_Stukturer.html#hvad-er-en-struct","title":"Hvad er en struct","text":"<p>En struct er ligesom en class en skabelon for en instans/objekt, men den placeres (i langt de fleste tilf\u00e6lde) et specielt sted i hukommelsen, og en instans indeholder v\u00e6rdier (og ikke referencer). Typen er is\u00e6r brugt til sm\u00e5 typer som benyttes meget, og som skal v\u00e6re nemme at kopiere og sammenligne.</p> <p>I den grundl\u00e6ggende C# kan du se helt bort fra definering af dine egne strukturer, s\u00e5 bortset fra denne sektion kan du godt hoppe videre til n\u00e6ste modul.</p>"},{"location":"082_Stukturer.html#indbyggede-strukturer","title":"Indbyggede strukturer","text":"<p>Der findes et hav af strukturer i framework som du benytter hele tiden - herunder alle de simple variabler som int, double, bool med videre. De er stukturer b\u00e5de af praktiske og performancem\u00e6ssige \u00e5rsager</p> <ul> <li>Det er nemt at kopiere v\u00e6rdier</li> <li>De \u201ckoster\u201d ikke s\u00e5 meget for runetime ved oprettelse og (is\u00e6r) oprydning</li> </ul> <pre><code>using System;\nnamespace Demo\n{\nclass Program\n{\nstatic void Main(string[] args)\n{\n// nemt og effektivt\nint i = 1;\n// giver det samme\nint j = new int();\nj = 1;\nbool k = true;\nDateTime l = DateTime.Now;\ndouble m = 0;\n// + mange andre\n}\n}\n}\n</code></pre>"},{"location":"082_Stukturer.html#definering-af-egne-strukturer","title":"Definering af egne strukturer","text":"<p>En struktur kan defineres med struct-kodeordet (ligesom class), og kan i virkeligen best\u00e5r af det samme som klasser:</p> <ul> <li>felter</li> <li>metoder</li> <li>egenskaber</li> <li>h\u00e6ndelser</li> </ul> <p>Her er et eksempel p\u00e5 brug af en simpel stuktur til opbevaring af data:</p> <pre><code>internal struct Person\n{\npublic string Navn;\npublic int Alder;\n}\n</code></pre> <p>Den store forskel p\u00e5 strukturer og klasser er, at instanser af strukturer placeres et andet sted i hukommelsen og, at strukturer er v\u00e6rdibaserede (der gemmes v\u00e6rdier i variabler) medens klasser er referencebaserede (der gemmes referencer i variabler).</p>"},{"location":"082_Stukturer.html#oprettelse-af-instanser-af-structs","title":"Oprettelse af instanser af structs","text":"<p>Man kan oprette instanser b\u00e5de med og uden new kodeordet, men bedst pratice er at benytte new. Det vil sikre, at felter bliver tildelt default v\u00e6rdier</p> <pre><code>using System;\nnamespace Demo\n{\nclass Program\n{\nstatic void Main(string[] args)\n{\nint a;\n// a++;     // Fejl - a er ikke initialiseret\na = 0;\na++;        // ok - a = 1\nint b = new int();\nb++;        // ok - b = 1\nMinStruct c;\n// c.A++;   // Fejl - c er ikke initialiseret\nMinStruct d = new MinStruct();\n// d.A = 0\n// d.B = false\n// d.C = 01-01-0001 00:00:00\n}\n}\nstruct MinStruct\n{\npublic int A;\npublic bool B;\npublic DateTime C;\n}\n}\n</code></pre> <p>Her er en kort animieret gif - en gul linje viser at der skal til at blive afviklet! Du skal v\u00e6re helt skarp p\u00e5 hvad der sker:</p> <ul> <li>En variabel p\u00e5 stack\u2019en (del af hukommelse) indeholder v\u00e6rdierne af en struct</li> <li>new-kodet er ikke n\u00f8dvendigt (men best pratice)</li> <li>N\u00e5r en variabel s\u00e6ttes = en anden variabel kopieres v\u00e6rdi (ikke reference)</li> </ul> <p></p> <p>Info</p> <p>Info</p>"},{"location":"082_Stukturer.html#opgave-82-1","title":"Opgave 82-1","text":"<p>Brug af en struct til at repr\u00e6sentere en vare i et ERP system (kode til s\u00f8gning: ICB)</p> <p>Se opgave</p>"},{"location":"082_Stukturer.html#opgave-82-2","title":"Opgave 82-2","text":"<p>Brug af en struct og en enum til at repr\u00e6sentere et spillekort (kode til s\u00f8gning: ICC)</p> <p>Se opgave</p>"},{"location":"082_Stukturer.html#forskellen-pa-en-struct-og-en-class","title":"Forskellen p\u00e5 en struct og en class","text":"<ul> <li>class er en referencebaseret type og placeret p\u00e5 heap\u2019en<ul> <li>kan have en null-v\u00e6rdi</li> <li>koster performance ved allokering og ved oprydning</li> <li>supporterer nedarvning</li> <li>kan implementere interfaces</li> </ul> </li> <li>struct er en v\u00e6rdibaseret type og (typisk) placeret p\u00e5 stack\u2019en<ul> <li>har altid en v\u00e6rdi</li> <li>supporterer ikke nedarvning</li> <li>kan dog implementere interfaces</li> <li>lidt anden implementation til brug af constructor</li> </ul> </li> </ul>"},{"location":"082_Stukturer.html#hvorfor-struct-i-stedet-for-class","title":"Hvorfor struct i stedet for class?","text":"<p>Jeg har en simpel test liggende p\u00e5 GitHub</p> <p>devcronberg/StructVsClass</p> <p>Den viser forskellen p\u00e5 brugen af en struktur sammenlignet med brugen af en klasse.</p>"},{"location":"082_Stukturer.html#constructor","title":"Constructor","text":"<p>Man kan benytte construktor som ved klasser, men man m\u00e5 ikke benytte en default constructor (uden argumenter), og alle felter skal initialiseres.</p> <pre><code>using System;\nnamespace DebugDemo\n{\nclass Program\n{\nstatic void Main(string[] args)\n{\nPerson p1 = new Person();           // default constructor kan ikke overskrives/fjernes\nPerson p2 = new Person(\"a\", 10);\n}\n}\n}\ninternal struct Person\n{\npublic string Navn;\npublic int Alder;\npublic Person(string navn, int alder)\n{\nthis.Navn = navn;\nthis.Alder = alder;\n}\n}\n</code></pre>"},{"location":"082_Stukturer.html#rekursive-strukturer","title":"Rekursive strukturer","text":"<p>P\u00e5 grund af deres placering p\u00e5 stakken m\u00e5 stukturer ikke v\u00e6re rekursive.</p> <pre><code>// ok\nclass Node {\npublic object Data { get; set; }\npublic Node Next { get; set; }\n}\n// ikke ok\nstruct Node {\npublic object Data { get; set; }\npublic Node Next { get; set; }\n}\n</code></pre> <p>Men klasser (og metoder) m\u00e5 jo naturligvis gerne.</p>"},{"location":"087_Hukommelsesteori.html","title":"Hukommelsesteori","text":""},{"location":"087_Hukommelsesteori.html#om-modulet","title":"Om modulet","text":"<p>Dette modul er m\u00e5ske et af de vigtigste modulet i hele kurset. Det er meget vigtigt at du forst\u00e5r forskellen p\u00e5 v\u00e6rdibaserede- og referencebaserede variabler, og kan tegne de klassiske og grundl\u00e6ggende stack- og heap diagrammer i hovedet n\u00e5r du koder. Derfor er dette modul lidt anderledes - der er en del sm\u00e5 videoer som forklarer teorien.</p> <p>Brug noget tid p\u00e5 dette modul - og is\u00e6r opgaven!</p>"},{"location":"087_Hukommelsesteori.html#hukommelse","title":"Hukommelse","text":"<p>I den helt grundl\u00e6ggende hukommelsesteori kan hukommelsen beskrives som:</p> <p></p>"},{"location":"087_Hukommelsesteori.html#stack-og-heap","title":"Stack og heap","text":"<p>Det klassiske stack/heap diagram kan tegnes som</p> <p></p> <p>P\u00e5 stack\u2019en er findes variabler, og disse indeholder enten r\u00e5 data (tal, bool, dato, strukturer) eller reference, og stack\u2019en er opdelt i frames. Hver stackframe d\u00e6kker en metodes virkefelt, og placeres ovenp\u00e5 hinanden som en stabel tallerkner (derfor kaldes det en stack). N\u00e5r en metode er f\u00e6rdig fjernes den med LIFO (last in first out) princippet.</p> <ul> <li> <p>stack</p> </li> <li> <p>bool</p> </li> <li>byte</li> <li>int</li> <li>long</li> <li>double</li> <li>enum</li> <li>objekter af struct</li> <li> <p>referencer til v\u00e6rdier p\u00e5 heap</p> </li> <li> <p>heap</p> </li> <li>dynamiske data</li> <li>strenge</li> <li>objekter af klasser</li> <li>arrays</li> <li>delegates</li> <li>hvis data ikke er refereret bliver de automatisk fjernet</li> </ul>"},{"location":"087_Hukommelsesteori.html#stack-frames","title":"Stack frames","text":"<p>I den helt grundl\u00e6ggende C# kan du antage, at der findes en stack frame for hver metode (se bort fra block scope), og en stor heap til dynamiske data.</p> <p>En stack frame er alts\u00e5 m\u00e5den at adskille metodebaserede virkefelter fra hinanden, og kan bedst forklares med f\u00f8lgende korte video (hvis du ser den uden lyd s\u00e5 betyder \u201cgule linjer\u201d at instruktionen skal til at blive afviklet):</p> <p>Find eventuelt den Powerpoint-pr\u00e6sentation der ligger til grund for videoen her.</p>"},{"location":"087_Hukommelsesteori.html#vrdibaserede-variabler","title":"V\u00e6rdibaserede variabler","text":"<p>N\u00e5r man arbejder med v\u00e6rdibaserede variabler er det kun stack\u2019en man p\u00e5virker, og der arbejdes med v\u00e6rdier og ikke referencer.</p> <p>Se f\u00f8lgende korte video (hvis du ser den uden lyd s\u00e5 betyder \u201cgule linjer\u201d at instruktionen skal til at blive afviklet):</p> <p>Find eventuelt den Powerpoint-pr\u00e6sentation der ligger til grund for videoen her.</p>"},{"location":"087_Hukommelsesteori.html#brug-af-struct","title":"Brug af struct","text":"<p>En struct er jo en v\u00e6rdibaseret variabel (en int, DateTime, bool mv er ogs\u00e5 structs) s\u00e5 derfor bliver vi p\u00e5 stacken n\u00e5r der kopieres variabler:</p> <p>Find eventuelt den Powerpoint-pr\u00e6sentation der ligger til grund for videoen her.</p>"},{"location":"087_Hukommelsesteori.html#referencebaserede-variabler","title":"Referencebaserede variabler","text":"<p>Helt anderledes er det n\u00e5r vi arbejder med klasser som er en referencebaseret type - der kommer heap\u2019en i spil og pludselig resulterer samme kode som vist i struct-videoen noget helt andet!</p> <p>Find eventuelt den Powerpoint-pr\u00e6sentation der ligger til grund for videoen her.</p> <p>Info</p> <p>Info</p>"},{"location":"087_Hukommelsesteori.html#opgave-87-1","title":"Opgave 87-1","text":"<p>Den helt grundl\u00e6ggende opgave i hukommelsesteori - den SKAL du forst\u00e5 ;) (kode til s\u00f8gning: IHB)</p> <p>Se opgave</p>"},{"location":"087_Hukommelsesteori.html#opgave-87-2","title":"Opgave 87-2","text":"<p>Med udgangspunkt i en terning og et b\u00e6ger skal du visualisere stack/heap (kode til s\u00f8gning: IHC)</p> <p>Se opgave</p>"},{"location":"087_Hukommelsesteori.html#argumenter-til-metoder","title":"Argumenter til metoder","text":"<ul> <li>Pas p\u00e5 med argumenter til metoder. Hvis der er tale om reference variabler kan v\u00e6rdien rettes i metoden.</li> </ul> <p>Find eventuelt den Powerpoint-pr\u00e6sentation der ligger til grund for videoen her.</p>"},{"location":"087_Hukommelsesteori.html#arrays-og-andre-samlinger","title":"Arrays og andre samlinger","text":"<p>Husk at array er en reference baseret type, og det kan jo have en del konsekvenser hvis man eksempelvis sender arrays videre som argument til en metode.</p> <p>Find eventuelt den Powerpoint-pr\u00e6sentation der ligger til grund for videoen her.</p> <p>Bem\u00e6rk, at st\u00f8rrelsen p\u00e5 array er underordnet. En referencevariabel vil blot pege p\u00e5 starten af et array p\u00e5 heap\u2019en.</p> <pre><code>int[] a = { 5, 1, 7 };\nConsole.WriteLine($\"a = {string.Join(' ', a)}\");\nint[] b = { 7, 5, 1, 8, 10 };\nConsole.WriteLine($\"b = {string.Join(' ', b)}\");\na = b;  // peger p\u00e5 det samme (gamle a array forsvinder)\nConsole.WriteLine($\"a = {string.Join(' ', a)}\");\nConsole.WriteLine($\"b = {string.Join(' ', b)}\");\na[0] = 99;\nConsole.WriteLine($\"a = {string.Join(' ', a)}\");\nConsole.WriteLine($\"b = {string.Join(' ', b)}\");\nb[1] = 999;\nConsole.WriteLine($\"a = {string.Join(' ', a)}\");\nConsole.WriteLine($\"b = {string.Join(' ', b)}\");\n/*\n ---------- Output: ----------\na = 5 1 7\nb = 7 5 1 8 10\na = 7 5 1 8 10\nb = 7 5 1 8 10\na = 99 5 1 8 10\nb = 99 5 1 8 10\na = 99 999 1 8 10\nb = 99 999 1 8 10\n*/\n</code></pre>"},{"location":"087_Hukommelsesteori.html#strenge-er-immutable","title":"Strenge er immutable","text":"<p>Husk at strenge (jf. tidligere modul) er immutable (kan ikke rettes).</p> <p>Find eventuelt den Powerpoint-pr\u00e6sentation der ligger til grund for videoen her.</p>"},{"location":"089_OOP.html","title":"OOP","text":""},{"location":"089_OOP.html#om-modulet","title":"Om modulet","text":"<p>Dette modul vil introducere dig til de tre prim\u00e6re principper i objektorienteret programmering.</p>"},{"location":"089_OOP.html#de-tre-principper-i-oop","title":"De tre principper i OOP","text":"<p>I grundl\u00e6ggende objektorienteret programmering arbejder man typisk med tre hovedprincipper:</p> <p></p>"},{"location":"089_OOP.html#indkapsling","title":"Indkapsling","text":""},{"location":"089_OOP.html#nedarvning","title":"Nedarvning","text":""},{"location":"089_OOP.html#polymorfi","title":"Polymorfi","text":""},{"location":"090_Indkapsling.html","title":"Indkapsling","text":""},{"location":"090_Indkapsling.html#om-modulet","title":"Om modulet","text":"<p>I dette modul vil du l\u00e6re om indkapsling og beskyttelse af data. Vi skal b\u00e5de se p\u00e5 brugen af de klassiske get/set metoder, samt brugen af egenskaber som i realiteten blot er autogenerering af metoder. Sidstn\u00e6vnte er dog m\u00e5den at indkapsle data p\u00e5 i C#, og du vil forst\u00e5 hvorfor det er at foretr\u00e6kke.</p>"},{"location":"090_Indkapsling.html#grundlggende-om-indkapsling","title":"Grundl\u00e6ggende om indkapsling","text":"<p>Brug af synlighed (private/public) til at indkapsle data og skabe adgang ved hj\u00e6lp metoder eller egenskaber.</p> <p></p> <p>Grundl\u00e6ggende kan der i C# v\u00e6lges mellem to m\u00e5de at indkapsle data p\u00e5</p> <ul> <li>metoder</li> <li>egenskaber</li> <li>som egentlig bare er autogereret kode der benytter metoder</li> </ul> <p></p>"},{"location":"090_Indkapsling.html#indkapsling-med-metoder","title":"Indkapsling med metoder","text":"<ul> <li> <p>Brug af get/set metoder</p> </li> <li> <p>java + andre sprog benytter denne tilgang</p> </li> </ul> <pre><code>public class Person {\nprivate string navn;\nprivate int alder;\n// get\npublic string GetNavn () {\n// m\u00e5ske kode som h\u00e5ndterer:\n// log\n// sikkerhed\nreturn this.navn;\n}\n// set\npublic void SetNavn (string value) {\n// m\u00e5ske kode som h\u00e5ndterer:\n// log\n// validering\n// sikkerhed\nthis.navn = value;\n}\n// get\npublic int GetAlder () {\n// m\u00e5ske kode som h\u00e5ndterer:\n// log\n// sikkerhed\nreturn this.alder;\n}\n// set\npublic void SetAlder (int value) {\n// m\u00e5ske kode som h\u00e5ndterer:\n// log\n// validering\n// sikkerhed\nthis.alder = value;\n}\n}\n</code></pre> <ul> <li>kan bruges som</li> </ul> <pre><code>Person p = new Person();\np.SetNavn(\"Mathias\");\np.SetAlder(12);\nConsole.WriteLine($\"{p.GetNavn()} er {p.GetAlder()} \u00e5r gammel\");\n/*\n---------- Output: ----------\nMathias er 12 \u00e5r gammel\n*/\n</code></pre> <p>Man kan skabe readonly/writeonly tilgang ved at droppe den ene af metoderne</p> <ul> <li>Man kan ogs\u00e5 benytte en privat metode s\u00e5 tilgang internt aldrig sker direkte til feltet</li> </ul>"},{"location":"090_Indkapsling.html#indkapsling-med-egenskaber","title":"Indkapsling med egenskaber","text":"<ul> <li> <p>Brug af egenskaber i stedet for manuelle get/set metoder er bedre fordi</p> </li> <li> <p>Syntaks er langt bedre</p> </li> <li>Klar typem\u00e6ssig adskillelse mellem medlemmer som \u201cudelukkende\u201d arbejder p\u00e5 data og som medlemmer som er metoder<ul> <li>Eksempelvis kan brugerflader som WPF/WinForm bruge det til databinding fordi man gennem kode kan se om der er tale om et medlem som har med objektets data at g\u00f8re</li> </ul> </li> <li>get/set metoder autogenereres</li> </ul> <pre><code>using System;\nnamespace Klasser9\n{\npublic class Person\n{\nprivate string navn;\npublic string Navn\n{\nget\n{\n// m\u00e5ske kode som h\u00e5ndterer:\n// log\n// sikkerhed\nreturn navn;\n}\nset\n{\n// m\u00e5ske kode som h\u00e5ndterer:\n// log\n// validering\n// sikkerhed\nnavn = value;\n}\n}\nprivate int alder;\npublic int Alder\n{\nget\n{\n// m\u00e5ske kode som h\u00e5ndterer:\n// log\n// sikkerhed\nreturn alder;\n}\nset\n{\n// m\u00e5ske kode som h\u00e5ndterer:\n// log\n// validering\n// sikkerhed\n// hvad med\nif (value &lt; 0 || value &gt; 100)\nthrow new ApplicationException(\"Forkert alder\");\nelse // else er egentlig ikke n\u00f8dvendig!\nalder = value;\n}\n}\n}\n}\n</code></pre> <ul> <li>Brug af egenskaber</li> </ul> <pre><code>Klasser9.Person p = new Klasser9.Person();\np.Navn = \"Mathias\";\np.Alder = 12;\nConsole.WriteLine($\"{p.Navn} er {p.Alder} \u00e5r gammel\");\n/*\n ---------- Output: ----------\nMathias er 12 \u00e5r gammel\n*/\n</code></pre> <ul> <li>man m\u00e5 gerne n\u00f8jes med get eller set</li> <li>readonly</li> <li>writeonly</li> </ul> <pre><code>using System;\nnamespace Klasser10\n{\npublic class Person\n{\nprivate string navn = \"\";\n// Read only (ingen set)\npublic string Navn\n{\nget\n{\n// m\u00e5ske kode som h\u00e5ndterer:\n// log\n// sikkerhed\nreturn navn;\n}\n}\nprivate int alder = 0;\npublic int Alder\n{\nget\n{\n// m\u00e5ske kode som h\u00e5ndterer:\n// log\n// sikkerhed\nreturn alder;\n}\nset\n{\n// m\u00e5ske kode som h\u00e5ndterer:\n// log\n// validering\n// sikkerhed\n// hvad med\nif (value &lt; 0 || value &gt; 100)\nthrow new ApplicationException(\"Forkert alder\");\nelse // else er egentlig ikke n\u00f8dvendig!\nalder = value;\n}\n}\npublic Person(string navn, int alder)\n{\nthis.alder = alder;\nthis.navn = navn;\n}\n}\n}\n</code></pre> <p>Brug evt snippet \u201cpropfull\u201d</p> <p>Find eventuelt den Powerpoint-pr\u00e6sentation der ligger til grund for videoen her.</p> <p>Info</p> <p>Info</p> <p>Info</p>"},{"location":"090_Indkapsling.html#opgave-90-1","title":"Opgave 90-1","text":"<p>En mere komplet terning der benytter egenskaber (kode til s\u00f8gning: JAB)</p> <p>Se opgave</p>"},{"location":"090_Indkapsling.html#opgave-90-2","title":"Opgave 90-2","text":"<p>Simpel opgave i brugen af komplete egenskaber (kode til s\u00f8gning: JAC)</p> <p>Se opgave</p>"},{"location":"090_Indkapsling.html#opgave-90-3","title":"Opgave 90-3","text":"<p>Simpel klasse med en simpel egenskab men med en heftig fejl - find den!! (kode til s\u00f8gning: JAD)</p> <p>Se opgave</p>"},{"location":"090_Indkapsling.html#init","title":"init","text":"<p>I C# 9 blev det muligt at skabe read-only lignende egenskaber med init-kodeordet:</p> <pre><code>public class Person\n{\nprivate string? navn;\npublic string? Navn\n{\nget { return navn; }\ninit { navn = value; }\n}\nprivate int alder;\npublic int Alder\n{\nget { return alder; }\ninit { alder = value; }\n}\n}\n</code></pre> <p>Nu kan egenskaberne udelukkende tildeles en v\u00e6rdi ved initialisering:</p> <pre><code>Person person = new Person() { Navn = \"a\", Alder = 10 };\n// person.Navn = \"b\";  // fejl\n</code></pre>"},{"location":"090_Indkapsling.html#automatiske-egenskaber","title":"Automatiske egenskaber","text":"<ul> <li>Hvis man blot vil sende v\u00e6rdier videre til felter kan man benytte automatiske egenskaber</li> <li>Man kan evt senere \u00e6ndre det til en fuld egenskab med kode til sikkerhed, log mv</li> </ul> <pre><code>using System;\nnamespace Klasser11\n{\npublic class Person\n{\n// fuld egenskab\nprivate string navn;\npublic string Navn\n{\nget { return navn; }\nset { navn = value; }\n}\n// forskellige automatiske egenskaber\npublic int Alder { get; set; }\npublic string Land { get; set; } = \"\";\npublic double L\u00f8n  { get; }\npublic bool HeltSpecielPerson { get; private set; } // kan kun tildeles internt\npublic string Adresse { get; init } // kan kun tildeles ved initialisering\n}\n}\n```\n- brug snippet \"prop\"\n&lt;!-- &gt; opgave:{navn:\"Brug af automatiske egenskaber\",url:\"https://github.com/devcronberg/undervisning-cs-opgaver/blob/master/indkapsling-automatisk-egenskab/Opgave/index.md\", beskrivelse: \"Kom godt i gang med automatiserede egenskaber\"} --&gt;\n!!! Info\n## Opgave 90-4\nKom godt i gang med automatiserede egenskaber (kode til s\u00f8gning: JAE)\n[Se opgave](https://github.com/devcronberg/undervisning-cs-opgaver/blob/master/indkapsling-automatisk-egenskab/Opgave/index.md){ .md-button .md-button--primary target=_blank}\n&lt;!-- &gt; opgave:{navn:\"En Terning med automatiske egenskaber\",url:\"https://github.com/devcronberg/undervisning-cs-opgaver/blob/master/indkapsling-terning-full/opgave\", beskrivelse: \"Benyt automatiske (get only) egenskaber til en Terning\"} --&gt;\n!!! Info\n## Opgave 90-5\nBenyt automatiske (get only) egenskaber til en Terning (kode til s\u00f8gning: JAF)\n[Se opgave](https://github.com/devcronberg/undervisning-cs-opgaver/blob/master/indkapsling-terning-full/opgave){ .md-button .md-button--primary target=_blank}\n&lt;!-- &gt; opgave:{navn:\"Get-egenskab eller en metode?\",url:\"https://github.com/devcronberg/undervisning-cs-opgaver/blob/master/indkapsling-getter-som-metode/Opgave/index.md\", beskrivelse: \"Opgave i brug af en Get-egenskab som alternativ til en metode\"} --&gt;\n!!! Info\n## Opgave 90-6\nOpgave i brug af en Get-egenskab som alternativ til en metode (kode til s\u00f8gning: JAG)\n[Se opgave](https://github.com/devcronberg/undervisning-cs-opgaver/blob/master/indkapsling-getter-som-metode/Opgave/index.md){ .md-button .md-button--primary target=_blank}\n&lt;!-- &gt; opgave:{navn:\"Immutable klasse\",url:\"https://github.com/devcronberg/undervisning-cs-opgaver/tree/master/indkapsling-immutable-klasse/Opgave\", beskrivelse: \"Opgave i brug immutable datatyper (samt c# 9 records)\"} --&gt;\n!!! Info\n## Opgave 90-7\nOpgave i brug immutable datatyper (samt c# 9 records) (kode til s\u00f8gning: JAH)\n[Se opgave](https://github.com/devcronberg/undervisning-cs-opgaver/tree/master/indkapsling-immutable-klasse/Opgave){ .md-button .md-button--primary target=_blank}\n&lt;!-- &gt; opgave:{navn:\"Serialisering/Deserialiering\",url:\"https://github.com/devcronberg/undervisning-cs-opgaver/tree/master/indkapsling-deserialisering/Opgave/index.md\", beskrivelse: \"Opgave der leger lidt med serialisering\"} --&gt;\n!!! Info\n## Opgave 90-8\nOpgave der leger lidt med serialisering (kode til s\u00f8gning: JAI)\n[Se opgave](https://github.com/devcronberg/undervisning-cs-opgaver/tree/master/indkapsling-deserialisering/Opgave/index.md){ .md-button .md-button--primary target=_blank}\n## Autogenerering af kode\nBrug eventuelt NuGet-pakken MCronberg.CSCourseHelper.Standard (s\u00f8g efter \"cronberg\"). Den indeholder blandt andet en Extension-metode til Object kaldet ToStringEx, som giver flere informationer om et objekt. S\u00e5 kan man eksempelvis nemt se, at en fuld egenskab og automatisk egenskab resulterer i autogenerede felter og metoder:\n```csharp\nusing System;\nusing MCronberg;\nnamespace demo\n{\nclass Program\n{\nstatic void Main(string[] args)\n{\nDyr d = new Dyr();\nConsole.WriteLine(d.ToStringEx());\n}\n}\nclass Dyr\n{\n// Automatisk egenskab\npublic int Id { get; set; }\n// Fuld egenskab\nprivate string navn;\npublic string Navn\n{\nget { return navn; }\nset { navn = value; }\n}\n}\n}\n</code></pre> <p>Resultat:</p> <pre><code>Showing members (fields, properties, methods) from object of type demo.Dyr:\n---------------------------------------------------------------------------\nFields:\n\nPrivate    System.Int32              &lt;Id&gt;k__BackingField            0\nPrivate    System.String             navn                           null\n\nProperties:\n\nget/set    System.Int32              Id                             0\nget/set    System.String             Navn                           null\n\nMethods:\n\nPublic     System.Int32              get_Id\nPublic     System.String             get_Navn\nPublic     System.Void               set_Id\nPublic     System.Void               set_Navn\n\nMore info:\n\nPrimitive                            False\nValueType                            False\nReferenceType                        True\nArray                                False\nAbstract                             False\nEnum                                 False\nInterface                            False\nSealed                               False\n</code></pre> <p>Bem\u00e6rk:</p> <ul> <li>der auto genereres et felt kaldet k__BackingField (auto egenskab) <li>get/set metoder til begge felter</li>"},{"location":"100_Arv.html","title":"Nedarvning","text":""},{"location":"100_Arv.html#om-modulet","title":"Om modulet","text":"<p>Nedarvning er grundleddet i objektorientering programmering! Det giver en meget effektiv mulighed for genbrug af kode, samt mulighed at arbejde objekter i samme arvehierarki p\u00e5 en helt speciel m\u00e5de. Sidstn\u00e6vnte kaldes polymofi, og det venter vi med at se p\u00e5 til n\u00e6ste modul. I dette fokuserer vi p\u00e5 nedarvning - som i sig selv faktisk er ret simpelt at forst\u00e5.</p>"},{"location":"100_Arv.html#overordnet-om-arv","title":"Overordnet om arv","text":"<p>Nedarvning er et af principperne i objektorienteret programmering</p> <p></p> <p>I sin helt grundl\u00e6ggende form kan nedarvning bruges til at opbygge et hierarki hvor medlemmer (felter, metoder, egenskaber, h\u00e6ndelser) i klasser kan genbruges automatisk og uden kode i andre klasser som arver fra en anden klasse.</p> <ul> <li>\u201cEr en\u201d relation</li> <li>Generalisering -&gt; Specialisering</li> <li>Kan alt hvad mor kan + (evt) yderligere medlemmer</li> <li>Single/Multible nedarvning</li> <li>Kun en mor i C#</li> </ul>"},{"location":"100_Arv.html#eksempel-mor-og-barn","title":"Eksempel: Mor og barn","text":""},{"location":"100_Arv.html#eksempel-dyr","title":"Eksempel: Dyr","text":""},{"location":"100_Arv.html#eksempel-medarbejdere","title":"Eksempel: Medarbejdere","text":""},{"location":"100_Arv.html#syntaks-for-nedarvning","title":"Syntaks for nedarvning","text":"<p>Man benytter kolon (:) til nedarvning</p> <pre><code>// Mor-Barn\nclass Mor { }\nclass Barn : Mor { }\n// Dyr\nclass Dyr { }\nclass Hvirveldyr : Dyr { }\nclass Hvirvell\u00f8se : Dyr { }\nclass Fisk : Hvirveldyr { }\nclass Torsk : Fisk { }\nclass Pattedyr : Hvirveldyr { }\nclass Elefant : Pattedyr { }\nclass Bl\u00f8ddyr : Hvirvell\u00f8se { }\nclass Musling : Bl\u00f8ddyr { }\n// Personer\nclass Person { }\nclass Medarbejder : Person { }\nclass Kursist : Person { }\nclass Instrukt\u00f8r : Medarbejder { }\nclass Fremm\u00f8deKursist : Kursist { }\nclass OnlineKursist : Kursist { }\nclass Hj\u00e6lpeInstrukt\u00f8r : Instrukt\u00f8r { }\n</code></pre>"},{"location":"100_Arv.html#tilgang-til-medlemmer","title":"Tilgang til medlemmer","text":"<p>Der er fortsat de to klassiske virkefelter</p> <ul> <li>public (alle udefra og i hierarki kan tilg\u00e5 medlem)</li> <li>private (kun klassen selv kan tilg\u00e5 medlem)</li> </ul> <p>men der tilf\u00f8jes en ny</p> <ul> <li>protected (alle klasser i hierarki kan tilg\u00e5 medlem - men ikke udefra)</li> </ul> <pre><code>using System;\nnamespace Arv1\n{\npublic class Mor\n{\npublic int A { get; set; }\nprotected int B { get; set; }\nprivate int C { get; set; }\npublic void Test1()\n{\n// Alle egenskaber kan ses\nConsole.WriteLine(\"I Test1\");\n}\nprotected void Test2()\n{\n// Alle egenskaber kan ses\nConsole.WriteLine(\"I Test2\");\n}\nprivate void Test3()\n{\n// Alle egenskaber kan ses\nConsole.WriteLine(\"I Test3\");\n}\n}\npublic class Barn : Mor\n{\npublic int D { get; set; }\npublic void Test4()\n{\n// A, B og D kan ses\n// Test1, Test2 kan ses            \nConsole.WriteLine(\"I Test4\");\n}\n}\n}\n</code></pre> <p>Pr\u00f8v denne kode:</p> <pre><code>Arv1.Mor a = new Arv1.Mor();\na.A = 1;            // a.B kan ikke ses\n// a.C kan ikke ses\na.Test1();\n// a.Test2(); kan ikke ses\n// a.Test3(); kan ikke ses\nArv1.Barn b = new Arv1.Barn();\nb.A = 1;\n// a.B kan ikke ses\n// a.C kan ikke ses\nb.D = 1;\nb.Test1();\n// a.Test2(); kan ikke ses\n// a.Test3(); kan ikke ses\nb.Test4();\n/*\n ---------- Output: ----------\nI Test1\nI Test1\nI Test4\n*/\n</code></pre>"},{"location":"100_Arv.html#default-constructor","title":"Default constructor","text":"<ul> <li>Alle default constructors bliver afviklet</li> <li>F\u00f8rst mor s\u00e5 barn</li> </ul> <pre><code>using System;\nusing System.Collections.Generic;\nusing System.Text;\nnamespace Arv2\n{\nclass A\n{\npublic A()\n{\nConsole.WriteLine(\"I A\");\n}\n}\nclass B : A {\npublic B()\n{\nConsole.WriteLine(\"I B\");\n}\n}\n}\n</code></pre> <pre><code>Arv2.B b = new Arv2.B();\n/*\n ---------- Output: ----------\nI A\nI B\n*/\n</code></pre>"},{"location":"100_Arv.html#custom-constructor","title":"Custom constructor","text":"<p>Custom constructors nedarves ikke</p> <ul> <li>Dem skal man selv tilf\u00f8je (hvis de \u00f8nskes - hvilket jo netop er \u00e5rsagen til at de ikke nedarves)</li> </ul> <pre><code>using System;\nusing System.Collections.Generic;\nusing System.Text;\nnamespace Arv2a\n{\nclass A\n{\npublic A()\n{\nConsole.WriteLine(\"I A\");\n}\npublic A(int x) {\nConsole.WriteLine(\"I A(x)\");\n}\n}\nclass B : A {\npublic B()\n{\nConsole.WriteLine(\"I B\");\n}\n}\n}\n</code></pre> <pre><code>Arv2a.B b = new Arv2a.B();\n// Custom arves ikke\n// Arv2a.B b = new Arv2a.B(3);\n/*\n ---------- Output: ----------\nI A\nI B\n*/\n</code></pre> <p>Hvis man tilf\u00f8jer en custom constructor til en nedarvet klasse kaldes f\u00f8rst default constructor frs \u201cmor\u201d og herefter custom constructor\u2019en.</p> <p>Info</p> <p>Info</p> <p>Info</p>"},{"location":"100_Arv.html#opgave-100-1","title":"Opgave 100-1","text":"<p>Simpel opgave i brugen af arv (persontyper) (kode til s\u00f8gning: BAAB)</p> <p>Se opgave</p>"},{"location":"100_Arv.html#opgave-100-2","title":"Opgave 100-2","text":"<p>Opgave der viser at man ogs\u00e5 kan arve fra framework-klasser (kode til s\u00f8gning: BAAC)</p> <p>Se opgave</p>"},{"location":"100_Arv.html#opgave-100-3","title":"Opgave 100-3","text":"<p>Udvikling af egne exception-klasser ved hj\u00e6lp af arv (kode til s\u00f8gning: BAAD)</p> <p>Se opgave</p>"},{"location":"100_Arv.html#base","title":"base","text":"<ul> <li>Brug base til f\u00e5 fat i \u00f8vre constructors</li> <li>Lidt som this - bare for arv</li> <li>Husk: custom constructor arves ikke</li> </ul> <pre><code>using System;\nusing System.Collections.Generic;\nusing System.Text;\nnamespace Arv3\n{\npublic class A\n{\npublic A()\n{\nConsole.WriteLine(\"Default i A\");\n}\npublic A(int a)\n{\nConsole.WriteLine(\"Custom i A\");\n}\npublic A(int a, int b)\n{\nConsole.WriteLine(\"Custom speciel i A\");\n}\n}\npublic class B : A\n{\npublic B()\n{\nConsole.WriteLine(\"Default i B\");\n}\npublic B(int v) : base(v)\n{\nConsole.WriteLine(\"Custom i B\");\n}\n}\npublic class C : B\n{\npublic C()\n{\nConsole.WriteLine(\"Default i C\");\n}\npublic C(int c) : base(c)\n{\nConsole.WriteLine(\"Custom i C\");\n}\n}\n}\n</code></pre> <pre><code>Arv3.C c = new Arv3.C(1);\n/*\n ---------- Output: ----------\nCustom i A\nCustom i B\nCustom i C\n*/\n</code></pre>"},{"location":"100_Arv.html#sealed","title":"sealed","text":"<p>Nogle gange giver det mening at l\u00e5se en klasse for yderligere nedarvning - s\u00e5 kan man benytte sealed-kodeordet. S\u00e5 vil kompileren smide en fejl hvis man fors\u00f8ge at arve fra klassen.</p> <pre><code>namespace Arv4\n{\nclass A\n{\n}\nclass B : A\n{\n}\nsealed class C : B\n{\n}\n//class D : C   Fejl!!\n//{\n//}\n}\n</code></pre> <p>Info</p>"},{"location":"100_Arv.html#opgave-100-4","title":"Opgave 100-4","text":"<p>Skab en terning (mor) og en ludoterning (barn) som man ikke kan arve yderligere fra (kode til s\u00f8gning: BAAE)</p> <p>Se opgave</p>"},{"location":"105_Polymofi.html","title":"Polymorfi","text":""},{"location":"105_Polymofi.html#om-modulet","title":"Om modulet","text":"<p>Polymorfi er m\u00e5ske en af de sv\u00e6reste ting at forst\u00e5 inden for objektorienteret kode - men s\u00e5 sv\u00e6rt er det alts\u00e5 heller ikke. Som altid er det nemmest at forst\u00e5 teori hvis du samtidig skriver noget kode, og det g\u00e6lder i den grad ogs\u00e5 her. Kopi\u2019er eksempler over i VS og pr\u00f8v tingene af. Der er ogs\u00e5 nogle opgaver du kan kaste dig over.</p>"},{"location":"105_Polymofi.html#grundlggende-om-polymorfi","title":"Grundl\u00e6ggende om polymorfi","text":"<p>Helt grundl\u00e6ggende fungerer de to former for polymorfi ved at runtime ved, at et medlem med 100% sikkerhed findes i et objekt (enten grundet arv eller implementering af interface). Det kan udnyttes til at lade runtime finde og afvikle den korrekte metode.</p>"},{"location":"105_Polymofi.html#eksempel-brugt-i-dette-modul","title":"Eksempel brugt i dette modul","text":"<p>For at g\u00f8re teorien s\u00e5 nem at forst\u00e5 som overhovedet mulig benyttes dette eksempel (i forskellige former) i hele modulet.</p> <p></p>"},{"location":"105_Polymofi.html#virtuelle-metoder","title":"Virtuelle metoder","text":"<p>Hvis en metode erkl\u00e6res som virtuel kan b\u00f8rn \u201coverskrive\u201d og tilf\u00f8je egen implementation</p> <p>Se denne definitation</p> <pre><code>internal class K\u00e6ledyr {\npublic string Navn { get; set; }\npublic string Kendelyd() {\nreturn \"?\";\n}\n}\ninternal class Fugl : K\u00e6ledyr {\npublic bool H\u00e5ndTam { get; set; }\n}\ninternal class Hund : K\u00e6ledyr {\npublic string HundeRegisterId { get; set; }\n}\n</code></pre> <p>Der kan skabes en instans af alle tre klasse og KendeLyd() kan kaldes:</p> <pre><code>K\u00e6ledyr k = new K\u00e6ledyr() { Navn = \"a\" };\nFugl f = new Fugl() { Navn = \"Hans\", H\u00e5ndTam = true };\nHund h = new Hund() { Navn = \"Mille\", HundeRegisterId = \"1\" };\nConsole.WriteLine(k.Kendelyd());    // ?\nConsole.WriteLine(f.Kendelyd());    // ?\nConsole.WriteLine(h.Kendelyd());    // ?\n</code></pre> <p>Det var bedre hvis b\u00e5de Fugl og Hund havde deres egen implementation af KendeLyd():</p> <pre><code>internal class K\u00e6ledyr\n{\npublic string Navn { get; set; }\npublic virtual string Kendelyd()    // bem\u00e6rk - virtual\n{\nreturn \"?\";\n}\n}\ninternal class Fugl : K\u00e6ledyr\n{\npublic bool H\u00e5ndTam { get; set; }\npublic override string Kendelyd()   // bem\u00e6rk override\n{\nreturn \"Pip\";\n}\n}\ninternal class Hund : K\u00e6ledyr\n{\npublic string HundeRegisterId { get; set; }\npublic override string Kendelyd()   // bem\u00e6rk override\n{\nreturn \"Vov\";\n}\n}\n</code></pre> <p>Nu giver samme kode fra f\u00f8r et noget anderledes resultat:</p> <pre><code>K\u00e6ledyr k = new K\u00e6ledyr() { Navn = \"a\" };\nFugl f = new Fugl() { Navn = \"Hand\", H\u00e5ndTam = true };\nHund h = new Hund() { Navn = \"Mille\", HundeRegisterId = \"1\" };\nConsole.WriteLine(k.Kendelyd());    // ?\nConsole.WriteLine(f.Kendelyd());    // Pip\nConsole.WriteLine(h.Kendelyd());    // Vov\n</code></pre> <p>Bem\u00e6rk:</p> <ul> <li>KendeLyd() i Dyr er markeret med virtual</li> <li>KendeLyd() i underklasser er markeret med override</li> </ul> <p>Runtime finder selv den korrekte metode at afvikle.</p>"},{"location":"105_Polymofi.html#override-af-tostring","title":"Override af ToString()","text":"<p>Alle typer arver fra System.Object, og her er flere virtuelle metoder - blandt andet ToString() som tit overskrives. Se f\u00f8lgende:</p> <pre><code>K\u00e6ledyr k = new K\u00e6ledyr() { Navn = \"a\" };\nFugl f = new Fugl() { Navn = \"Hans\", H\u00e5ndTam = true };\nHund h = new Hund() { Navn = \"Mille\", HundeRegisterId = \"1\" };\nConsole.WriteLine(k.ToString());    // K\u00e6leDyr\nConsole.WriteLine(f.ToString());    // Fugl\nConsole.WriteLine(h.ToString());    // Hund\n</code></pre> <p>Det eneste runtime kan returnere ved kald til ToString() er navnet p\u00e5 typen. Men da ToString er virtual kan den overskrives og returnere noget mere sigende:</p> <pre><code>internal class K\u00e6ledyr\n{\npublic string Navn { get; set; }\npublic virtual string Kendelyd()\n{\nreturn \"?\";\n}\n}\ninternal class Fugl : K\u00e6ledyr\n{\npublic bool H\u00e5ndTam { get; set; }\npublic override string Kendelyd()\n{\nreturn \"Pip\";\n}\npublic override string ToString()\n{\nreturn $\"Jeg er en fugl der hedder {this.Navn} og siger { this.Kendelyd() }.\";\n}\n}\ninternal class Hund : K\u00e6ledyr\n{\npublic string HundeRegisterId { get; set; }\npublic override string Kendelyd()\n{\nreturn \"Vov\";\n}\npublic override string ToString()\n{\nreturn $\"Jeg er en hund der hedder {this.Navn} og siger { this.Kendelyd() }.\";\n}\n}\n</code></pre> <pre><code>K\u00e6ledyr k = new K\u00e6ledyr() { Navn = \"x\" };\nFugl f = new Fugl() { Navn = \"Hans\", H\u00e5ndTam = true };\nHund h = new Hund() { Navn = \"Mille\", HundeRegisterId = \"1\" };\nConsole.WriteLine(k.ToString());    // K\u00e6leDyr\nConsole.WriteLine(f.ToString());    // Jeg er en fugl der hedder Hans og siger Pip\nConsole.WriteLine(h.ToString());    // Jeg er en hund der hedder Mille og siger Vov\n</code></pre> <p>Info</p> <p>Info</p>"},{"location":"105_Polymofi.html#opgave-105-1","title":"Opgave 105-1","text":"<p>Overskrivning af ToString (kode til s\u00f8gning: BAFB)</p> <p>Se opgave</p>"},{"location":"105_Polymofi.html#opgave-105-2","title":"Opgave 105-2","text":"<p>Brug af polymorfi med terninger og ludoterninger (kode til s\u00f8gning: BAFC)</p> <p>Se opgave</p>"},{"location":"105_Polymofi.html#abstrakte-klasser","title":"Abstrakte klasser","text":"<p>Nogle gange giver det mening at sikre, at man ikke skabe en instans af en klasse - eksempelvis klassen K\u00e6ledyr. Ved at g\u00f8re klasse abstrakt kan man ikke skabe en instans men udelukkende arve fra den:</p> <pre><code>internal abstract class K\u00e6ledyr\n{\npublic string Navn { get; set; }\npublic virtual string Kendelyd()\n{\nreturn \"?\";\n}\n}\ninternal class Fugl : K\u00e6ledyr\n{\npublic bool H\u00e5ndTam { get; set; }\npublic override string Kendelyd()\n{\nreturn \"Pip\";\n}\npublic override string ToString()\n{\nreturn $\"Jeg er en fugl der hedder {Navn} og siger {Kendelyd()}\";\n}\n}\ninternal class Hund : K\u00e6ledyr\n{\npublic string HundeRegisterId { get; set; }\npublic override string Kendelyd()\n{\nreturn \"Vov\";\n}\npublic override string ToString()\n{\nreturn $\"Jeg er en hund der hedder {Navn} og siger {Kendelyd()}\";\n}\n}\n</code></pre> <p>Nu vil compileren smide en fejl hvis man fors\u00f8ger at skabe en instans af K\u00e6ledyr:</p> <pre><code>K\u00e6ledyr k = new K\u00e6ledyr() { Navn = \"x\" }; // Fejl - abstrakt klasse!!\n</code></pre>"},{"location":"105_Polymofi.html#abstrakte-metoder","title":"Abstrakte metoder","text":"<p>Ved at g\u00f8re klassen abstrakt kan man ogs\u00e5 skabe abstrakte metoder. Det g\u00f8r det muligt (som virtual) at overskrive en metode, men fordi klassen er abstrakt (og man dermed ikke kan skabe en instans), er der ingen grund til implementering i den abstrakte klasse. Til geng\u00e6ld skal metodens signatur beskrives:</p> <pre><code>internal abstract class K\u00e6ledyr\n{\npublic string Navn { get; set; }\npublic abstract string Kendelyd();  // bem\u00e6rk - ingen implementering\n}\ninternal class Fugl : K\u00e6ledyr\n{\npublic bool H\u00e5ndTam { get; set; }\npublic override string Kendelyd()\n{\nreturn \"Pip\";\n}\npublic override string ToString()\n{\nreturn $\"Jeg er en fugl der hedder {Navn} og siger {Kendelyd()}\";\n}\n}\ninternal class Hund : K\u00e6ledyr\n{\npublic string HundeRegisterId { get; set; }\npublic override string Kendelyd()\n{\nreturn \"Vov\";\n}\npublic override string ToString()\n{\nreturn $\"Jeg er en hund der hedder {Navn} og siger {Kendelyd()}\";\n}\n}\n</code></pre> <p>P\u00e5 den m\u00e5de slipper vi ogs\u00e5 af med den t\u00e5belige KendeLyd() i K\u00e6ledyr som jo blot returnerede \u201c?\u201d - det gav jo ikke rigtig nogen mening.</p> <p>Info</p>"},{"location":"105_Polymofi.html#opgave-105-3","title":"Opgave 105-3","text":"<p>Udvikling og brug af en abstrakt Person-klasse (kode til s\u00f8gning: BAFD)</p> <p>Se opgave</p>"},{"location":"105_Polymofi.html#referencer","title":"Referencer","text":"<p>Der kan altid skabes en reference til et barn gennem mors type (ogs\u00e5 - eller m\u00e5ske is\u00e6r - hvis den er abstrakt).</p> <p>Med udgangspunkt i f\u00f8lgende:</p> <pre><code>internal abstract class K\u00e6ledyr\n{\npublic string Navn { get; set; }\npublic abstract string Kendelyd();\n}\ninternal class Fugl : K\u00e6ledyr\n{\npublic bool H\u00e5ndTam { get; set; }\npublic override string Kendelyd()\n{\nreturn \"Pip\";\n}\npublic override string ToString()\n{\nreturn $\"Jeg er en fugl der hedder {Navn} og siger {Kendelyd()}\";\n}\n}\ninternal class Hund : K\u00e6ledyr\n{\npublic string HundeRegisterId { get; set; }\npublic override string Kendelyd()\n{\nreturn \"Vov\";\n}\npublic override string ToString()\n{\nreturn $\"Jeg er en hund der hedder {Navn} og siger {Kendelyd()}\";\n}\n}\n</code></pre> <p>kan man godt skrive f\u00f8lgende kode:</p> <pre><code>Fugl f = new Fugl() { Navn = \"Hans\", H\u00e5ndTam = true };\nHund h = new Hund() { Navn = \"Mille\", HundeRegisterId = \"1\" };\n// Bem\u00e6rk - En variabel der kan pege p\u00e5 \"mor\" kan ogs\u00e5 pege p\u00e5 dens \"b\u00f8rn\"\nK\u00e6ledyr k1 = new Fugl() { Navn = \"Svend\", H\u00e5ndTam = false  };\nK\u00e6ledyr k2 = new Hund() { Navn = \"Brutus\", HundeRegisterId = \"2\" };\nConsole.WriteLine(f.ToString());     // Jeg er en fugl der hedder Hans og siger Pip\nConsole.WriteLine(h.ToString());     // Jeg er en hund der hedder Mille og siger Vov\nConsole.WriteLine(k1.ToString());    // Jeg er en fugl der hedder Svend og siger Pip\nConsole.WriteLine(k2.ToString());    // Jeg er en hund der hedder Brutus og siger Vov\n</code></pre> <p>Kigger man n\u00e6rmere p\u00e5 k1 og k2 er det jo variabler som kan pege p\u00e5 et K\u00e6ledyr, men da b\u00e5de Hund og Fugl jo ER et k\u00e6ledyr kan det lade sig g\u00f8re. Og p\u00e5 heap\u2019en ligger der objekter af b\u00e5de Hund og Fugl - vi kan blot ikke se medlemmer relateret til Hund og Fugl for vores variabel jo er af typen K\u00e6ledyr.</p> <p>Bem\u00e6rk: \u201cmor\u201d beh\u00f8ver ikke v\u00e6re abstrakt for at udnytte dette.</p> <p>Find eventuelt den Powerpoint-pr\u00e6sentation der ligger til grund for videoen her.</p>"},{"location":"105_Polymofi.html#is","title":"is","text":"<p>Men man kan altid sp\u00f8rge om et objekt er af en konkret type:</p> <pre><code>Fugl f = new Fugl() { Navn = \"Hans\", H\u00e5ndTam = true };\nHund h = new Hund() { Navn = \"Mille\", HundeRegisterId = \"1\" };\n// Bem\u00e6rk - En variabel der kan pege p\u00e5 \"mor\" kan ogs\u00e5 pege p\u00e5 dens \"b\u00f8rn\"\nK\u00e6ledyr k1 = new Fugl() { Navn = \"Svend\", H\u00e5ndTam = false };\nK\u00e6ledyr k2 = new Hund() { Navn = \"Brutus\", HundeRegisterId = \"2\" };\nConsole.WriteLine(f is Fugl);       // true\nConsole.WriteLine(f is Hund);       // false\nConsole.WriteLine(f is K\u00e6ledyr);    // true\nConsole.WriteLine(k1 is K\u00e6ledyr);   // true\nConsole.WriteLine(k1 is Fugl);      // true\nConsole.WriteLine(k1 is Hund);      // false\n</code></pre>"},{"location":"105_Polymofi.html#typekonvertering","title":"Typekonvertering","text":"<p>Og man kan altid typekonvertere retur til den rigtige type hvis man \u00f8nsker det:</p> <pre><code>K\u00e6ledyr k1 = new Fugl() { Navn = \"Svend\", H\u00e5ndTam = false };\nK\u00e6ledyr k2 = new Hund() { Navn = \"Brutus\", HundeRegisterId = \"2\" };\nFugl f1 = k1 as Fugl;   // ok\nHund h1 = k2 as Hund;   // ok\nFugl f2 = k2 as Fugl;   // fejl (f2 = null) - k2 er en hund og ikke en fugl\n// eller\nFugl f1a = (Fugl)k1;   // ok\nHund h1a = (Hund)k2;   // ok\nFugl f2a = (Fugl)k2;   // fejl (Exception) - k2 er en hund og ikke en fugl\n</code></pre>"},{"location":"105_Polymofi.html#pattern-matching","title":"Pattern matching","text":"<p>Man kan benytte pattern matching i is fra version 7.</p> <p>F\u00f8lgende:</p> <pre><code>public static void Vis1(object o)\n{\nif (o is Person)\n{\nvar p = o as Person;\nConsole.WriteLine($\"Person hedder {p.Navn}\");\n}\nelse if (o is Bil)\n{\nvar b = o as Bil;\nConsole.WriteLine($\"Bil er en {b.M\u00e6rke}\");\n}\nelse\n{\nConsole.WriteLine($\"?\");\n}\n}\n</code></pre> <p>kan skrives som </p> <pre><code>public static void Vis2(object o)\n{\nif (o is Person p)\n{                Console.WriteLine($\"Person hedder {p.Navn}\");\n}\nelse if (o is Bil b)\n{                Console.WriteLine($\"Bil er en {b.M\u00e6rke}\");\n}\nelse\n{\nConsole.WriteLine($\"?\");\n}\n}   </code></pre>"},{"location":"105_Polymofi.html#polymorfi-og-samlinger","title":"Polymorfi og samlinger","text":"<p>Brug af virtuelle/abstrakte medlemmer, samt det faktum at \u201cmor\u201d altid kan pege p\u00e5 \u201cb\u00f8rn\u201d, kan blandt udnyttes i samlinger.</p> <p>Her er en liste af k\u00e6ledyr, og da b\u00e5de en Hund og en Fugl ER k\u00e6ledyr kan de tildeles samme liste/array/k\u00f8/stack mv:</p> <pre><code>List&lt;K\u00e6ledyr&gt; lst = new List&lt;K\u00e6ledyr&gt;();\nlst.Add(new Fugl() { Navn = \"Hans\", H\u00e5ndTam = true });\nlst.Add(new Hund() { Navn = \"Mille\", HundeRegisterId = \"1\" });\nlst.Add(new Fugl() { Navn = \"Svend\", H\u00e5ndTam = false });\nlst.Add(new Hund() { Navn = \"Brutus\", HundeRegisterId = \"2\" });\nforeach (var item in lst)\nConsole.WriteLine(item.ToString());\n/*\nJeg er en fugl der hedder Hans og siger Pip\nJeg er en hund der hedder Mille og siger Vov\nJeg er en fugl der hedder Svend og siger Pip\nJeg er en hund der hedder Brutus og siger Vov\n*/\n</code></pre> <p>Smart - ik ;)</p> <p>Info</p>"},{"location":"105_Polymofi.html#opgave-105-4","title":"Opgave 105-4","text":"<p>Brug af polymorfi i en samling af dyr (kode til s\u00f8gning: BAFE)</p> <p>Se opgave</p>"},{"location":"105_Polymofi.html#shadowing","title":"Shadowing","text":"<p>Man kan gemme (ikke fjerne) en metode for runtime ved ikke at bruge override (brug new i stedet). Det er dog sj\u00e6ldent det giver mening - men for en god ordens skyld er her et eksempel. Med udgangspunkt i f\u00f8lgende:</p> <pre><code>internal abstract class K\u00e6ledyr\n{\npublic string Navn { get; set; }\npublic virtual string Kendelyd() {\nreturn \"?\";\n}\n}\ninternal class Fugl : K\u00e6ledyr\n{\npublic bool H\u00e5ndTam { get; set; }\npublic new string Kendelyd()        // bem\u00e6rk new og ingen override\n{\nreturn \"Pip\";\n}\n}\n</code></pre> <p>Nu \u201cgemmes\u201d KendeLyd() v\u00e6k n\u00e5r referencevariablen er af mor\u2019s type:</p> <pre><code>Fugl fugl = new Fugl() { Navn = \"Hans\", H\u00e5ndTam = true };\nConsole.WriteLine(fugl.Kendelyd());     // Pip\nK\u00e6ledyr k\u00e6ledyr = new Fugl() { Navn = \"Hans\", H\u00e5ndTam = true };\n// Bem\u00e6rk, at fuglens KendeLyd \"gemmes v\u00e6k\" og mors KendeLyd afvikles i stedet\nConsole.WriteLine(k\u00e6ledyr.Kendelyd());  // ?\n</code></pre>"},{"location":"110_Interfaces.html","title":"Interface","text":""},{"location":"110_Interfaces.html#om-modulet","title":"Om modulet","text":"<p>I dette modul ser vi p\u00e5 brugen af interface.</p> <p>Som begynder er det vigtigste, at du forst\u00e5r de overordnede form\u00e5l med interface - alts\u00e5 at give compileren 100% vished for at en metode eksisterer. Du b\u00f8r fokusere p\u00e5 den simple form for polymorfi, og m\u00e5ske ikke bruge s\u00e5 meget energi p\u00e5 at forst\u00e5 afkobling (herunder dependency injection).</p> <p>Hvis du har erfaring med C# eller andre objektorienterede sprog kan du l\u00f8be eksemplerne igennem og m\u00e5ske kigge n\u00e6rmere p\u00e5 det sidste afsnit.</p>"},{"location":"110_Interfaces.html#generelt-om-interface","title":"Generelt om interface","text":"<ul> <li>Interface er en navngivet samling af abstrakte medlemmer<ul> <li>Kompileren ved (ligesom ved arv) hvilke medlemmer der findes</li> </ul> </li> <li>Benyttes til at skabe samh\u00f8righed mellem klasser/strukturer<ul> <li>Polymorfi</li> <li>Afkobling</li> </ul> </li> <li>Ingen implementation - kun signatur/definition<ul> <li>Implementation skal i klasser der implementerer et interface</li> </ul> </li> <li>Man m\u00e5 gerne implementere flere interface i en klasse (i mods\u00e6tning til arv)<ul> <li>En klasse m\u00e5 gerne arve fra en anden klasse og implementere et eller flere interfaces</li> </ul> </li> </ul>"},{"location":"110_Interfaces.html#brug-af-egne-interfaces","title":"Brug af egne interfaces","text":"<ul> <li>B\u00f8r starte med I</li> <li>Synlighed angives ikke</li> <li>Interface er en reference type</li> <li>Skal implementeres af en klasse/struct</li> </ul>"},{"location":"110_Interfaces.html#syntaks","title":"Syntaks","text":"<ul> <li>Benyt interface-kodeordet</li> <li>Beskriv signatur uden access modifiers (og implementation)</li> </ul> <pre><code>internal interface IGem\n{\nvoid Gem();\n// m\u00e5ske ogs\u00e5..\n// ErGemt();\n// DatoForSidsteGem();\n// mv\n}\n</code></pre>"},{"location":"110_Interfaces.html#implementering","title":"Implementering","text":"<ul> <li>Samme syntaks som klasser</li> <li>Metoder skal implementeres</li> <li>Brug VS til at hj\u00e6lpe</li> </ul> <pre><code>internal interface IGem\n{\nvoid Gem();\n}\ninternal class Vare : IGem {\npublic int VareId { get; set; }\npublic string Varenavn { get; set; }\n// Explicit\nvoid IGem.Gem()\n{\n// Kode til at gemme\n}\n}\ninternal class Kunde : IGem\n{\npublic int KundeId { get; set; }\npublic string Navn { get; set; }\n// Implicit\npublic void Gem()\n{\n// Kode til at gemme\n}\n}\n</code></pre>"},{"location":"110_Interfaces.html#interface-er-en-referencetype","title":"Interface er en referencetype","text":"<p>Man kan altid skabe en variabel af en interface-type, og f\u00e5 den til at pege p\u00e5 et objekt af en klasse der implementerer samme interface.</p> <pre><code>Vare v = new Vare();\nKunde k = new Kunde();\nIGem g1 = new Vare();\nIGem g2 = new Kunde();\n</code></pre> <p>Man kan dog kun tilg\u00e5 de medlemmer som interfacet definerer - men resten er jo ogs\u00e5 ligegyldigt. Man ser objektet som et objekt af interface-typen.</p>"},{"location":"110_Interfaces.html#brug-af-is","title":"Brug af is","text":"<p>Man kan naturligvis kontrollere om et objekt ER en interface-type:</p> <pre><code>Console.WriteLine(v is Vare);   // true\nConsole.WriteLine(v is IGem);   // true\nConsole.WriteLine(v is Kunde);  // false\n</code></pre>"},{"location":"110_Interfaces.html#brug-af-as-typekonvertering","title":"Brug af as (typekonvertering)","text":"<p>Og man kan naturligvis typekonvertere til en konkret type.</p> <pre><code>IGem g1 = new Vare();\nVare v = g1 as Vare;        // v = object\nKunde k = g1 as Kunde;      // k = null\nVare v1 = (Vare)g1;         // v1 = object\nKunde k1 = (Kunde)g1;       // Exception\n</code></pre>"},{"location":"110_Interfaces.html#polymorfi","title":"Polymorfi","text":"<p>Interface giver mulighed for samme funktionalitet som klasser og arv - man kan skabe en liste af et interface. Alle klasser som implementerer et interface kan placeres i listen.</p> <pre><code>internal interface IGem\n{\nvoid Gem();\n}\ninternal class Vare : IGem\n{\npublic int VareId { get; set; }\npublic string Varenavn { get; set; }\npublic void Gem()\n{\nConsole.WriteLine(\"Gemmer vare...\");\n}\n}\ninternal class Kunde : IGem\n{\npublic int KundeId { get; set; }\npublic string Navn { get; set; }\npublic void Gem()\n{\nConsole.WriteLine(\"Gemmer kunde...\");\n}\n}\n</code></pre> <pre><code>List&lt;IGem&gt; l = new List&lt;IGem&gt;();\nl.Add(new Vare());\nl.Add(new Kunde());\nl.Add(new Vare());\nl.Add(new Kunde());\nforeach (var item in l)\nitem.Gem();\n/*\n    Gemmer vare...\n    Gemmer kunde...\n    Gemmer vare...\n    Gemmer kunde...\n*/\n</code></pre> <p>Info</p>"},{"location":"110_Interfaces.html#opgave-110-1","title":"Opgave 110-1","text":"<p>Udvikling af egne interfaces og tilh\u00f8rende polymorfi (kode til s\u00f8gning: BBAB)</p> <p>Se opgave</p>"},{"location":"110_Interfaces.html#brug-af-icomparable","title":"Brug af IComparable","text":"<p>Sortering af objekter fra egne klasser kr\u00e6ver implementation af IComparable:</p> <pre><code>using System;\nusing System.Collections.Generic;\nusing System.Text;\nnamespace In4\n{\nclass Person : IComparable&lt;Person&gt;\n{\npublic string Navn { get; set; }\npublic int Alder { get; set; }\npublic int CompareTo(Person other)\n{\n//return this.Alder.CompareTo(other.Alder);\nif (this.Alder &gt; other.Alder)\nreturn 1;\nif (this.Alder &lt; other.Alder)\nreturn -1;\nreturn 0;\n}\n}\n}\n</code></pre> <pre><code>List&lt;In4.Person&gt; lst = new List&lt;In4.Person&gt;()\n{\nnew In4.Person(){ Alder = 10, Navn = \"a\" },\nnew In4.Person(){ Alder = 8, Navn = \"b\" },\nnew In4.Person(){ Alder = 9, Navn = \"c\" },\n};\nforeach (var item in lst)\nConsole.WriteLine($\"{item.Navn} er {item.Alder} \u00e5r\");\nlst.Sort();\nConsole.WriteLine();\nforeach (var item in lst)\nConsole.WriteLine($\"{item.Navn} er {item.Alder} \u00e5r\");\n/*\n ---------- Output: ----------\na er 10 \u00e5r\nb er 8 \u00e5r\nc er 9 \u00e5r\nb er 8 \u00e5r\nc er 9 \u00e5r\na er 10 \u00e5r\n*/\n</code></pre> <p>Info</p>"},{"location":"110_Interfaces.html#opgave-110-2","title":"Opgave 110-2","text":"<p>Brug af IComparable&lt;&gt; i forbindelse med sortering (kode til s\u00f8gning: BBAC)</p> <p>Se opgave</p>"},{"location":"110_Interfaces.html#brug-af-idisposable","title":"Brug af IDisposable","text":"<p>Hvis man \u00f8nsker at afvikle kode n\u00e5r et objekt g\u00e5r ud af scope (tuborgklammer) kan man overveje brugen af using-strukturen. Men det kr\u00e6ver implementering af IDisposable og dermed Dispose():</p> <pre><code>using (Oprydning.C c = new Oprydning.C())\n{\n} // Dispose bliver kaldt\n</code></pre>"},{"location":"110_Interfaces.html#afkobling","title":"Afkobling","text":"<p>Interface benyttes ogs\u00e5 tit i forbindelse med forskellige software m\u00f8nstre - herunder blandt andet Dependency Injection (DI). Se f\u00f8lgende video og eventuelt tilh\u00f8rende opgave for at f\u00e5 en ide om hvordan DI fungerer.</p> <p>Se eventuelt ogs\u00e5 alternativ til brug af interface p\u00e5 jbogard/MediatR.</p> <p>Info</p>"},{"location":"110_Interfaces.html#opgave-110-3","title":"Opgave 110-3","text":"<p>Avanceret opgave i brug af interfaces til afkobling (kode til s\u00f8gning: BBAD)</p> <p>Se opgave</p>"},{"location":"110_Interfaces.html#default-interface-methods","title":"Default interface methods","text":"<p>I C# 8 har vi f\u00e5et mulighed for at tilf\u00f8je metoder til interface. Det sikre, at tidligere implementationer af et interface ikke fejler ved opdatering af et nyt interface.</p> <p>Antag at f\u00f8lgende er version 1:</p> <pre><code>interface ILogger\n{\nvoid Log(string level, string message);\n}\nclass Logger : ILogger\n{\npublic void Log(string level, string message)\n{\n//\n}\n}\n</code></pre> <p>Men i version 2 opdateres interface, og hvis ikke der kunne angives en metode ville samtlige implementationer fejle.</p> <pre><code>interface ILogger\n{\nvoid Log(string level, string message);\nvoid Log(Exception ex) =&gt; Log(\"error\", ex.Message);\n}\n// Virker fortsat!!\nclass Logger : ILogger\n{\npublic void Log(string level, string message)\n{\n//\n}\n}\n</code></pre> <p>Den nye Log-metode kan dog overskrives hvis det \u00f8nskes:</p> <pre><code>class Logger : ILogger\n{\npublic void Log(string level, string message)\n{\n// kode\n}\npublic void Log(Exception x)\n{\n// kode\n}\n}\n</code></pre>"},{"location":"120_Delegates.html","title":"Delegates","text":""},{"location":"120_Delegates.html#om-modulet","title":"Om modulet","text":"<p>I dette modul ser vi p\u00e5 delegates og lambda udtryk. Begge ting er nok noget af det begyndere har alle sv\u00e6rest ved i C#, og det skyldes egentlig ikke at teorien er sv\u00e6r men mere at syntaksen kan v\u00e6re lidt teknisk, og at der er mange m\u00e5de at skrive det samme p\u00e5. Men tungen lige i munden og start med at forst\u00e5 hvad en delegate overhovedet er - s\u00e5 m\u00e5 du \u00f8ve dig p\u00e5 syntaksen over lidt tid.</p> <p>Bare for en god ordens skyld - skulle du efter at have stiftet bekendtskab med delegates og lambda ikke helt have set lyset s\u00e5 er du ikke den f\u00f8rste. Giv det er par dage og s\u00e5 se videoerne igen og lav opgaverne.</p>"},{"location":"120_Delegates.html#grundlggende-om-delegates","title":"Grundl\u00e6ggende om delegates","text":"<p>Vi har snakket om lokale og statiske reference til instanser p\u00e5 b\u00e5de heap og stack, men man kan ogs\u00e5 arbejde med referencer til metoder.</p> <p></p> <p>Ideen med at kunne arbejde med reference til en eller flere metoder er typisk at afkoble implementation - udvikleren der \u00f8nsker at benytte vores klasse eller metode m\u00e5 sende en reference til kode han/hun \u00f8nsker afviklet i et givet situation.</p>"},{"location":"120_Delegates.html#hvad-er-en-delegate","title":"Hvad er en delegate","text":"<p>En delegate er en speciel type i C# som kan ligge til grund for objekter der indeholder referencer til en eller flere metoder:</p> <p></p> <p>T\u00e6nk p\u00e5 ordet \u201cdelegate\u201d - en type der give mulighed for at \u201cdelegere\u201d afvikling af metoder. Kan sammenlignes med en objektorienteret version af C++\u2019s funktionspointere.</p>"},{"location":"120_Delegates.html#hvad-kan-man-bruge-en-delegate-til","title":"Hvad kan man bruge en delegate til","text":"<p>Man kunne forestille sig:</p> <ul> <li>finde elementer i en liste eller array ud fra et boolsk (true/false) resultat af en metode</li> <li>et argument til en metode hvor der angives en refence til metoder man \u00f8nsker afviklet ved success eller fejl (hedder ogs\u00e5 en call back metode og er meget benyttet i andre sprog)</li> <li>n\u00e5r der oprettes en instans af en klasse skal der samtidigt angives hvilken/hvilke metoder man \u00f8nsker klassen skal bruge til log</li> <li>en dynamisk \u201cregnemaskine\u201d hvor udvikleren selv kan udvide de funktioner lommeregneren stiller til r\u00e5dighed</li> <li>n\u00e5r terningen sl\u00e5r en sekser s\u00e5 bliver der afviklet en eller flere metoder angivet af udvikleren der opretter terningen (hedder ogs\u00e5 \u201ch\u00e6ndelser\u201d)</li> </ul> <p>Du kan finde koden der d\u00e6kker ovenn\u00e6vnte eksempler her.</p>"},{"location":"120_Delegates.html#definition-af-en-delegate","title":"Definition af en delegate","text":"<p>Se <code>delegate</code> ligesom <code>class</code> - den definerer en skabelon for et objekt med referencer til metoder.</p> <p></p> <p>En delegate kan placeres p\u00e5 namespace- og type-niveau (ligesom klasser, stukturer mv):</p> <pre><code>using System;\nnamespace Demo\n{\n// Defination af delegates\npublic delegate void MinDelegate1();\npublic delegate void MinDelegate2(string txt);\npublic delegate int MinDelegate3(int a, int b);\ninternal class Program\n{\nprivate static void Main(string[] args)\n{\nif (System.Diagnostics.Debugger.IsAttached)\n{\nConsole.Write(\"Press any key to continue . . . \");\nConsole.ReadKey();\n}\n}\n}\n}\n</code></pre>"},{"location":"120_Delegates.html#opret-et-delegate-objekt","title":"Opret et delegate objekt","text":"<p>N\u00e5r f\u00f8rst en delegate er defineret kan der skabes objekter p\u00e5 flere m\u00e5der</p> <ul> <li>brug af new til at oprette objekt</li> <li>constructor kr\u00e6ver en reference til en metode</li> <li>brug af navnet p\u00e5 metoden</li> <li>compiler autogenererer kode</li> </ul> <p>Husk at signatur p\u00e5 metoden skal matche signatur p\u00e5 delegate (ikke helt sandt i et arvehieraki men se bort fra det lige nu)</p> <pre><code>using System;\nnamespace Demo\n{\n// Defination af delegates\npublic delegate void MinDelegate1();\npublic delegate void MinDelegate2(string txt);\npublic delegate int MinDelegate3(int a, int b);\ninternal class Program\n{\nprivate static void Main(string[] args)\n{\nMinDelegate1 o1 = new MinDelegate1(Test1);\nMinDelegate1 o2 = Test1;\nMinDelegate2 o3 = new MinDelegate2(Test2);\nMinDelegate2 o4 = Test2;\nMinDelegate3 o5 = new MinDelegate3(Test3);\nMinDelegate3 o6 = Test3;\n// Man kan i princippet oprette et objekt med en NOP (no operation)\nMinDelegate1 o7 = new MinDelegate1(NOP);\nMinDelegate1 o8 = NOP;\nMinDelegate1 o9 = delegate\n{ };\n// Metoder kan defineres lokalt eller som instans eller statiske metoder\nvoid NOP()\n{ }\nvoid Test1()\n{ }\nvoid Test2(string t)\n{ }\nint Test3(int a, int b)\n{ return 0; }\nif (System.Diagnostics.Debugger.IsAttached)\n{\nConsole.Write(\"Press any key to continue . . . \");\nConsole.ReadKey();\n}\n}\n}\n}\n</code></pre>"},{"location":"120_Delegates.html#afvikling-af-metoder","title":"Afvikling af metoder","text":"<p>Man kan afvikle metoder p\u00e5 flere m\u00e5der</p> <ul> <li>b\u00f8r checke for null!</li> </ul> <pre><code>using System;\nnamespace Demo\n{\npublic delegate void MinDelegate1(string txt);\ninternal class Program\n{\nprivate static void Main(string[] args)\n{\n//MinDelegate1 o1 = new MinDelegate1(SkrivP\u00e5Konsol);\nMinDelegate1 o1 = SkrivP\u00e5Konsol;\nif (o1 != null)\no1.Invoke(\"Test\");\n// eller\no1?.Invoke(\"Test\");\n// eller\nif (o1 != null)\no1(\"Test\");\nvoid SkrivP\u00e5Konsol(string txt)\n{\nConsole.WriteLine($\"I SkrivP\u00e5Konsol med {txt} som argument\");\n}\nif (System.Diagnostics.Debugger.IsAttached)\n{\nConsole.Write(\"Press any key to continue . . . \");\nConsole.ReadKey();\n}\n}\n}\n}\n</code></pre>"},{"location":"120_Delegates.html#flere-referencer-i-en-delegate","title":"Flere referencer i en delegate","text":"<p>En delegate best\u00e5r af en liste af metoder s\u00e5 man kan b\u00e5de tilf\u00f8je og fjerne referencer dynamisk.</p> <ul> <li>Alle bliver afviklet</li> </ul> <p>Brugen af += bliver erstatet af et kald til Combine().</p> <pre><code>using System;\nnamespace Demo\n{\npublic delegate void MinDelegate1(string txt);\ninternal class Program\n{\nprivate static void Main(string[] args)\n{\n//MinDelegate1 o1 = new MinDelegate1(SkrivP\u00e5Konsol);\nMinDelegate1 o1 = SkrivP\u00e5Konsol;\n// Ekstra metoder\no1 += GemIFil;\no1 += Console.WriteLine;\n// Afvikler SAMTLIGE (tre) metoder\no1?.Invoke(\"Test\");\n// eller\n// if(o1!=null)\n//   o1(\"Test\");\n// Man kan ogs\u00e5 afvikle dem en af gangen (brugbar ved retur v\u00e6rdier)\nforeach (var item in o1.GetInvocationList())\nitem.DynamicInvoke(\"NY TEST\");\nvoid SkrivP\u00e5Konsol(string txt)\n{\nConsole.WriteLine($\"I SkrivP\u00e5Konsol med {txt} som argument\");\n}\nvoid GemIFil(string txt)\n{\nSystem.IO.File.AppendAllText(@\"c:\\temp\\test.txt\", txt + \"\\r\\n\");\n}\nif (System.Diagnostics.Debugger.IsAttached)\n{\nConsole.Write(\"Press any key to continue . . . \");\nConsole.ReadKey();\n}\n}\n}\n}\n</code></pre>"},{"location":"120_Delegates.html#fjern-referencer-fra-delegates","title":"Fjern referencer fra delegates","text":"<p>Man kan fjerne referencer med <code>-=</code> og b\u00f8r g\u00f8re det. N\u00e5r man har med events/referencer at g\u00f8re kan man komme til at skabe et memoryleak - s\u00e5 v\u00e6rd bevidst om at en reference b\u00f8r fjernes igen.</p> <p>Brugen af -= bliver erstatet af et kald til Remove().</p> <pre><code>using System;\nnamespace Demo\n{\npublic delegate void MinDelegate1(string txt);\ninternal class Program\n{\nprivate static void Main(string[] args)\n{\nMinDelegate1 o1 = SkrivP\u00e5Konsol;\n// Ekstra metoder\no1 += GemIFil;\no1 += Console.WriteLine;\no1?.Invoke(\"Test\");\no1 -= GemIFil;\no1 -= Console.WriteLine;\no1 -= SkrivP\u00e5Konsol;\n// eller\n// o1 = null;\nvoid SkrivP\u00e5Konsol(string txt)\n{\nConsole.WriteLine($\"I SkrivP\u00e5Konsol med {txt} som argument\");\n}\nvoid GemIFil(string txt)\n{\nSystem.IO.File.AppendAllText(@\"c:\\temp\\test.txt\", txt + \"\\r\\n\");\n}\nif (System.Diagnostics.Debugger.IsAttached)\n{\nConsole.Write(\"Press any key to continue . . . \");\nConsole.ReadKey();\n}\n}\n}\n}\n</code></pre> <p>Find eventuelt den Powerpoint-pr\u00e6sentation der ligger til grund for videoen her.</p> <p>Info</p> <p>Info</p> <p>Info</p>"},{"location":"120_Delegates.html#opgave-120-1","title":"Opgave 120-1","text":"<p>En opgave der omhandler brugen af delegates - b\u00e5de med og uden sukker. (kode til s\u00f8gning: BCAB)</p> <p>Se opgave</p>"},{"location":"120_Delegates.html#opgave-120-2","title":"Opgave 120-2","text":"<p>Brug af r\u00e5 delegates til at skabe en regnemaskine (kode til s\u00f8gning: BCAC)</p> <p>Se opgave</p>"},{"location":"120_Delegates.html#opgave-120-3","title":"Opgave 120-3","text":"<p>Brug af delegates til log-funktionalitet (kode til s\u00f8gning: BCAD)</p> <p>Se opgave</p>"},{"location":"120_Delegates.html#dynamicinvoke","title":"DynamicInvoke","text":"<p>Man kan eventuelt benytte den (i argumetnerne) typesvage DynamicInvoke-metode. Den skal ogs\u00e5 benyttes hvis man skal kalder metoder fra GetInvocationList() med mindre man typekonverterer:</p> <pre><code>Func&lt;int, int, int&gt; c = (a, b) =&gt; a + b;\nc += (a, b) =&gt; a - b;\nc += (a, b) =&gt; a * b;\nc += (a, b) =&gt; a / b;\nforeach (var item in c.GetInvocationList())\n{\nint r = (int)item.DynamicInvoke(8, 2);\nConsole.WriteLine(r);\n}\n</code></pre>"},{"location":"120_Delegates.html#indbyggede-delegates","title":"Indbyggede delegates","text":"<p>Der findes tre indbyggede generiske delegates</p> <ul> <li>Action</li> <li>Metoder uden retur v\u00e6rdi (void)</li> <li>Func</li> <li>Metoder med retur v\u00e6rdi</li> <li>Predicate</li> <li>Metode der returnerer en bool og tager et argument<ul> <li>Denne signatur meget i eksempelvis s\u00f8gefunktioner mv</li> </ul> </li> </ul>"},{"location":"120_Delegates.html#action","title":"Action","text":"<p>Action d\u00e6kker void metoder (med 16 argumenter), og typerne p\u00e5 argumenterne angives generisk ved erkl\u00e6ring. S\u00e5ledes er f\u00f8lgende tre delegates erstattet af Action-delegates:</p> <pre><code>using System;\nnamespace Demo\n{\npublic delegate void MinDelegate1();\npublic delegate void MinDelegate2(string txt);\npublic delegate void MinDelegate3(string txt, int a);\ninternal class Program\n{\nprivate static void Main(string[] args)\n{\nMinDelegate1 f1 = Test1;\nAction f2 = Test1;\nMinDelegate2 f3 = Test2;\nAction&lt;string&gt; f4 = Test2;\nMinDelegate3 f5 = Test3;\nAction&lt;string, int&gt; f6 = Test3;\nf1?.Invoke();\nf2?.Invoke();\nf3?.Invoke(\"\");\nf4?.Invoke(\"\");\nf5?.Invoke(\"\", 0);\nf6?.Invoke(\"\", 0);\nvoid Test1()\n{ Console.WriteLine(\"I Test1\"); }\nvoid Test2(string t)\n{ Console.WriteLine(\"I Test2\"); }\nvoid Test3(string t, int x)\n{ Console.WriteLine(\"I Test3\"); }\nif (System.Diagnostics.Debugger.IsAttached)\n{\nConsole.Write(\"Press any key to continue . . . \");\nConsole.ReadKey();\n}\n}\n}\n}\n</code></pre> <p>Info</p>"},{"location":"120_Delegates.html#opgave-120-4","title":"Opgave 120-4","text":"<p>Brug af delegates til log-funktionalitet (indbyggede delegates) (kode til s\u00f8gning: BCAE)</p> <p>Se opgave</p>"},{"location":"120_Delegates.html#func","title":"Func","text":"<p>Func d\u00e6kker metoder med returv\u00e6rdi, og typen p\u00e5 argumenter og p\u00e5 returv\u00e6rdi angives generisk. Den sidst angivne type d\u00e6kker returv\u00e6rdi - Eksempelvis <code>Func&lt;int, double, bool&gt; d1</code> svarer til <code>delegate bool d1(int a, double b)</code></p> <p>S\u00e5ledes er f\u00f8lgende tre delegates erstattet af Func-delegates:</p> <pre><code>using System;\nnamespace Demo\n{\npublic delegate bool MinDelegate1();\npublic delegate bool MinDelegate2(string txt);\npublic delegate bool MinDelegate3(string txt, int a);\ninternal class Program\n{\nprivate static void Main(string[] args)\n{\nMinDelegate1 f1 = Test1;\nFunc&lt;bool&gt; f2 = Test1;\nMinDelegate2 f3 = Test2;\nFunc&lt;string, bool&gt; f4 = Test2;\nMinDelegate3 f5 = Test3;\nFunc&lt;string, int, bool&gt; f6 = Test3;\nbool? res;\nres = f1?.Invoke();\nres = f2?.Invoke();\nres = f3?.Invoke(\"\");\nres = f4?.Invoke(\"\");\nres = f5?.Invoke(\"\", 0);\nres = f6?.Invoke(\"\", 0);\nbool Test1()\n{\nConsole.WriteLine(\"I Test1\");\nreturn false;\n}\nbool Test2(string t)\n{\nConsole.WriteLine(\"I Test2\");\nreturn false;\n}\nbool Test3(string t, int x)\n{\nConsole.WriteLine(\"I Test3\");\nreturn false;\n}\nif (System.Diagnostics.Debugger.IsAttached)\n{\nConsole.Write(\"Press any key to continue . . . \");\nConsole.ReadKey();\n}\n}\n}\n}\n</code></pre> <p>Info</p>"},{"location":"120_Delegates.html#opgave-120-5","title":"Opgave 120-5","text":"<p>Brug af Func til at skabe en regnemaskine (kode til s\u00f8gning: BCAF)</p> <p>Se opgave</p>"},{"location":"120_Delegates.html#predicate","title":"Predicate","text":"<p>Predicate d\u00e6kker en metode med et argument der altid returnerer en bool, og typen p\u00e5 argumentet angives generisk. Eksempelvis benyttes en Predicate i mange Array/LINQ metoder - herunder findes det index hvor v\u00e6rdien = 6. FindIndex-metoden tager en Predicate (delegate som returnerer en bool med en int som argument) for at findes det konkrete indeks.</p> <pre><code>int[] array = { 5, 1, 4, 1, 6, 7, 10 };\nint findes = System.Array.FindIndex(array, FindesTal);  // 4\nbool FindesTal(int a)\n{\nreturn a == 6;\n}\n</code></pre> <p>S\u00e5 f\u00f8lgende tre delegates er erstattet af Predicate-delegates:</p> <pre><code>using System;\nnamespace Demo\n{\npublic delegate bool MinDelegate1(int a);\npublic delegate bool MinDelegate2(string txt);\npublic delegate bool MinDelegate3(double a);\ninternal class Program\n{\nprivate static void Main(string[] args)\n{\nMinDelegate1 f1 = Test1;\nPredicate&lt;int&gt; f2 = Test1;\nMinDelegate2 f3 = Test2;\nPredicate&lt;string&gt; f4 = Test2;\nMinDelegate3 f5 = Test3;\nPredicate&lt;double&gt; f6 = Test3;\nbool? res;\nres = f1?.Invoke(0);\nres = f2?.Invoke(0);\nres = f3?.Invoke(\"\");\nres = f4?.Invoke(\"\");\nres = f5?.Invoke(0);\nres = f6?.Invoke(0);\nbool Test1(int a)\n{\nConsole.WriteLine(\"I Test1\");\nreturn false;\n}\nbool Test2(string t)\n{\nConsole.WriteLine(\"I Test2\");\nreturn false;\n}\nbool Test3(double a)\n{\nConsole.WriteLine(\"I Test3\");\nreturn false;\n}\nif (System.Diagnostics.Debugger.IsAttached)\n{\nConsole.Write(\"Press any key to continue . . . \");\nConsole.ReadKey();\n}\n}\n}\n}\n</code></pre> <p>Info</p> <p>Info</p>"},{"location":"120_Delegates.html#opgave-120-6","title":"Opgave 120-6","text":"<p>Brug af en predicate til Array-funktioner (kode til s\u00f8gning: BCAG)</p> <p>Se opgave</p>"},{"location":"120_Delegates.html#opgave-120-7","title":"Opgave 120-7","text":"<p>Brug af en Predicate til en filtreringsmetode (kode til s\u00f8gning: BCAH)</p> <p>Se opgave</p>"},{"location":"120_Delegates.html#lambda-expressions","title":"Lambda expressions","text":"<p>Lambda i C# er i virkeligheden ret kompleks og d\u00e6kker over expressions trees og generering af dynamiske udtryk - men i sin simple form er det bare en anden og hurtigere m\u00e5de at skrive en metode (sukker metode syntaks). Man kan ogs\u00e5 kalde det en anonym metode fordi en Lambda returnerer en delegate, og ikke i sig selv har et navn.</p> <p>Man kan skrive Lambda-udtryk p\u00e5 mange m\u00e5der hvilket g\u00f8r det lidt sv\u00e6rt at l\u00e6re, men n\u00e5r du f\u00f8rst har styr p\u00e5 det er det en super effektiv m\u00e5de at skrive kode p\u00e5. Her er eksemplet fra tidligere med FindIndex - nu med lambda:</p> <pre><code>int[] array = { 5, 1, 4, 1, 6, 7, 10 };\nint findes1 = System.Array.FindIndex(array, FindesTal);  // 4\nbool FindesTal(int a)\n{\nreturn a == 6;\n}\n// var noget nemmere at skrive (hvis man lige vender sig til syntaksen - smiler)\nint findes2 = System.Array.FindIndex(array, i =&gt; i == 6);   // 4\n</code></pre> <p>Her er nogle af reglerne som lambda-syntaks</p> <ul> <li>=&gt; betyder \u201csendes ind i metoden som argument\u201d</li> <li>N\u00e5r der angives argumenter</li> <li>Du beh\u00f8ver ikke at angive typenavn</li> <li>Ved et argument beh\u00f8ver man ikke angive parentes</li> <li>Ved flere argumenter skal der benyttes parentes</li> <li>Ingen argumenter angives som ()</li> <li>Hvis metoden blot best\u00e5r af en enkelt instruktion beh\u00f8ver man ikke tuborgklammer</li> <li>Hvis metoden blot returnerer en v\u00e6rdi i f\u00f8rste instruktion beh\u00f8ver man ikke return</li> </ul> <pre><code>using System;\nnamespace Demo\n{\ninternal class Program\n{\nprivate static void Main(string[] args)\n{\nvoid Test1()\n{\nConsole.WriteLine(\"I Test1\");\n}\nAction f1 = Test1;\nAction f2 = () =&gt; { Console.WriteLine(\"I Test1\"); };\nAction f3 = () =&gt; Console.WriteLine(\"I Test1\");\nf1();\nf2();\nf3();\nvoid Test2(int a)\n{\nConsole.WriteLine($\"I Test2 med {a}\");\n}\nAction&lt;int&gt; f4 = Test2;\nAction&lt;int&gt; f5 = (int x) =&gt; { Console.WriteLine($\"I Test2 med {x}\"); };\nAction&lt;int&gt; f6 = (x) =&gt; { Console.WriteLine($\"I Test2 med {x}\"); };\nAction&lt;int&gt; f7 = x =&gt; Console.WriteLine($\"I Test2 med {x}\");\nf4(1);\nf5(1);\nf6(1);\nf7(1);\nvoid Test3(int a, int b)\n{\nConsole.WriteLine($\"I Test2 med {a} og {b}\");\n}\nAction&lt;int, int&gt; f8 = Test3;\nAction&lt;int, int&gt; f9 = (int x, int y) =&gt; { Console.WriteLine($\"I Test2 med {x} og {y}\"); };\nAction&lt;int, int&gt; f10 = (x, y) =&gt; { Console.WriteLine($\"I Test2 med {x} og {y}\"); };\nAction&lt;int, int&gt; f11 = (x, y) =&gt; Console.WriteLine($\"I Test2 med {x} og {y}\");\nf8(1, 1);\nf9(1, 1);\nf10(1, 1);\nf11(1, 1);\nint Test4(int a)\n{\nreturn a + 1;\n}\nFunc&lt;int, int&gt; f12 = Test4;\nFunc&lt;int, int&gt; f13 = (int x) =&gt; { return x + 1; };\nFunc&lt;int, int&gt; f14 = (x) =&gt; { return x + 1; };\nFunc&lt;int, int&gt; f15 = x =&gt; x + 1;\nConsole.WriteLine(f12(1));\nConsole.WriteLine(f13(1));\nConsole.WriteLine(f14(1));\nConsole.WriteLine(f15(1));\nint Test5(int a, int b)\n{\nreturn a + b;\n}\nFunc&lt;int, int, int&gt; f16 = Test5;\nFunc&lt;int, int, int&gt; f17 = (int x, int y) =&gt; { return x + y; };\nFunc&lt;int, int, int&gt; f18 = (x, y) =&gt; { return x + y; };\nFunc&lt;int, int, int&gt; f19 = (x, y) =&gt; x + y;\nConsole.WriteLine(f16(1, 1));\nConsole.WriteLine(f17(1, 1));\nConsole.WriteLine(f18(1, 1));\nConsole.WriteLine(f19(1, 1));\nbool Test6(int a)\n{\nreturn a &lt; 10;\n}\nPredicate&lt;int&gt; f20 = Test6;\nPredicate&lt;int&gt; f21 = (int x) =&gt; { return x &lt; 10; };\nPredicate&lt;int&gt; f22 = (x) =&gt; { return x &lt; 10; };\nPredicate&lt;int&gt; f23 = x =&gt; x &lt; 10;\nConsole.WriteLine(f20(1));\nConsole.WriteLine(f21(1));\nConsole.WriteLine(f22(1));\nConsole.WriteLine(f23(1));\nif (System.Diagnostics.Debugger.IsAttached)\n{\nConsole.Write(\"Press any key to continue . . . \");\nConsole.ReadKey();\n}\n}\n}\n}\n</code></pre> <p>Info</p> <p>Info</p>"},{"location":"120_Delegates.html#opgave-120-8","title":"Opgave 120-8","text":"<p>Brug af delegates og lambda-metoder til at arbejde p\u00e5 et array af heltal. (kode til s\u00f8gning: BCAI)</p> <p>Se opgave</p>"},{"location":"120_Delegates.html#opgave-120-9","title":"Opgave 120-9","text":"<p>Brug af Func til at skabe en regnemaskine (kode til s\u00f8gning: BCAJ)</p> <p>Se opgave</p>"},{"location":"120_Delegates.html#discards","title":"Discards","text":"<p>Fra C# 9 er det muligt at benytte descards (_) til at angive b\u00e5de kompiler og udvikler at der ikke er behov for et argument. Det bruges is\u00e6r i tuples, ved ignorering af returv\u00e6rdier fra en metode men ogs\u00e5 nogle gange i lambda:</p> <pre><code>Func&lt;int, int, int&gt; a = (_, _) =&gt; 0;\n</code></pre>"},{"location":"120_Delegates.html#brug-af-var-med-lambda","title":"Brug af var med lambda","text":"<p>Fra C# 10 er det muligt at lade kompileren finde returtypen. Alternativt kan den som noget nyt angives ved deklaration:</p> <pre><code>Func&lt;int, int, int&gt; f1 = (a, b) =&gt; a + b;\nvar f2 = (int a, int b) =&gt; a + b;\nvar f3 = int (int a, int b) =&gt; a + b;\n</code></pre>"},{"location":"120_Delegates.html#anden-brug-af-lambda-syntaks","title":"Anden brug af lambda syntaks","text":"<p>Til orientering kan lambda syntaks ogs\u00e5 benyttes til egenskaber og metoder i typer - eksempelvis</p> <pre><code>using System;\nnamespace demo\n{\ninternal class Program\n{\nprivate static void Main(string[] args)\n{\nPerson p = new Person { Alder = 30 };\nConsole.WriteLine(p.BeregnetF\u00f8dsels\u00e5r);\np.Skriv();\nConsole.WriteLine(p.Er\u00c6ldre(31));\n}\n}\npublic class Person {\n// Egenskaber (get/set)\nprivate int alder;\npublic int Alder\n{\nget =&gt; alder;\nset =&gt; alder = value;\n}\n// Egenskab (get)\npublic int BeregnetF\u00f8dsels\u00e5r =&gt; DateTime.Now.Year - Alder;\n// Metoder\npublic void Skriv() =&gt; Console.WriteLine(\"Person er fra \" + BeregnetF\u00f8dsels\u00e5r);\npublic bool Er\u00c6ldre(int andenAlder) =&gt; alder &gt; andenAlder;\n}\n}\n</code></pre>"},{"location":"125_Events.html","title":"H\u00e6ndelser","text":""},{"location":"125_Events.html#om-modulet","title":"Om modulet","text":"<p>Dette model handler om h\u00e6ndelser (events). Det er muligheden for at objekter kan afvikle en eller flere metoder n\u00e5r en given h\u00e6ndelse sker. Det vigtigste at forst\u00e5 er princippet og form\u00e5let med h\u00e6ndelser s\u00e5 vi starter med at se p\u00e5 nogle eksempler. Herefter ser vi p\u00e5 hvordan du selv kan skabe klasser med h\u00e6ndelser.</p>"},{"location":"125_Events.html#grundlggende-om-hndelser","title":"Grundl\u00e6ggende om h\u00e6ndelser","text":"<p>H\u00e6ndelser giver mulighed for at objekter kan afvikle kode n\u00e5r \u201cnoget\u201d sker - det kunne v\u00e6re</p> <ul> <li>N\u00e5r der er g\u00e5et et specielt tidsrum</li> <li>N\u00e5r der oprettes eller slettes en fil fra en folder</li> <li>N\u00e5r en konto g\u00e5r i minus</li> <li>N\u00e5r der sl\u00e5s en sekser med en terning</li> </ul>"},{"location":"125_Events.html#eksempel-en-timer","title":"Eksempel - en timer","text":"<p>Pr\u00f8v at kopiere f\u00f8lgende kode til en tom konsolapplikation:</p> <pre><code>using System;\nnamespace Demo\n{\nclass Program\n{\nstatic void Main(string[] args)\n{\nSystem.Timers.Timer t = new System.Timers.Timer();\nt.Interval = 1000;\nt.Enabled = true;\nt.Elapsed += (s, e) =&gt; Console.WriteLine(\"tiktak\");\ndo { } while (true);\n}\n}\n}\n</code></pre> <p>Bem\u00e6rk, at der hvert sekund udskrives \u201ctiktak\u201d, og at <code>t.Elapsed +=</code> er brug af delegates jf. tidligere.</p>"},{"location":"125_Events.html#eksempel-hold-je-med-en-mappe","title":"Eksempel - Hold \u00f8je med en mappe","text":"<p>Pr\u00f8v f\u00f8lgende kode:</p> <pre><code>using System;\nnamespace Demo\n{\nclass Program\n{\nstatic void Main(string[] args)\n{\nSystem.IO.FileSystemWatcher w = new System.IO.FileSystemWatcher(@\"c:\\tmp\");\nw.EnableRaisingEvents = true;\nw.Created += (s, e) =&gt; Console.WriteLine(\"Fil oprettet\");\nw.Deleted += (s, e) =&gt; Console.WriteLine(\"Fil slettet\");\ndo { } while (true);\n}\n}\n}\n</code></pre> <p>Bem\u00e6rk, at der udskrives p\u00e5 konsol n\u00e5r der oprettes og slettes en fil i c:\\tmp.</p>"},{"location":"125_Events.html#eksempel-nar-en-konto-gar-i-minus","title":"Eksempel - N\u00e5r en konto g\u00e5r i minus","text":"<p>Pr\u00f8v f\u00f8lgende:</p> <pre><code>using System;\nnamespace Demo\n{\nclass Program\n{\nstatic void Main(string[] args)\n{\nKonto k = new Konto(100);\nk.KontoIMinus += (s, e) =&gt; Console.WriteLine(\"MINUS..\");\nk.Inds\u00e6t(10);\nConsole.WriteLine(k.Saldo);\nk.Udtr\u00e6k(50);\nConsole.WriteLine(k.Saldo);\nk.Udtr\u00e6k(10);\nConsole.WriteLine(k.Saldo);\nk.Udtr\u00e6k(60);\nConsole.WriteLine(k.Saldo);\n}\n}\nclass Konto\n{\npublic double Saldo { get; private set; }\npublic event EventHandler KontoIMinus;\npublic Konto(double saldo)\n{\nSaldo = saldo;\n}\npublic void Inds\u00e6t(double bel\u00f8b)\n{\nSaldo += bel\u00f8b;\nif (Saldo &lt; 0)\nKontoIMinus?.Invoke(this, new EventArgs());\n}\npublic void Udtr\u00e6k(double bel\u00f8b)\n{\nSaldo -= bel\u00f8b;\nif (Saldo &lt; 0)\nKontoIMinus?.Invoke(this, new EventArgs());\n}\n}\n}\n</code></pre> <p>Bem\u00e6rk, at Konto-klassen giver mulighed for at afvikle noget kode n\u00e5r saldoen er under nul.</p>"},{"location":"125_Events.html#eksempel-nar-der-slas-en-sekser","title":"Eksempel - n\u00e5r der sl\u00e5s en sekser","text":"<p>Pr\u00f8v f\u00f8lgende:</p> <pre><code>using System;\nnamespace Demo\n{\nclass Program\n{\nstatic void Main(string[] args)\n{\nTerning t = new Terning();\nt.ErSekser += (s, e) =&gt;\n{\nConsole.WriteLine(\"SEKSER!!!!\");\nConsole.Beep();\n};\nfor (int i = 0; i &lt; 10; i++)\n{\nt.Ryst();\nt.Skriv();\n}\n}\n}\npublic class Terning\n{\nprivate System.Random rnd = new Random();\npublic event EventHandler ErSekser;\npublic int V\u00e6rdi { get; private set; }\npublic Terning()\n{\nthis.Ryst();\n}\npublic void Ryst()\n{\nthis.V\u00e6rdi = rnd.Next(1, 7);\nif (this.V\u00e6rdi == 6)\n{\nErSekser?.Invoke(this, new EventArgs());\n}\n}\npublic void Skriv()\n{\nConsole.WriteLine($\"[{this.V\u00e6rdi}]\");\n}\n}\n}\n</code></pre> <p>Info</p>"},{"location":"125_Events.html#opgave-125-1","title":"Opgave 125-1","text":"<p>\u00d8v dig p\u00e5 brug af events med FileSystemWatcher. (kode til s\u00f8gning: BCFB)</p> <p>Se opgave</p>"},{"location":"125_Events.html#hvad-er-en-hndelse","title":"Hvad er en h\u00e6ndelse","text":"<p>Egentlig er en h\u00e6ndelse (event) i bund og grund en delegate som tidligere gennemg\u00e5et, men er implementeret som en h\u00e6ndelse prim\u00e6rt fordi det skaber en tydelig adskillelse mellem de andre medlemstyper:</p> <ul> <li>Felter</li> <li>Egenskaber</li> <li>Metoder</li> <li>H\u00e6ndelser</li> </ul> <p></p> <p>Yderligere er en h\u00e6ndelse beskyttet af runtime p\u00e5 forskellige m\u00e5der, og det er mulighed at skabe indkapsling med add/remove (i stedet for get/set).</p>"},{"location":"125_Events.html#forskellen-pa-en-ra-delegate-og-en-event","title":"Forskellen p\u00e5 en \u201cr\u00e5\u201d delegate og en event","text":"<pre><code>using System;\nnamespace Demo\n{\nclass Program\n{\nstatic void Main(string[] args)\n{\nEventDelegate ed = new EventDelegate();\ned.DelegateTest += (s, e) =&gt; Console.WriteLine(\"delegate\");\ned.EventTest += (s, e) =&gt; Console.WriteLine(\"event\");\ned.Test();\ned.DelegateTest = null; // Det er ok\n// ed.EventTest = null; // Det m\u00e5 man ikke (man kunne jo \u00f8del\u00e6gge andres abonnering p\u00e5 h\u00e6ndelsen)\n}\n}\nclass EventDelegate\n{\npublic Action&lt;object, EventArgs&gt; DelegateTest;\npublic event Action&lt;object, EventArgs&gt; EventTest;\npublic void Test() {\nDelegateTest?.Invoke(this, new EventArgs());\nEventTest?.Invoke(this, new EventArgs());\n}\n}\n}\n</code></pre> <p>Bem\u00e6rk, at der ikke er meget forskel - men event er en separat medlemstype og er beskyttet af runtime (p\u00e5 flere m\u00e5der).</p>"},{"location":"125_Events.html#event-kodeordet","title":"event-kodeordet","text":"<p>Brug event-kodeordet til at definere en h\u00e6ndelse (delegate)</p> <pre><code>public class EventDemo\n{\npublic event Action Event1;                     // bare en void\npublic event Action&lt;string&gt; Event2;             // void(string)\npublic event Action&lt;object, EventArgs&gt; Event3;  // void(object, EventArgs)\npublic event EventHandler Event4;               // void(object, EventArgs)\n}\n</code></pre> <p>De fleste benytter Microsoft\u2019s System.EventHandler (object, EventArgs) som predefineret delegate:</p> <pre><code>public event EventHandler Event1;\n</code></pre> <p>men det er helt op til dig.</p>"},{"location":"125_Events.html#afvikling-af-metoder","title":"Afvikling af metoder","text":"<p>N\u00e5r man skal afvikle en h\u00e6ndelse i klassen foreg\u00e5r det p\u00e5 samme m\u00e5de som ved delegates (for\u2026 det er jo en delegate). Man benytter typisk Invoke-metoden for nemt at kunne checke for null (se tidligere modul):</p> <pre><code>class Konto\n{\npublic double Saldo { get; private set; }\npublic event EventHandler KontoIMinus;\npublic Konto(double saldo)\n{\nSaldo = saldo;\n}\npublic void Inds\u00e6t(double bel\u00f8b)\n{\nSaldo += bel\u00f8b;\nif (Saldo &lt; 0)\nKontoIMinus?.Invoke(this, new EventArgs());\n}\npublic void Udtr\u00e6k(double bel\u00f8b)\n{\nSaldo -= bel\u00f8b;\nif (Saldo &lt; 0)\nKontoIMinus?.Invoke(this, new EventArgs());\n}\n}\n</code></pre> <p>Hvis man benytter den indbyggede delegate EventHandler er det f\u00f8rste argument typisk det objekt der smider h\u00e6ndelsen, og det andet et tomt objekt af klassen EventArgs eller en af nedarvet klasse.</p> <p>Info</p>"},{"location":"125_Events.html#opgave-125-2","title":"Opgave 125-2","text":"<p>Skab din egen h\u00e6ndelse. (kode til s\u00f8gning: BCFC)</p> <p>Se opgave</p>"},{"location":"125_Events.html#din-egen-eventargs-klasse","title":"Din egen EventArgs-klasse","text":"<p>Du kan eventuelt skabe din egen eventargs-klasse ved at arve fra EventArgs, og s\u00e5 benytte den generiske EventHandler.</p> <p>Bem\u00e6rk forskellen p\u00e5 konto1 og konto2 - b\u00e5de i definition og brug:</p> <pre><code>using System;\nnamespace Demo\n{\nclass Program\n{\nstatic void Main(string[] args)\n{\nKonto1 k1 = new Konto1(10);\nk1.KontoIMinus += (s, e) =&gt; Console.WriteLine(\"MINUS\");\nKonto2 k2 = new Konto2(10);\nk2.KontoIMinus += (s, e) =&gt; Console.WriteLine($\"MINUS med {e.Saldo}\");\nk1.Udtr\u00e6k(20);\nk2.Udtr\u00e6k(20);\n}\n}\nclass Konto1\n{\npublic double Saldo { get; private set; }\npublic event EventHandler KontoIMinus;\npublic Konto1(double saldo)\n{\nSaldo = saldo;\n}\npublic void Inds\u00e6t(double bel\u00f8b)\n{\nSaldo += bel\u00f8b;\nif (Saldo &lt; 0)\nKontoIMinus?.Invoke(this, new EventArgs());\n}\npublic void Udtr\u00e6k(double bel\u00f8b)\n{\nSaldo -= bel\u00f8b;\nif (Saldo &lt; 0)\nKontoIMinus?.Invoke(this, new EventArgs());\n}\n}\nclass Konto2\n{\npublic double Saldo { get; private set; }\npublic event EventHandler&lt;MineEventArgs&gt; KontoIMinus;\npublic Konto2(double saldo)\n{\nSaldo = saldo;\n}\npublic void Inds\u00e6t(double bel\u00f8b)\n{\nSaldo += bel\u00f8b;\nif (Saldo &lt; 0)\nKontoIMinus?.Invoke(this, new MineEventArgs { Saldo = this.Saldo });\n}\npublic void Udtr\u00e6k(double bel\u00f8b)\n{\nSaldo -= bel\u00f8b;\nif (Saldo &lt; 0)\nKontoIMinus?.Invoke(this, new MineEventArgs { Saldo = this.Saldo });\n}\n}\npublic class MineEventArgs : EventArgs\n{\npublic double Saldo { get; set; }\n}\n}\n</code></pre> <p>Info</p>"},{"location":"125_Events.html#opgave-125-3","title":"Opgave 125-3","text":"<p>Skab en h\u00e6ndelse med egen eventargs (kode til s\u00f8gning: BCFD)</p> <p>Se opgave</p>"},{"location":"126_Avancerede_typer.html","title":"Avancerede typer","text":""},{"location":"126_Avancerede_typer.html#om-modulet","title":"Om modulet","text":"<p>Dette modul gennemg\u00e5r nogle af de lidt mere avancerede features relateret til typer.</p>"},{"location":"126_Avancerede_typer.html#records-poster","title":"Records (poster)","text":"<p>I C# 9 blev en feature kaldet records introduceret og den blev udvidet i C# 10. Records giver mulighed for hurtigt og nemt at skabe en immutable v\u00e6rdibaseret- (strukt) eller referencebaseret (klasse) type. En record vil autogenerere en klasse eller struct med f\u00f8lgende medlemmer:</p> <ul> <li>overskrivning af Equals, GetHashCode mv for nem sammenligning</li> <li>overskrivning af == og != operatorerne</li> <li>overskrivning af ToString</li> <li>Evt automatisk generering af felter, egenskaber og konstrukt\u00f8r</li> <li>En deconstruct metode til nedbrydning til variabler</li> </ul> <p>I sin simple syntaks ser en record ud som f\u00f8lger (her en class)</p> <pre><code>public record class Person(string Navn, int Alder);\n// class er default s\u00e5 f\u00f8lgende er det samme\n// public record Person(string Navn, int Alder);\n</code></pre> <p>hvilke autogenererer f\u00f8lgende (se https://sharplab.io/)</p> <pre><code>public class Person : IEquatable&lt;Person&gt;\n{\n[CompilerGenerated]\n[DebuggerBrowsable(DebuggerBrowsableState.Never)]\nprivate readonly string &lt;Navn&gt;k__BackingField;\n[CompilerGenerated]\n[DebuggerBrowsable(DebuggerBrowsableState.Never)]\nprivate readonly int &lt;Alder&gt;k__BackingField;\n[System.Runtime.CompilerServices.Nullable(1)]\nprotected virtual Type EqualityContract\n{\n[System.Runtime.CompilerServices.NullableContext(1)]\n[CompilerGenerated]\nget\n{\nreturn typeof(Person);\n}\n}\npublic string Navn\n{\n[CompilerGenerated]\nget\n{\nreturn &lt;Navn&gt;k__BackingField;\n}\n[CompilerGenerated]\ninit\n{\n&lt;Navn&gt;k__BackingField = value;\n}\n}\npublic int Alder\n{\n[CompilerGenerated]\nget\n{\nreturn &lt;Alder&gt;k__BackingField;\n}\n[CompilerGenerated]\ninit\n{\n&lt;Alder&gt;k__BackingField = value;\n}\n}\npublic Person(string Navn, int Alder)\n{\n&lt;Navn&gt;k__BackingField = Navn;\n&lt;Alder&gt;k__BackingField = Alder;\nbase..ctor();\n}\n[System.Runtime.CompilerServices.NullableContext(1)]\npublic override string ToString()\n{\nStringBuilder stringBuilder = new StringBuilder();\nstringBuilder.Append(\"Person\");\nstringBuilder.Append(\" { \");\nif (PrintMembers(stringBuilder))\n{\nstringBuilder.Append(' ');\n}\nstringBuilder.Append('}');\nreturn stringBuilder.ToString();\n}\n[System.Runtime.CompilerServices.NullableContext(1)]\nprotected virtual bool PrintMembers(StringBuilder builder)\n{\nRuntimeHelpers.EnsureSufficientExecutionStack();\nbuilder.Append(\"Navn = \");\nbuilder.Append((object)Navn);\nbuilder.Append(\", Alder = \");\nbuilder.Append(Alder.ToString());\nreturn true;\n}\n[System.Runtime.CompilerServices.NullableContext(2)]\npublic static bool operator !=(Person left, Person right)\n{\nreturn !(left == right);\n}\n[System.Runtime.CompilerServices.NullableContext(2)]\npublic static bool operator ==(Person left, Person right)\n{\nreturn (object)left == right || ((object)left != null &amp;&amp; left.Equals(right));\n}\npublic override int GetHashCode()\n{\nreturn (EqualityComparer&lt;Type&gt;.Default.GetHashCode(EqualityContract) * -1521134295 + EqualityComparer&lt;string&gt;.Default.GetHashCode(&lt;Navn&gt;k__BackingField)) * -1521134295 + EqualityComparer&lt;int&gt;.Default.GetHashCode(&lt;Alder&gt;k__BackingField);\n}\n[System.Runtime.CompilerServices.NullableContext(2)]\npublic override bool Equals(object obj)\n{\nreturn Equals(obj as Person);\n}\n[System.Runtime.CompilerServices.NullableContext(2)]\npublic virtual bool Equals(Person other)\n{\nreturn (object)this == other || ((object)other != null &amp;&amp; EqualityContract == other.EqualityContract &amp;&amp; EqualityComparer&lt;string&gt;.Default.Equals(&lt;Navn&gt;k__BackingField, other.&lt;Navn&gt;k__BackingField) &amp;&amp; EqualityComparer&lt;int&gt;.Default.Equals(&lt;Alder&gt;k__BackingField, other.&lt;Alder&gt;k__BackingField));\n}\n[System.Runtime.CompilerServices.NullableContext(1)]\npublic virtual Person &lt;Clone&gt;$()\n{\nreturn new Person(this);\n}\nprotected Person([System.Runtime.CompilerServices.Nullable(1)] Person original)\n{\n&lt;Navn&gt;k__BackingField = original.&lt;Navn&gt;k__BackingField;\n&lt;Alder&gt;k__BackingField = original.&lt;Alder&gt;k__BackingField;\n}\npublic void Deconstruct(out string Navn, out int Alder)\n{\nNavn = this.Navn;\nAlder = this.Alder;\n}\n}\n</code></pre> <p>Det g\u00f8r det muligt at benytte klassen som en immutable datatype</p> <pre><code>Person p1 = new Person(\"a\", 11);\nConsole.WriteLine(p1);\n// Person { Navn = a, Alder = 11 }\nPerson p2 = p1;\nConsole.WriteLine(p2);\n// Person { Name = a, Alder = 11 }\nPerson p3 = p1 with\n{\nAlder = 12\n};\nConsole.WriteLine(p3);\n// Person { Name = a, Alder = 12 }\nPerson p4 = new Person(\"b\", 15);\n// Sammenligner v\u00e6rdier!!\nConsole.WriteLine(p3==p4);  // false\n// Deconstruct\n(var n, var a) = p4;\nConsole.WriteLine(n);   // b\nConsole.WriteLine(a);   // 15\n</code></pre> <p>samme er muligt hvis man \u00f8nsker en stuct i stedet for en klasse:</p> <pre><code>public record struct Person(string Navn, int Alder);\n</code></pre> <p>hvilket skabe samme medlemmen - men nu som en struct.</p>"},{"location":"126_Avancerede_typer.html#tilretning-af-record","title":"Tilretning af record","text":"<p>Den hurtige syntaks kan afl\u00f8se af lidt mere kode men ogs\u00e5 mere styring - her er eksempelvis en default konstrukt\u00f8r</p> <pre><code>public record class Person(string Navn, int Alder)\n{\npublic string? Land { get; init; }\npublic void Skriv() {\nConsole.WriteLine($\"Jeg hedder {Navn}, er fra {Land}, og er {Alder} \u00e5r gammel\");\n}\n}\n</code></pre> <p>som kan bruges som</p> <pre><code>Person person = new Person(\"a\", 10) { Land = \"DK\" };\nConsole.WriteLine(person);\nperson.Skriv();\n</code></pre>"},{"location":"126_Avancerede_typer.html#brug-af-with-til-kopi","title":"Brug af with til kopi","text":"<p>For nemt at skabe en ny instans kan with-kodeordet benyttes</p> <pre><code>Person person1 = new Person(\"a\", 10, \"DK\")\nPerson person2 = person1 with { Navn = \"b\" };\n// person2 == person1 bortset fra navn\n</code></pre> <p>Info</p>"},{"location":"126_Avancerede_typer.html#opgave-126-1","title":"Opgave 126-1","text":"<p>Brug af en record (class) (kode til s\u00f8gning: BCGB)</p> <p>Se opgave</p>"},{"location":"126_Avancerede_typer.html#nullable-typer","title":"Nullable typer","text":"<p>Mulighed for at v\u00e6rdibaserede variabler kan f\u00e5 v\u00e6rdien null</p> <ul> <li>Nullable\\&lt;T&gt;<ul> <li>Bem\u00e6rk at Nullable\\&lt;T&gt; er en struct</li> </ul> </li> <li>Brug af ? ved erkl\u00e6ring</li> <li>Brugt en del til at tilf\u00f8je \u201cuinitialiseret\u201d til alle structs</li> <li>Brugt en del i ORM produkter til at mappe en database tabel</li> <li>Bem\u00e6rk - C# 8 har ogs\u00e5 en nullable reference (string?), men det er noget helt andet!</li> </ul> <pre><code>{\nNullable&lt;int&gt; a = new Nullable&lt;int&gt;();\na = 10;\nConsole.WriteLine(a);                       // 10\nConsole.WriteLine(a.HasValue);              // true\nConsole.WriteLine(a.GetValueOrDefault());   // 10\nConsole.WriteLine(a is null);               // false\nConsole.WriteLine(a == null);               // false\na = null;\nConsole.WriteLine(a.HasValue);              // false\nConsole.WriteLine(a.GetValueOrDefault());   // 0\nConsole.WriteLine(a.GetValueOrDefault(20)); // 20\nConsole.WriteLine(a is null);               // true\nConsole.WriteLine(a == null);               // true\n}\n{\nint? a;\na = 10;\nConsole.WriteLine(a);                       // 10\nConsole.WriteLine(a.HasValue);              // true\nConsole.WriteLine(a.GetValueOrDefault());   // 10\nConsole.WriteLine(a is null);               // false\nConsole.WriteLine(a == null);               // false\na = null;\nConsole.WriteLine(a.HasValue);              // false\nConsole.WriteLine(a.GetValueOrDefault());   // 0\nConsole.WriteLine(a.GetValueOrDefault(20)); // 20\nConsole.WriteLine(a is null);               // true\nConsole.WriteLine(a == null);               // true\n}\n</code></pre> <p>Er egentlig implementeret som</p> <pre><code>public struct Nullable&lt;T&gt; where T : struct\n{\npublic Nullable(T value);\npublic bool HasValue { get; }\npublic T Value { get; }\npublic T GetValueOrDefault();\npublic T GetValueOrDefault(T defaultValue);\n// ...\n}\n</code></pre> <p>Info</p>"},{"location":"126_Avancerede_typer.html#opgave-126-2","title":"Opgave 126-2","text":"<p>Skab simple metoder/typer der benytter nullable variabler (kode til s\u00f8gning: BCGC)</p> <p>Se opgave</p>"},{"location":"126_Avancerede_typer.html#tuples","title":"Tuples","text":"<p>Generisk datastruktur som is\u00e6r kan bruges til at returnere data fra en funktioner uden at angive en type, som argumeter eller som en midlertidig datatype.</p> <p>Der findes i version 8 to muligheder.</p> <ul> <li>System.Tuple (class - immutable)</li> <li>System.ValueTuple (struct - mutable)</li> </ul> <pre><code>var a = (1, 1);\nConsole.WriteLine(a.GetType()); // System.ValueTuple\nSystem.Tuple&lt;int, int&gt; b = new Tuple&lt;int, int&gt;(1, 1);\nConsole.WriteLine(b.GetType()); // System.Tuple\nSystem.Tuple&lt;int, int&gt; c = Tuple.Create(1, 1);\nConsole.WriteLine(c.GetType()); // System.Tuple\nvar d = (nr1: 1, nr2: 2);\nConsole.WriteLine(d.GetType()); // System.ValueTuple\nSystem.ValueTuple&lt;int, int&gt; e = ValueTuple.Create(1, 1);\nConsole.WriteLine(e);   // (1, 1)\n// Immutable - Mutable\nTuple&lt;int, int&gt; aa = new Tuple&lt;int, int&gt;(2, 2);\n// aa.Item1 = 1;\nValueTuple&lt;int, int&gt; bb = ValueTuple.Create(2, 2);\nbb.Item1 = 1;\n</code></pre> <p>Bruges som n\u00e6vnt blandt i metodekald og returv\u00e6rdier:</p> <pre><code>using System;\nusing System.Collections.Generic;\nusing System.Threading.Tasks;\nnamespace Demo\n{\nclass Program\n{\nstatic async Task Main(string[] args)\n{\nvar res1 = Test1((\"a\", \"b\"));\nif (res1.Item2)\n{\nConsole.WriteLine(res1.Item1);\n}\n//var res2 = Test2((\"a\", \"b\"));\n// Eller...\nvar res2 = Test2(ValueTuple.Create&lt;string, string&gt;(\"a\", \"b\"));\nif (res2.succes)\n{\nConsole.WriteLine(res2.l\u00e6ngde);\n}\n}\nstatic (int, bool) Test1((string, string) v)\n{\nif (string.IsNullOrEmpty(v.Item1) || string.IsNullOrEmpty(v.Item2))\nreturn (0, false);\nelse\nreturn (v.Item1.Length + v.Item2.Length, true);\n}\nstatic (int l\u00e6ngde, bool succes) Test2((string txt1, string txt2) v)\n{\nif (string.IsNullOrEmpty(v.txt1) || string.IsNullOrEmpty(v.txt1))\nreturn (0, false);\nelse\nreturn (v.txt1.Length + v.txt2.Length, true);\n}\n}\n}\n</code></pre> <p>Info</p>"},{"location":"126_Avancerede_typer.html#opgave-126-3","title":"Opgave 126-3","text":"<p>Skab en metoder der returnerer flere v\u00e6rdier uden en type definition. (kode til s\u00f8gning: BCGD)</p> <p>Se opgave</p>"},{"location":"126_Avancerede_typer.html#nedbrydning","title":"Nedbrydning","text":"<p>Tuples ses tit i forbindelse nedbrydning til enkelte variabler:</p> <pre><code>// Definering af Tuple (kunne ogs\u00e5 v\u00e6re returv\u00e6rdi fra metode)\nvar a = (navn: \"Mikkel\", alder: 16);\nvar (navn1, alder1) = a;\n(string navn2, int alder2) = a;\n// Kun alder eller navn\nvar (_, alder3) = a;\n(string navn3, _) = a;\n</code></pre> <p>Ved egne klasser kan du selv skabe en Deconstruct:</p> <pre><code>class Person\n{\npublic string Navn { get; set; }\npublic int Alder { get; set; }\npublic bool ErDansk { get; set; }\npublic void Deconstruct(out string navn,\nout int alder, out bool erDansk)\n{\nnavn = Navn;\nalder = Alder;\nerDansk = ErDansk;\n}\n}\n</code></pre> <p>Metoden benytter out-argumenter som betyder, at der sendes en reference med til variablen og ikke selve v\u00e6rdien. Derfor kan metoden tildele argumenterne en v\u00e6rdi.</p> <p>Nu kan der foretages en nedbrydning:</p> <pre><code>Person p = new Person\n{\nNavn = \"Mathias\",\nAlder = 14,\nErDansk = true\n};\nConsole.WriteLine(p.Navn);      // Mathias\nConsole.WriteLine(p.Alder);     // 14\nConsole.WriteLine(p.ErDansk);   // true\n// Nedbrydning\n(var navn, var alder, var erDansk) = p;\nConsole.WriteLine(navn);        // Mathias\nConsole.WriteLine(alder);       // 14\nConsole.WriteLine(erDansk);     // true\n</code></pre> <p>Metoden kan ogs\u00e5 overloades</p> <pre><code>class Person\n{\npublic string Navn { get; set; }\npublic int Alder { get; set; }\npublic bool ErDansk { get; set; }\npublic void Deconstruct(out string navn, out int alder,\nout bool erDansk)\n{\nnavn = Navn;\nalder = Alder;\nerDansk = ErDansk;\n}\npublic void Deconstruct(out string navn, out int alder)\n{\nnavn = Navn;\nalder = Alder;\n}\n}\n</code></pre>"},{"location":"126_Avancerede_typer.html#discards","title":"Discards","text":"<p>Ved nedbrydning er der nogle gange ikke behov for variabler, og her kan discards (_) benyttes til at fort\u00e6lle udvikler og kompiler at en v\u00e6rdi ignoreres:</p> <pre><code>namespace Demo\n{\ninternal class Program\n{\nstatic void Main(string[] args)\n{\nPerson person = new Person() { Navn = \"a\", Alder = 10, ErDansk = true };\n(var navn, var alder, var erDansk1) = person;\n(_, _, var erDansk2) = person;\nConsole.WriteLine(erDansk2);\n}\n}\nclass Person\n{\npublic string? Navn { get; set; }\npublic int Alder { get; set; }\npublic bool ErDansk { get; set; }\npublic void Deconstruct(out string? navn, out int alder,\nout bool erDansk)\n{\nnavn = Navn;\nalder = Alder;\nerDansk = ErDansk;\n}\n}\n}\n</code></pre>"},{"location":"126_Avancerede_typer.html#using","title":"using","text":"<ul> <li>using vil automatisk k\u00f8re dispose</li> </ul> <pre><code>using (Oprydning.C c = new Oprydning.C())\n{\n}\n</code></pre> <ul> <li>Du kan forvente, at Dispose rydder rigtig op (lukker forbindelser mv)</li> </ul> <p>Bem\u00e6rk - der er kommet en ny syntaks til using uden definitiation af scope. Nu lever using i det scope det er oprettet.</p> <pre><code>static async Task Main(string[] args)\n{\nusing HttpClient client = new HttpClient();\n// kode..\n// kode..\n// kode..\n}\n</code></pre> <p>Info</p>"},{"location":"126_Avancerede_typer.html#opgave-126-4","title":"Opgave 126-4","text":"<p>\u00d8v dig p\u00e5 Dispose-m\u00f8nsteret (kode til s\u00f8gning: BCGE)</p> <p>Se opgave</p>"},{"location":"126_Avancerede_typer.html#mutable-og-immutable-data","title":"Mutable og Immutable data","text":"<p>\u201cIn object-oriented and functional programming, an immutable (unchangeable) object is an object whose state cannot be modified after it is created. This is in contrast to a mutable (changeable) object, which can be modified after it is created.\u201d WikiPedia</p> <pre><code>// Hvorfor er value types immutable ;)\n5++;    // PS - kan ikke kompilere\nConsole.WriteLine(5);\n</code></pre> <p>Mange struct\u2019s i frameworket er immutable</p> <pre><code>DateTime d = new DateTime(2019, 1, 1);\nConsole.WriteLine(d);   // 2019-1-1\nd.AddDays(1);\nConsole.WriteLine(d);   // 2019-1-1\nd = d.AddDays(1);\nConsole.WriteLine(d);   // 2019-1-2\n</code></pre> <p>men det er et sp\u00f8rgsm\u00e5l om implementation:</p> <pre><code>struct MutableStruct\n{\nprivate int state;\npublic MutableStruct(int state) { this.state = state; }\npublic void ChangeState() { this.state++; }\n}\nstruct ImmutableStruct\n{\nprivate readonly int state;\npublic ImmutableStruct(int state) { this.state = state; }\npublic ImmutableStruct ChangeState()\n{\nreturn new ImmutableStruct(this.state + 1);\n}\n}\n</code></pre> <p>Det klassiske eksempel er System.String (immutable) og System.Text.StringBuilder (mutable).</p>"},{"location":"126_Avancerede_typer.html#immutable-klasser","title":"Immutable klasser","text":"<p>Men kan relativt nemt skabe immutable klasser ved at indkapsle felter.</p> <pre><code>using System;\nusing System.Threading.Tasks;\nnamespace Demo\n{\nclass Program\n{\nstatic async Task Main(string[] args)\n{\nPersonMutable a = new PersonMutable(\"a\", 10);\nConsole.WriteLine(a.Alder);\nTest(a);\nConsole.WriteLine(a.Alder);\nPersonImutable b = new PersonImutable(\"a\", 10);\nConsole.WriteLine(b.Alder);\nTest(b);\nConsole.WriteLine(b.Alder);\n}\nstatic void Test(PersonMutable p)\n{\np.Alder = 100;\n}\nstatic void Test(PersonImutable p)\n{\n// p.Alder = 100; -- fejl\n}\n}\nclass PersonMutable\n{\npublic string Navn { get; set; }\npublic int Alder { get; set; }\npublic PersonMutable(string navn, int alder)\n{\nthis.Navn = navn;\nthis.Alder = alder;\n}\n}\nclass PersonImutable\n{\npublic string Navn { get; private set; }\npublic int Alder { get; private set; }\npublic PersonImutable(string navn, int alder)\n{\nthis.Navn = navn;\nthis.Alder = alder;\n}\n}\n}\n</code></pre>"},{"location":"126_Avancerede_typer.html#immutable-collections","title":"Immutable collections","text":"<p>MS har en NuGet pakke som kan bruges til at implementere immutable collections - System.Collections.Immutable.</p> <pre><code>List&lt;int&gt; lst = new List&lt;int&gt;();\nlst.Add(1);\nlst.Add(2);\n// ImmutableList&lt;int&gt; iLst = ImmutableList.CreateRange(lst);\nImmutableList&lt;int&gt; iLst = lst.ToImmutableList();\niLst = iLst.Add(3);\n// ----------------------------\n// read only er noget helt andet\nIReadOnlyCollection&lt;int&gt; rLst = lst;\nConsole.WriteLine(string.Join(' ', rLst));  // 1 2\nlst.Add(5);\nConsole.WriteLine(string.Join(' ', rLst));  // 1 2 5\nList&lt;int&gt; tmp = (List&lt;int&gt;)rLst;\ntmp.Add(6);\nConsole.WriteLine(string.Join(' ', tmp));  // 1 2 5 6\n</code></pre>"},{"location":"126_Avancerede_typer.html#dynamic","title":"dynamic","text":"<p>Brugt til</p> <ul> <li>Anonyme typer</li> <li>COM (Gamle Office-versioner feks.), unmanaged code</li> </ul> <pre><code>  dynamic i = 1;\nConsole.WriteLine($\"{i} {i.GetType()}\" );\ni = \"a\";\nConsole.WriteLine($\"{i} {i.GetType()}\");\ni = true;\nConsole.WriteLine($\"{i} {i.GetType()}\");\n/*\n ---------- Output: ----------\n1 System.Int32\na System.String\nTrue System.Boolean\n*/\n</code></pre> <p>DynamicObject</p> <ul> <li>oprettelse af et objekt p\u00e5 runtime</li> <li>masse metoder til overskrivning</li> </ul> <pre><code>using System.Collections.Generic;\nusing System.Dynamic;\nnamespace Dynamic\n{\npublic class MitObjekt : DynamicObject\n{\nDictionary&lt;string, object&gt; properties = new Dictionary&lt;string, object&gt;();\npublic override bool TryGetMember(GetMemberBinder binder, out object result)\n{\nif (properties.ContainsKey(binder.Name))\n{\nresult = properties[binder.Name];\nreturn true;\n}\nelse\n{\nresult = \"Forkert egenskab\";\nreturn false;\n}\n}\npublic override bool TrySetMember(SetMemberBinder binder, object value)\n{\nproperties[binder.Name] = value;\nreturn true;\n}\n}\n}\n</code></pre> <pre><code>dynamic o = new MitObjekt();\no.navn = \"x\";\no.alder = 2;\nConsole.WriteLine(o.navn);\n/*\n ---------- Output: ----------\nx\n*/\n</code></pre>"},{"location":"126_Avancerede_typer.html#forskel-pa-var-og-dynamic","title":"Forskel p\u00e5 var og dynamic","text":"<ul> <li>var lader compiler finde type<ul> <li>m\u00e5 aldrig \u00e6ndre type bagefter</li> </ul> </li> <li>dynamic har ingen typecheck<ul> <li>m\u00e5 godt \u00e6ndre type</li> </ul> </li> </ul>"},{"location":"126_Avancerede_typer.html#anonyme-typer","title":"Anonyme typer","text":"<ul> <li>Anonyme typer giver mulighed for at skabe typer uden en skabelon (class/struct)</li> <li>Benyttes meget ifbm med LINQ</li> <li>Simple \u201cklassel\u00f8se\u201d datastrukturer<ul> <li>felter er readonly</li> <li>er sealed</li> <li>ingen metoder mv</li> </ul> </li> </ul> <pre><code>// tomt objekt\nvar a = new { };\n// datastruktur\ndynamic b = new { navn = \"a\", id = 2 };\n// evt som argument (kr\u00e6ver dynamic)\nTest(b);\n// LINQ\nvar col = new List&lt;Person&gt;() {\nnew Person() { Id = 1, Navn = \"a\", Alder = 10 },\nnew Person() { Id = 2, Navn = \"b\", Alder = 11 }\n};\nvar res = col.Where(i =&gt; i.Alder &gt; 10).Select(i =&gt; new { n = i.Navn, i = i.Id });\nforeach (var item in res)\nConsole.WriteLine(item.i);\nvoid Test(dynamic s)\n{\nConsole.WriteLine(s.id);    // ingen intellisense\n// Console.WriteLine(s.ip);    // fejl\n}\n/*\n ---------- Output: ----------\n2\n2\n*/\n</code></pre> <p>Andet eksempel</p> <pre><code>// tomt objekt\nvar a = new { };\n// datastruktur\nvar b = new { navn = \"a\", id = 2 };\n</code></pre> <pre><code>// Skab en liste af filer i en mappe vi kan lege med\nvar mappe = new System.IO.DirectoryInfo(@\"c:\\temp\");\nvar filer = mappe.GetFiles(\"*.*\", System.IO.SearchOption.AllDirectories);\nConsole.WriteLine($\"Har fundet {filer.Length} i {mappe.Name}\");\nvar res1 = filer.Where(i =&gt; i.Extension == \".cs\").Select(i =&gt; new { Navn = i.Name, L\u00e6ngde = i.Length });\n// nu er res1 en liste af \"anonyme\" objekter uden en klasse definition\nforeach (var item in res1)\nConsole.WriteLine($\"{item.Navn} - {item.L\u00e6ngde}\");\n</code></pre>"},{"location":"126_Avancerede_typer.html#expandoobject","title":"ExpandoObject","text":"<ul> <li>oprettelse af et objekt p\u00e5 runtime</li> <li>typisk relateret til MVC (anonym model feks)</li> <li>kan oprettes p\u00e5 runtime</li> </ul> <pre><code>dynamic o = new ExpandoObject();\no.navn = \"x\";\no.alder = 2;\nConsole.WriteLine(o.navn);\n/*\n ---------- Output: ----------\nx\n*/\n</code></pre> <p>Se Dynamic in C# 4.0: Introducing the ExpandoObject</p> <p>Info</p>"},{"location":"126_Avancerede_typer.html#opgave-126-5","title":"Opgave 126-5","text":"<p>Leg med b\u00e5de anonyme objekter og Expando-klassen (kode til s\u00f8gning: BCGF)</p> <p>Se opgave</p>"},{"location":"128_OperatorOverload.html","title":"Operator overload","text":""},{"location":"128_OperatorOverload.html#om-modulet","title":"Om modulet","text":"<p>Dette modul vil introducere dig til operator overload s\u00e5ledes, at du kan benytte de gense operatorer til dine egne typer.</p>"},{"location":"128_OperatorOverload.html#ny-funktionalitet-til-operatorer","title":"Ny funktionalitet til operatorer","text":"<ul> <li>Mulighed for at overloaded operatorer til at virke p\u00e5 egne typer</li> <li>Skal typisk overloades i par (&gt; og &lt; eller = og !=)</li> <li>Benytter operator-kodeordet</li> <li>Skal v\u00e6re statiske</li> </ul>"},{"location":"128_OperatorOverload.html#standard-operatorer","title":"Standard operatorer","text":"<ul> <li>F\u00f8lgende kan overloades</li> <li>+, -, !, ~, ++, \u2013, true, false</li> <li>==, !=, &lt;, &gt;, &lt;=, &gt;=</li> <li>&amp;&amp;, ||</li> <li>+=, -=, *=, /=, %=, &amp;=, |=, ^=, &lt;&lt;=, &gt;&gt;=</li> </ul> <pre><code>using System;\nusing System.Collections.Generic;\nusing System.Text;\nnamespace Operator\n{\nclass Person\n{\npublic int Alder { get; set; }\npublic string Navn { get; set; }\npublic static bool operator &gt;(Person p1, Person p2)\n{\nif (p1.Alder &gt; p2.Alder)\nreturn true;\nreturn false;\n}\npublic static bool operator &lt;(Person p1, Person p2)\n{\nif (p1.Alder &lt; p2.Alder)\nreturn true;\nreturn false;\n}\npublic static bool operator ==(Person p1, Person p2) =&gt; (p1.Alder == p2.Alder) &amp;&amp; (p1.Navn == p2.Navn);\npublic static bool operator !=(Person p1, Person p2)\n=&gt; !(p1 == p2);\n}\n}\n</code></pre> <pre><code>Operator.Person p1 = new Operator.Person() { Alder = 10, Navn = \"a\" };\nOperator.Person p2 = new Operator.Person() { Alder = 20, Navn = \"b\" };\nConsole.WriteLine($\"p1&gt;p2: {p1 &gt; p2}\");\nConsole.WriteLine($\"p1&lt;p2: {p1 &lt; p2}\");\nConsole.WriteLine($\"p1==p2: {p1 == p2}\");\nConsole.WriteLine($\"p1!=p2: {p1 != p2}\");\n/*\n ---------- Output: ----------\np1&gt;p2: False\np1&lt;p2: True\np1==p2: False\np1!=p2: True\n*/\n</code></pre> <p>Info</p>"},{"location":"128_OperatorOverload.html#opgave-128-1","title":"Opgave 128-1","text":"<p>Brug operator overload til at finde ud af om en hund &gt; end en anden hund (kode til s\u00f8gning: BCIB)</p> <p>Se opgave</p>"},{"location":"128_OperatorOverload.html#implicit-operator","title":"Implicit operator","text":"<p>Kan benytte en implicit operator til at skabe egne datatyper</p> <pre><code>- Skal v\u00e6re statisk\n- Tildelingstypen og returneringstypen styres i syntaks\n</code></pre> <pre><code>class Hund {\npublic string  Navn { get; set; }\npublic static implicit operator string(Hund n)\n{\nreturn n.Navn;\n}\npublic static implicit operator Hund(string n)\n{\nreturn new Hund() { Navn = n };\n}\n}\n</code></pre> <pre><code>Hund h = new Hund();\nh = \"Fido\";\nConsole.WriteLine(h);\nh = \"Bruno\";\nConsole.WriteLine(h);\n</code></pre> <p>Info</p>"},{"location":"128_OperatorOverload.html#opgave-128-2","title":"Opgave 128-2","text":"<p>Tilf\u00f8j en ny datatype (Nibble) til C# og overload operatorer (kode til s\u00f8gning: BCIC)</p> <p>Se opgave</p>"},{"location":"130_Generics.html","title":"Generiske typer og medlemmer","text":""},{"location":"130_Generics.html#om-modulet","title":"Om modulet","text":"<p>I dette modul vil du l\u00e6re at oprette og benytte dine egne generiske typer.</p>"},{"location":"130_Generics.html#generics","title":"Generics","text":"<ul> <li>Der er en masse indbyggede typer og metoder der benytter generics</li> <li>System.Collections.Genetic</li> <li>LINQ</li> <li>Meget mere</li> <li>Generics er overordet en template for en type der erstattes p\u00e5 compile time</li> <li>Typisk set som typen T</li> <li>Slipper for at typekonvertere til og fra Object</li> <li>Kan oprette egne interfaces, klasser, metoder, h\u00e6ndelser og delegates</li> </ul> <pre><code>var lst1 = new List&lt;string&gt;();\nlst1.Add(\"a\");\nlst1.Add(\"b\");\n// lst1.Add(3); // fejl \nvar lst2 = new Stack&lt;Faktura&gt;();\nlst2.Push(new Faktura() { Id = 1 });\nlst2.Push(new Faktura() { Id = 2 });\n// lst2.Push(\"\");  // fejl\n</code></pre>"},{"location":"130_Generics.html#udvikling-af-egne-metoder","title":"Udvikling af egne metoder","text":"<ul> <li>Klassiske eksempler</li> </ul> <pre><code>int a = 10;\nint b = 20;\n// Beh\u00f8ver ikke Swap&lt;int&gt; - Swap() er ok\nSwap&lt;int&gt;(ref a, ref b);\nConsole.WriteLine($\"a={a} b={b}\");\nstring c = \"a\";\nstring d = \"b\";\n// Beh\u00f8ver ikke Swap&lt;string&gt;\nSwap(ref c, ref d);\nConsole.WriteLine($\"c={c} d={d}\");\nFaktura e = new Faktura() { Id = 1 };\nFaktura f = new Faktura() { Id = 2 };\nSwap(ref e, ref f);\nConsole.WriteLine($\"e={e.Id} f={f.Id}\");\nvoid Swap&lt;T&gt;(ref T t1, ref T t2)\n{\nT tmp = t1;\nt1 = t2;\nt2 = tmp;\n}\nvar lst1 = new List&lt;int&gt;();\nAddToCollection&lt;int&gt;(1, lst1);\nAddToCollection(1, lst1);\nConsole.WriteLine($\"Elementer i lst1; {lst1.Count}\");\nvar lst2 = new List&lt;Faktura&gt;();\nAddToCollection&lt;Faktura&gt;(new Faktura(), lst2);\nAddToCollection&lt;Faktura&gt;(new Faktura(), lst2);\nAddToCollection&lt;Faktura&gt;(new Faktura(), lst2);\nConsole.WriteLine($\"Elementer i lst2; {lst2.Count}\");\nvoid AddToCollection&lt;T&gt;(T item, List&lt;T&gt; collection) {\n// log+sikkerhed\ncollection.Add(item);\n}\n/*\n ---------- Output: ----------\na=20 b=10\nc=b d=a\ne=2 f=1\nElementer i lst1; 2\nElementer i lst2; 3\n*/\n</code></pre>"},{"location":"130_Generics.html#constrains-og-default","title":"Constrains og default","text":"<ul> <li> <p>Kan styre typen T p\u00e5 forskellig vis</p> </li> <li> <p>where T : struct</p> </li> <li>where T : class</li> <li>where T : unmanaged</li> <li>where T : new() (skal have en default constructor)</li> <li>where T : \\&lt;base class&gt;</li> <li> <p>where T : \\&lt;interface&gt;</p> </li> <li> <p>Kodeordet default kan finde default v\u00e6rdien</p> </li> </ul> <pre><code>var lst1 = new List&lt;Faktura&gt;();\nAddToCollection&lt;Faktura&gt;(new Faktura(), lst1);\nAddToCollection&lt;Faktura&gt;(new Faktura(), lst1);\nAddToCollection&lt;Faktura&gt;(new Faktura(), lst1);\nAddToCollection2&lt;Faktura&gt;(new Faktura(), lst1);\nAddToCollection3&lt;Faktura&gt;(new Faktura(), lst1);\nConsole.WriteLine($\"Elementer i lst1; {lst1.Count}\");\nvar lst2 = new List&lt;int&gt;();\n//AddToCollection&lt;Faktura&gt;(2, lst2);  // fejl\nvoid AddToCollection&lt;T&gt;(T item, List&lt;T&gt; collection)  where T : Faktura\n{\n// log+sikkerhed\ncollection.Add(item);\n}\nvoid AddToCollection2&lt;T&gt;(T item, List&lt;T&gt; collection) where T : class\n{\n// log+sikkerhed\ncollection.Add(item);\n}\n// Skal have en default constructor\nvoid AddToCollection3&lt;T&gt;(T item, List&lt;T&gt; collection) where T : new()\n{\n// log+sikkerhed\ncollection.Add(item);\n}\nint[] lst3 = { 1, 2, 8, 1, 7, 1, 12, 3, 6 };\nint res = FindSt\u00f8rsteV\u00e6rdi&lt;int&gt;(lst3);\nConsole.WriteLine($\"St\u00f8rste v\u00e6rdi i lst3: {res}\");\nstring[] lst4 = { \"a\", \"y\", \"b\" };\nstring res2 = FindSt\u00f8rsteV\u00e6rdi&lt;string&gt;(lst4);\nConsole.WriteLine($\"St\u00f8rste v\u00e6rdi i lst4: {res2}\");\nT FindSt\u00f8rsteV\u00e6rdi&lt;T&gt;(T[] andre) where T : IComparable\n{\n// Bem\u00e6rk - default v\u00e6rdi\nT i = default(T);\nConsole.WriteLine($\"Default v\u00e6rdi: {i}\");\nforeach (var item in andre)\n{\nif (item.CompareTo(i) &gt; 0)\ni = item;\n}\nreturn i;\n}\n/*\n ---------- Output: ----------\nElementer i lst1; 5\nDefault v\u00e6rdi: 0\nSt\u00f8rste v\u00e6rdi i lst3: 12\nDefault v\u00e6rdi: \nSt\u00f8rste v\u00e6rdi i lst4: y\n*/\n</code></pre> <p>Info</p> <p>Info</p>"},{"location":"130_Generics.html#opgave-130-1","title":"Opgave 130-1","text":"<p>Simpel brug af en generisk metode (kode til s\u00f8gning: BDAB)</p> <p>Se opgave</p>"},{"location":"130_Generics.html#opgave-130-2","title":"Opgave 130-2","text":"<p>Skab en generisk metode der kan benytte af typer der implementerer IComparable (kode til s\u00f8gning: BDAC)</p> <p>Se opgave</p>"},{"location":"130_Generics.html#generiske-typer","title":"Generiske typer","text":"<ul> <li>Du kan ogs\u00e5 skabe egne generiske strukturer og klasser</li> </ul> <pre><code>using System;\nusing System.Collections.Generic;\nusing System.Text;\nnamespace GenericsDemo\n{\nstruct Point&lt;T&gt;\n{\nT x;\nT y;\npublic Point(T x, T y) {\nthis.x = x;\nthis.y = y;\n}\npublic T X { get { return this.x; } }\npublic T Y { get { return this.y; } }\n}\nclass Garage&lt;T&gt; where T : Bil {\nprivate List&lt;T&gt; biler = new List&lt;T&gt;();\npublic void S\u00e6tBilIGarage(T bil) {\nbiler.Add(bil);\n}\npublic List&lt;T&gt; HentBiler() {\nreturn this.biler;\n}\n}\nclass Bil {\npublic string Model { get; set; }\n}\nclass Sportvogn : Bil {\n// ...\n}\n}\n</code></pre> <pre><code>GenericsDemo.Point&lt;int&gt; p1 = new GenericsDemo.Point&lt;int&gt;(1, 2);\nGenericsDemo.Point&lt;double&gt; p2 = new GenericsDemo.Point&lt;double&gt;(1.3, 2.4);\nGenericsDemo.Garage&lt;GenericsDemo.Bil&gt; garage = new GenericsDemo.Garage&lt;GenericsDemo.Bil&gt;();\nGenericsDemo.Sportvogn b1 = new GenericsDemo.Sportvogn();\ngarage.S\u00e6tBilIGarage(b1);\n</code></pre> <p>Info</p> <p>Info</p>"},{"location":"130_Generics.html#opgave-130-3","title":"Opgave 130-3","text":"<p>Skab din egen generiske klasse (kode til s\u00f8gning: BDAD)</p> <p>Se opgave</p>"},{"location":"130_Generics.html#opgave-130-4","title":"Opgave 130-4","text":"<p>Skab et generisk b\u00e6ger til terninger (kode til s\u00f8gning: BDAE)</p> <p>Se opgave</p>"},{"location":"150_LINQ2Objects.html","title":"LINQ to Objects","text":""},{"location":"150_LINQ2Objects.html#om-modulet","title":"Om modulet","text":"<p>I dette model skal vi arbejde med LINQ (Language INtegrated Query), som er en af de mest geniale features i .NET. Det giver mulighed for at iterere, filtere, sortere og gruppere samlinger (lister, arrays med videre) af objekter i hukommelsen.</p> <p>Det er typisk sv\u00e6rt for begyndere at forst\u00e5 LINQ fordi det kr\u00e6ver en grundl\u00e6ggende forst\u00e5else for blandt andet delegates og lambda, men du SKAL l\u00e6re at bruge LINQ s\u00e5 du m\u00e5 tilbage i tidligere moduler hvis du falder af.</p>"},{"location":"150_LINQ2Objects.html#grundlggende-om-linq","title":"Grundl\u00e6ggende om LINQ","text":"<p>LINQ st\u00e5r for Language INtegrated Query og giver en nem mulighed for</p> <ul> <li>Iterering</li> <li>Filtrering</li> <li>Sortering</li> <li>Gruppering</li> <li>med videre</li> </ul>"},{"location":"150_LINQ2Objects.html#demo-data","title":"Demo data","text":"<p>At bruge FileInfo-objekter er en god m\u00e5de at lege med LINQ p\u00e5. Et FileInfo-objekt repr\u00e6senterer en fil p\u00e5 disken, og har en masse \u201cbrugbare\u201d egenskaber:</p> <p></p> <p>Det er nemt at oprette et array af FileInfo-objekter:</p> <pre><code>// Skab en liste af filer i en mappe vi kan lege med\nvar mappe = new System.IO.DirectoryInfo(@\"c:\\temp\");\nvar filer = mappe.GetFiles(\"*.*\", System.IO.SearchOption.AllDirectories);\nConsole.WriteLine($\"Har fundet {filer.Length} i {mappe.Name}\");\n</code></pre> <p>S\u00f8rg for at rette mappen og eventuelt s\u00f8gestreng s\u00e5 du finder nogle filer at lege med.</p>"},{"location":"150_LINQ2Objects.html#derfor-linq","title":"Derfor LINQ","text":"<p>Du vil gerne slippe for at skrive kode som nedenst\u00e5ende hvis opgaven er at finde objekter i et array af filer hvor st\u00f8rrelsen er st\u00f8rre end x bytes, og resultatet skal v\u00e6re sorteret efter navnet p\u00e5 filen:</p> <pre><code>using System;\nusing System.Collections.Generic;\nusing System.IO;\nnamespace Demo\n{\nclass Program\n{\nstatic void Main(string[] args)\n{\n// Skab en liste af filer i en mappe vi kan lege med\nvar mappe = new System.IO.DirectoryInfo(@\"c:\\temp\");\nvar filer = mappe.GetFiles(\"*.*\", System.IO.SearchOption.AllDirectories);\nConsole.WriteLine($\"Har fundet {filer.Length} i {mappe.Name}\");\nvar res1 = FindFilerSt\u00f8rreEndSorteretEfterNavn(filer, 100);\n}\nstatic List&lt;FileInfo&gt; FindFilerSt\u00f8rreEndSorteretEfterNavn(FileInfo[] filer, long st\u00f8rrelse)\n{\nList&lt;FileInfo&gt; tmp = new List&lt;FileInfo&gt;();\nforeach (var item in filer)\n{\nif (item.Length &gt; st\u00f8rrelse)\n{\ntmp.Add(item);\n}\n}\ntmp.Sort(new SorterFiler());\nreturn tmp;\n}\n}\nclass SorterFiler : IComparer&lt;FileInfo&gt;\n{\npublic int Compare(FileInfo x, FileInfo y)\n{\nreturn string.Compare(x.Name, y.Name);\n}\n}\n}\n</code></pre> <p>Det er noget nemmere at skrive:</p> <pre><code>using System;\nusing System.Linq;\nnamespace Demo\n{\nclass Program\n{\nstatic void Main(string[] args)\n{\n// Skab en liste af filer i en mappe vi kan lege med\nvar mappe = new System.IO.DirectoryInfo(@\"c:\\temp\");\nvar filer = mappe.GetFiles(\"*.*\", System.IO.SearchOption.AllDirectories);\nConsole.WriteLine($\"Har fundet {filer.Length} i {mappe.Name}\");\nvar res1 = filer.Where(i =&gt; i.Length &gt; 100).OrderBy(i =&gt; i.Name).ToList();\n}\n}\n}\n</code></pre> <p>Og det er hele pointen med LINQ.</p>"},{"location":"150_LINQ2Objects.html#i-gang-med-linq","title":"I gang med LINQ","text":"<p>LINQ findes i forskellige versioner</p> <ul> <li>LINQ to objects</li> <li>LINQ to XML</li> <li>LINQ to EF (Entity Framework)</li> <li>LINQ to SQL (bruges ikke mere!!!)</li> <li>Parallel LINQ</li> </ul> <p>men i dette modul ser vi p\u00e5 det helt grundl\u00e6ggende - LINQ to objects.</p> <p>LINQ to objects (System.Linq) arbejder med alle typer af objekter i C# - b\u00e5de objekter fra frameworket og egne objekter:</p> <ul> <li>IEnumerable eller IEnumerable\\&lt;T&gt; (generisk)</li> <li>Array</li> <li>List</li> <li>Dictionary</li> </ul> <pre><code>using System;\nusing System.Linq;\nnamespace Demo\n{\nclass Program\n{\nstatic void Main(string[] args)\n{\n// LINQ kan b\u00e5de arbejde med arrays, List, List&lt;T&gt; mv\nint[] array = { 3, 3, 5, 3, 2, 3, 5, 2 };\nvar res1 = array.Where(i =&gt; i &lt; 5).OrderBy(i =&gt; i);\nforeach (var item in res1)\nConsole.WriteLine(item);\nvar mappe = new System.IO.DirectoryInfo(@\"c:\\temp\");\nvar filer = mappe.GetFiles(\"*.*\", System.IO.SearchOption.AllDirectories);\nvar res2 = filer.Where(i =&gt; i.Extension == \".zip\").OrderBy(i =&gt; i.Name);\nforeach (var item in res2)\nConsole.WriteLine(item.Name);\n}\n}\n}\n</code></pre> <p>LINQ to objects er en del af C# og virker ved hj\u00e6lp af extension metoder - alts\u00e5 metoder der automatisk tilf\u00f8jes klasser. Derfor er det n\u00f8dvendigt at have en using-reference til System.Linq i de filer hvor du \u00f8nsker at bruge LINQ:</p> <pre><code>using System.Linq;\n</code></pre>"},{"location":"150_LINQ2Objects.html#syntaks","title":"Syntaks","text":"<p>Lidt forvirrende har LINQ to former for syntaks</p> <ul> <li>\u201cQuery\u201d syntaks</li> <li>\u201cMethod\u201d syntaks</li> </ul> <p>De fleste benytter \u201cmetode\u201d (eller \u201clambda\u201d) syntaksen men det er op til dig. Query-syntaksen minder lidt om SQL og kan derfor m\u00e5ske v\u00e6re nemmere at komme i gang med. Jeg vil dog anbefale dig at l\u00e6re metode-syntaksen med det samme. Der kan dog v\u00e6re situationer hvor Query-syntaksen skaber nemmere l\u00e6sbar kode, men jeg syntes du skal fokusere p\u00e5 metode-syntaksen.</p> <pre><code>using System;\nusing System.Linq;\nnamespace Demo\n{\nclass Program\n{\nstatic void Main(string[] args)\n{\n// Skab en liste af filer i en mappe vi kan lege med\nvar mappe = new System.IO.DirectoryInfo(@\"c:\\temp\");\nvar filer = mappe.GetFiles(\"*.*\", System.IO.SearchOption.AllDirectories);\nConsole.WriteLine($\"Har fundet {filer.Length} i {mappe.Name}\");\n// finder alle filer med en st\u00f8rrelse over 1000 bytes sorteret efter navn\n// Query-syntaks (SQL)\nvar res1 = from f in filer where f.Length &gt; 1000 orderby f.Name select f;\n// Method-syntaks (Lambda)\nvar res2 = filer.Where(i =&gt; i.Length &gt; 1000).OrderBy(i =&gt; i.Name);\nConsole.WriteLine($\"Har fundet {res1.Count()} filer med Query-syntaks  - f\u00f8rste fil er {res1.First().Name}\");\nConsole.WriteLine($\"Har fundet {res2.Count()} filer med Method-syntaks - f\u00f8rste fil er {res1.First().Name}\");\n}\n}\n}\n</code></pre>"},{"location":"150_LINQ2Objects.html#deferedimediate-execution","title":"Defered/Imediate execution","text":"<p>Typisk vil resultatet af en query f\u00f8rst ske n\u00e5r man anmoder om data og det kan ske n\u00e5r man eksempelvis itererer eller benytter ToList/ToArray metoden:</p> <pre><code>using System;\nusing System.Linq;\nnamespace Demo\n{\nclass Program\n{\nstatic void Main(string[] args)\n{\n// LINQ kan b\u00e5de arbejde med arrays, List, List&lt;T&gt; mv\nint[] array = { 3, 3, 5, 3, 2, 3, 5, 2 };\nvar res1 = array.Where(i =&gt; i &lt; 5).OrderBy(i =&gt; i);\n// f\u00f8rst her afvikles udtryk\nforeach (var item in res1)\nConsole.WriteLine(item);\n// Nu afvikles udtryk med det samme\nvar res2 = array.Where(i =&gt; i &lt; 5).OrderBy(i =&gt; i).ToList();\n}\n}\n}\n</code></pre>"},{"location":"150_LINQ2Objects.html#brug-af-metoder-i-lambda-syntaksen","title":"Brug af metoder i Lambda-syntaksen","text":"<p>Mange af LINQ metoderne tager som argument en Func (hvilket jo faktisk er en Predicate), og typisk skrives det som en ren lambda. Men blot for en god ordens skyld er der jo tale om en reference til en delegate. <p>Her i en \u201cr\u00e5\u201d version:</p> <pre><code>using System;\nusing System.IO;\nusing System.Linq;\nnamespace Demo\n{\nclass Program\n{\nstatic void Main(string[] args)\n{\n// Skab en liste af filer i en mappe vi kan lege med\nvar mappe = new System.IO.DirectoryInfo(@\"c:\\temp\");\nvar filer = mappe.GetFiles(\"*.*\", System.IO.SearchOption.AllDirectories);\nConsole.WriteLine($\"Har fundet {filer.Length} i {mappe.Name}\");\nbool findesFil(FileInfo f) {\nreturn f.Length &gt; 1000;\n}\nFunc&lt;FileInfo, bool&gt; f = findesFil;\nvar res = filer.Where(f);\n}\n}\n}\n</code></pre> <p>Men det kan jo omskrives til lambda:</p> <pre><code>using System;\nusing System.IO;\nusing System.Linq;\nnamespace Demo\n{\nclass Program\n{\nstatic void Main(string[] args)\n{\n// Skab en liste af filer i en mappe vi kan lege med\nvar mappe = new System.IO.DirectoryInfo(@\"c:\\temp\");\nvar filer = mappe.GetFiles(\"*.*\", System.IO.SearchOption.AllDirectories);\nConsole.WriteLine($\"Har fundet {filer.Length} i {mappe.Name}\");\n// Den komplete syntaks\n// Func&lt;FileInfo, bool&gt; f = (FileInfo i) =&gt; { return i.Length &gt; 1000; };\n// som skrives nemmere som\nFunc&lt;FileInfo, bool&gt; f = i =&gt; i.Length &gt; 1000;\nvar res = filer.Where(f);\n}\n}\n}\n</code></pre> <p>Og hvis man ikke skal bruge referencen f til noget kan man liges\u00e5 godt droppe variablen:</p> <pre><code>using System;\nusing System.IO;\nusing System.Linq;\nnamespace Demo\n{\nclass Program\n{\nstatic void Main(string[] args)\n{\n// Skab en liste af filer i en mappe vi kan lege med\nvar mappe = new System.IO.DirectoryInfo(@\"c:\\temp\");\nvar filer = mappe.GetFiles(\"*.*\", System.IO.SearchOption.AllDirectories);\nConsole.WriteLine($\"Har fundet {filer.Length} i {mappe.Name}\");\nvar res = filer.Where(i =&gt; i.Length &gt; 1000);\n}\n}\n}\n</code></pre>"},{"location":"150_LINQ2Objects.html#sammenkdning","title":"Sammenk\u00e6dning","text":"<p>Helt grundl\u00e6ggende fungerer de fleste LINQ metoder ved at arbejde p\u00e5 en samling og returnere en ny. Man kan derfor v\u00e6lge at sammenk\u00e6de kald</p> <pre><code>using System;\nusing System.Linq;\nnamespace Demo\n{\nclass Program\n{\nstatic void Main(string[] args)\n{\n// Skab en liste af filer i en mappe vi kan lege med\nvar mappe = new System.IO.DirectoryInfo(@\"c:\\temp\");\nvar filer = mappe.GetFiles(\"*.*\", System.IO.SearchOption.AllDirectories);\nConsole.WriteLine($\"Har fundet {filer.Length} i {mappe.Name}\");\nvar s1 = filer.Where(i =&gt; i.Length &gt; 1000);\nvar s2 = s1.OrderBy(i =&gt; i.Name);\n// samme som\nvar s = filer.Where(i =&gt; i.Length &gt; 1000).OrderBy(i =&gt; i.Name);\n}\n}\n}\n</code></pre>"},{"location":"150_LINQ2Objects.html#filtrering-where","title":"Filtrering (Where)","text":"<p>Where-funktionen bruges til filtrering</p> <pre><code>using System;\nusing System.Linq;\nnamespace Demo\n{\nclass Program\n{\nstatic void Main(string[] args)\n{\n// Skab en liste af filer i en mappe vi kan lege med\nvar mappe = new System.IO.DirectoryInfo(@\"c:\\temp\");\nvar filer = mappe.GetFiles(\"*.*\", System.IO.SearchOption.AllDirectories);\nConsole.WriteLine($\"Har fundet {filer.Length} i {mappe.Name}\");\nvar res1 = filer.Where(i =&gt; i.Extension == \".cs\").ToList();\nvar res2 = filer.Where(i =&gt; i.Name.Contains(\"cache\") &amp;&amp; i.Length &gt; 1000).ToList();\nvar res3 = filer.Where(i =&gt; i.Name.Length &gt; 1000 || DateTime.Now.DayOfWeek == DayOfWeek.Sunday).ToList();\n// g\u00f8r noget med res1, res2 og res3\n}\n}\n}\n</code></pre>"},{"location":"150_LINQ2Objects.html#sortering-orderby","title":"Sortering (OrderBy)","text":"<p>Brug af OrderBy, OrderByDescending, ThenBy og ThenByDescendig.</p> <pre><code>using System;\nusing System.Linq;\nnamespace Demo\n{\nclass Program\n{\nstatic void Main(string[] args)\n{\n// Skab en liste af filer i en mappe vi kan lege med\nvar mappe = new System.IO.DirectoryInfo(@\"c:\\temp\");\nvar filer = mappe.GetFiles(\"*.*\", System.IO.SearchOption.AllDirectories);\nConsole.WriteLine($\"Har fundet {filer.Length} i {mappe.Name}\");\nvar res1 = filer.OrderBy(i =&gt; i.Length);\nvar res2 = filer.OrderByDescending(i =&gt; i.Length).ThenBy(i =&gt; i.Name);\n// g\u00f8r noget med res1 og res2\n}\n}\n}\n</code></pre>"},{"location":"150_LINQ2Objects.html#projecting-select","title":"Projecting (Select)","text":"<p>Select-funktionen kan bruges til at returnere en ny type. Her er der skabt en \u201clille\u201d FileInfo-klasse fordi man m\u00e5ske ikke skal bruge andet end navn og l\u00e6ngde:</p> <pre><code>using System;\nusing System.Linq;\nnamespace Demo\n{\nclass Program\n{\nstatic void Main(string[] args)\n{\n// Skab en liste af filer i en mappe vi kan lege med\nvar mappe = new System.IO.DirectoryInfo(@\"c:\\temp\");\nvar filer = mappe.GetFiles(\"*.*\", System.IO.SearchOption.AllDirectories);\nConsole.WriteLine($\"Har fundet {filer.Length} i {mappe.Name}\");\nvar res1 = filer.Where(i =&gt; i.Extension == \".cs\").Select(i =&gt; new MinFileInfo { Navn = i.Name, L\u00e6ngde = i.Length }).ToList(); ;\n// nu er res1 en liste af MinFileInfo-objekter\nforeach (var item in res1)\nConsole.WriteLine($\"{item.Navn} - {item.L\u00e6ngde}\");\n}\n}\nclass MinFileInfo {\npublic string Navn { get; set; }\npublic long L\u00e6ngde { get; set; }\n}\n}\n</code></pre>"},{"location":"150_LINQ2Objects.html#anonyme-typer","title":"Anonyme typer","text":"<p>Man man benytte anonyme typer til projektering i LINQ. P\u00e5 den m\u00e5de beh\u00f8ver man ikke skabe en klasse/struktur. I virkelighed h\u00f8rer anonyme typer under den avancerede C#, men helt grundl\u00e6ggende kan du skabe en anonym type med new {}, og benytter <code>var</code> ved typedefinition.</p> <pre><code>var a = new { };\nvar c = new { navn = \"a\", id = 2 };\n</code></pre> <p>Samme syntaxt kan bruges i LINQ:</p> <pre><code>using System;\nusing System.Linq;\nnamespace Demo\n{\nclass Program\n{\nstatic void Main(string[] args)\n{\n// Skab en liste af filer i en mappe vi kan lege med\nvar mappe = new System.IO.DirectoryInfo(@\"c:\\temp\");\nvar filer = mappe.GetFiles(\"*.*\", System.IO.SearchOption.AllDirectories);\nConsole.WriteLine($\"Har fundet {filer.Length} i {mappe.Name}\");\nvar res1 = filer.Where(i =&gt; i.Extension == \".cs\").Select(i =&gt; new { Navn = i.Name, L\u00e6ngde = i.Length });\n// nu er res1 en liste af \"anonyme\" objekter uden en klasse definition\nforeach (var item in res1)\nConsole.WriteLine($\"{item.Navn} - {item.L\u00e6ngde}\");\n}\n}\n}\n</code></pre> <p>Man kan s\u00e5gar n\u00f8jes med at angive navnet p\u00e5 egenskaben hvis man ikke \u00f8nsker at \u00e6ndre navnet:</p> <pre><code>using System;\nusing System.Linq;\nnamespace Demo\n{\nclass Program\n{\nstatic void Main(string[] args)\n{\n// Skab en liste af filer i en mappe vi kan lege med\nvar mappe = new System.IO.DirectoryInfo(@\"c:\\temp\");\nvar filer = mappe.GetFiles(\"*.*\", System.IO.SearchOption.AllDirectories);\nConsole.WriteLine($\"Har fundet {filer.Length} i {mappe.Name}\");\nvar res1 = filer.Where(i =&gt; i.Extension == \".cs\").Select(i =&gt; new { i.Name, i.Length });\n// nu er res1 en liste af \"anonyme\" objekter uden en klasse definition\nforeach (var item in res1)\nConsole.WriteLine($\"{item.Name} - {item.Length}\");\n}\n}\n}\n</code></pre>"},{"location":"150_LINQ2Objects.html#projektering-i-understrukturer-selectmany","title":"Projektering i understrukturer (SelectMany)","text":"<p>Man kan bruge SelectMany til at \u201cflade\u201d en struktur ud - alts\u00e5 arbejde med \u201cb\u00f8rn\u201d i stedet for \u201cm\u00f8dre\u201d:</p> <pre><code>class MinMappe {\npublic string Navn { get; set; }\npublic List&lt;MinFil&gt; Filer { get; set; }\n}\nclass MinFil {\npublic string Navn { get; set; }\n}\n</code></pre> <pre><code>var mappe = new System.IO.DirectoryInfo(@\"c:\\temp\");\nvar mineMapper = mappe.GetDirectories().Select(i =&gt; new MinMappe { Navn = i.FullName }).ToList();\nforeach (var minMappe in mineMapper)\nminMappe.Filer = System.IO.Directory.GetFiles(minMappe.Navn).Select(i =&gt; new MinFil { Navn = i }).ToList();\n// mineMapper best\u00e5r nu af en samling ala:\n// c:\\temp\\mappe1\n// -- fil1.txt\n// -- fil2.txt\n// c:\\temp\\mappe2\n// -- fil3.txt\n// ...\n// (Select finder mapperne)\nvar res1 = mineMapper.Select(m =&gt; m.Navn).ToList();\n// (SelectMany finder alle filerne)\nvar res2 = mineMapper.SelectMany(m =&gt; m.Filer).ToList();\n// (SelectMany kan ogs\u00e5 tage mor med - her som et anonymt object)\nvar res3 = mineMapper.SelectMany(m =&gt; m.Filer, (m, f) =&gt; new { mappeName = m.Navn, filNavn = f.Navn }).ToList(); ;\n</code></pre>"},{"location":"150_LINQ2Objects.html#gruppering-groupby","title":"Gruppering (GroupBy)","text":"<p>Gruppering er en af de effektive funktioner som LINQ tilbyder:</p> <pre><code>using System;\nusing System.Linq;\nnamespace Demo\n{\nclass Program\n{\nstatic void Main(string[] args)\n{\n// Skab en liste af filer i en mappe vi kan lege med\nvar mappe = new System.IO.DirectoryInfo(@\"c:\\temp\");\nvar filer = mappe.GetFiles(\"*.*\", System.IO.SearchOption.AllDirectories);\nConsole.WriteLine($\"Har fundet {filer.Length} i {mappe.Name}\");\n// Grupperet efter extension\nvar res1 = filer.GroupBy(i =&gt; i.Extension);\nforeach (var gruppe in res1)\n{\n// udskriver extension\nConsole.WriteLine($\"Gruppe: {gruppe.Key}\");\nforeach (var fil in gruppe)\n{\n// udskriver fil\nConsole.WriteLine($\"\\t{fil.Name}\");\n}\n}\n}\n}\n}\n</code></pre>"},{"location":"150_LINQ2Objects.html#joining-join","title":"Joining (Join)","text":"<p>Med Join kan man koble to (eller flere) lister sammen:</p> <pre><code>using System;\nusing System.Collections.Generic;\nusing System.Linq;\nnamespace Demo\n{\nclass Program\n{\nstatic void Main(string[] args)\n{\n// Skab en liste af filer i en mappe vi kan lege med\nvar mappe = new System.IO.DirectoryInfo(@\"c:\\temp\");\nvar filer = mappe.GetFiles(\"*.*\", System.IO.SearchOption.AllDirectories);\nConsole.WriteLine($\"Har fundet {filer.Length} i {mappe.Name}\");\nList&lt;MinGruppe&gt; grupper = new List&lt;MinGruppe&gt;\n{\nnew MinGruppe{ Extension=\".txt\", GruppeNavn = \"Tekst filer\" },\nnew MinGruppe{ Extension = \".cs\", GruppeNavn = \"Kode filer\" },\nnew MinGruppe{ Extension = \".zip\", GruppeNavn = \"Komprimerede filer\" },\nnew MinGruppe{ Extension = \".csproj\", GruppeNavn = \"VS filer\" },\nnew MinGruppe{ Extension = \".sln\", GruppeNavn = \"VS filer\" }\n};\nvar mineFiler = filer.OrderBy(i=&gt;i.Name).ToList();\n// nu er der to lister der kan \"joines\" p\u00e5 extension\nvar res = mineFiler.Join(grupper, i =&gt; i.Extension, x =&gt; x.Extension, (i, x) =&gt; new { i.Name, x.GruppeNavn });\nforeach (var item in res)\nConsole.WriteLine($\"Fil: {item.Name} Gruppe: {item.GruppeNavn}\");\n}\n}\nclass MinGruppe\n{\npublic string Extension { get; set; }\npublic string GruppeNavn { get; set; }\n}\n}\n</code></pre>"},{"location":"150_LINQ2Objects.html#singleton","title":"Singleton","text":"<p>Der er tit brug for at finde enkelte elementer i en liste (eller resultat):</p> <pre><code>using System;\nusing System.Linq;\nnamespace Demo\n{\nclass Program\n{\nstatic void Main(string[] args)\n{\n// Skab en liste af filer i en mappe vi kan lege med\nvar mappe = new System.IO.DirectoryInfo(@\"c:\\temp\");\nvar filer = mappe.GetFiles(\"*.*\", System.IO.SearchOption.AllDirectories);\nConsole.WriteLine($\"Har fundet {filer.Length} i {mappe.Name}\");\n// Find den f\u00f8rste\nvar item1 = filer[0];               // Finder den f\u00f8rste eller fejler hvis liste er tom\nvar item2 = filer.First();          // Finder den f\u00f8rste eller fejler hvis liste er tom\nvar item3 = filer.FirstOrDefault(); // Finder den f\u00f8rste eller returnerer default v\u00e6rdi\n// vil v\u00e6re sikker p\u00e5 at der kun er en\n// var item4 = filer.Single();         // Finder den f\u00f8rste - men der m\u00e5 kun v\u00e6re en eller en tom liste - ellers fejl\n// var item5 = filer.SingleOrDefault();// Finder den f\u00f8rste - men der m\u00e5 kun v\u00e6re en eller en tom liste - ellers default v\u00e6rdi\n// Lidt mere avanceret (s\u00f8rg for at minfil.txt er i /temp)\nvar item6 = filer.FirstOrDefault(i =&gt; i.Name == \"minfil.txt\");  // Finder en fil\nvar item7 = filer.FirstOrDefault(i =&gt; i.Name == \"minfil1.txt\"); // Finder ikke noget - derfor null\nvar item8 = filer.Single(i =&gt; i.Name == \"minfil.txt\");          // Finder en fil (men havde der v\u00e6ret to filer med det navn var det fejlet)\n// samme g\u00e6lder med Last...\nvar item9 = filer.LastOrDefault();\n// find \"index 3\"\nvar item10 = filer.ElementAt(2);            // Finder index 2 (evt fejl hvis den ikke er der)\nvar item11 = filer.ElementAtOrDefault(2);   // Finder index 2 (null ved fejl)\n}\n}\n}\n</code></pre>"},{"location":"150_LINQ2Objects.html#diverse-linq","title":"Diverse LINQ","text":""},{"location":"150_LINQ2Objects.html#check","title":"Check","text":"<p>Brug Any-funktionen til at checke om noget i listen matcher et udtryk</p> <pre><code>using System;\nusing System.Linq;\nnamespace Demo\n{\nclass Program\n{\nstatic void Main(string[] args)\n{\n// Skab en liste af filer i en mappe vi kan lege med\nvar mappe = new System.IO.DirectoryInfo(@\"c:\\temp\");\nvar filer = mappe.GetFiles(\"*.*\", System.IO.SearchOption.AllDirectories);\nConsole.WriteLine($\"Har fundet {filer.Length} i {mappe.Name}\");\nstring ledEfter = \"Program.cs\";\nvar findes1 = filer.Any(i =&gt; i.Name == ledEfter);\nint st\u00f8rrelse = 100000;\nConsole.WriteLine($\"Findes der filer over {st\u00f8rrelse:N0} bytes: {filer.Any(i=&gt;i.Length&gt;st\u00f8rrelse)}\");\n}\n}\n}\n</code></pre>"},{"location":"150_LINQ2Objects.html#partitionering-takeskip","title":"Partitionering (Take/Skip)","text":"<p>P\u00e5 Skip- og Take-funktioner til at \u201cplukke\u201d i en liste</p> <pre><code>using System;\nusing System.Linq;\nnamespace Demo\n{\nclass Program\n{\nstatic void Main(string[] args)\n{\n// Skab en liste af filer i en mappe vi kan lege med\nvar mappe = new System.IO.DirectoryInfo(@\"c:\\temp\");\nvar filer = mappe.GetFiles(\"*.*\", System.IO.SearchOption.AllDirectories);\nConsole.WriteLine($\"Har fundet {filer.Length} i {mappe.Name}\");\nvar res1 = filer.Take(10);          // f\u00f8rste 10 filer\nvar res2 = filer.Skip(10);          // Skip de f\u00f8rste 10 filer og returner resten\nvar res3 = filer.Skip(10).Take(10); // Skip de f\u00f8rste 10 og returnerer de n\u00e6ste 10\n}\n}\n}\n</code></pre>"},{"location":"150_LINQ2Objects.html#st-operationer","title":"S\u00e6t operationer","text":"<p>Hvis man har to lister kan man bruge s\u00e6t-operationer til at sammenligne listerne.</p> <pre><code>using System;\nusing System.Linq;\nnamespace Demo\n{\nclass Program\n{\nstatic void Main(string[] args)\n{\n// Skab lister af filnavne fra hver sin mappe\nvar mappe = new System.IO.DirectoryInfo(@\"c:\\temp\");\nvar filer1 = mappe.GetFiles(\"*.*\", System.IO.SearchOption.AllDirectories).Select(i=&gt;i.Name.ToLower()).ToList();\nConsole.WriteLine($\"Har fundet {filer1.Count} i {mappe.Name}\");\nmappe = new System.IO.DirectoryInfo(@\"c:\\script\");\nvar filer2 = mappe.GetFiles(\"*.*\", System.IO.SearchOption.AllDirectories).Select(i =&gt; i.Name.ToLower()).ToList();\nConsole.WriteLine($\"Har fundet {filer2.Count} i {mappe.Name}\");\nvar res1 = filer1.Except(filer2).ToList();   // Filer i filer1 som ikke er i filer2\nvar res2 = filer2.Except(filer1).ToList();   // Filer i filer2 som ikke er i filer1\nvar res3 = filer1.Union(filer2).ToList();    // Filer fra begge mapper (uden dubletter)\nvar res4 = filer1.Intersect(filer2).ToList();// Filer der findes i begge mapper\nvar res5 = filer1.Distinct().ToList();       // Fjern dubletter fra filer1\nvar res6 = filer2.Distinct().ToList();       // Fjern dubletter fra filer2\n// concat kan bruges til at l\u00e6gge samlinger sammen\n}\n}\n}\n</code></pre>"},{"location":"150_LINQ2Objects.html#zip","title":"Zip","text":"<p>Skab en ny samling</p> <pre><code>int[] alder = { 1, 2, 3 };\nstring[] navn = { \"a\", \"b\", \"c\" };\n// Samling af tuples\nIEnumerable&lt;(string Navn, int Alder)&gt; c = navn.Zip(alder);\nforeach (var item in c)\n{\nConsole.WriteLine(item.Navn + \" \" + item.Alder);\n}\n</code></pre>"},{"location":"150_LINQ2Objects.html#chunk","title":"Chunk","text":"<p>Split samlinger</p> <pre><code>var mappe = new System.IO.DirectoryInfo(@\"c:\\temp\");\nvar filer = mappe.GetFiles(\"*.*\", System.IO.SearchOption.AllDirectories).Select(i =&gt; i.Name.ToLower()).ToList();\nList&lt;string[]&gt; res = filer.Chunk(25).ToList();\n// res = liste af arrays med hver 25 elementer\n</code></pre>"},{"location":"150_LINQ2Objects.html#linq-er-meget-mere","title":"LINQ er meget mere","text":"<p>LINQ best\u00e5r af en del andre metoder - herunder</p> <ul> <li>Aggregate</li> <li>Cast</li> <li>GroupJoin</li> <li>OfType</li> <li>SelectMany</li> </ul> <p>og mange andre - for slet ikke at tale om muligheden for at skabe egne udtryk (IQueryable\\&lt;T&gt;). Men det kan du eventuelt selv l\u00e6se op p\u00e5.</p>"},{"location":"150_LINQ2Objects.html#linq-og-tal","title":"LINQ og tal","text":"<p>Ved brug af Linq mod samlinger af tal findes der en nogle flere muligheder:</p> <pre><code>int[] nr = new[] { 5, 7, 1, 3, 9, 10, 4, 1, 2, 7 };\nConsole.WriteLine(nr.Count());              // 10\nConsole.WriteLine(nr.Count(i =&gt; i &gt; 2));    // 7\nConsole.WriteLine(nr.Max());                // 10\nConsole.WriteLine(nr.Min());                // 1\nConsole.WriteLine(nr.Sum());                // 49\nConsole.WriteLine(nr.Average());            // 4,9\nConsole.WriteLine(nr.Min(i =&gt; i * 10));     // 10\nConsole.WriteLine(nr.Max(i =&gt; i * 10));     // 100\nConsole.WriteLine(nr.Sum(i =&gt; i * 10));     // 490\n</code></pre> <p>Info</p> <p>Info</p> <p>Info</p> <p>Info</p>"},{"location":"150_LINQ2Objects.html#opgave-150-1","title":"Opgave 150-1","text":"<p>Brug LINQ mod et simpelt int-array (kode til s\u00f8gning: BFAB)</p> <p>Se opgave</p>"},{"location":"150_LINQ2Objects.html#opgave-150-2","title":"Opgave 150-2","text":"<p>Brug LINQ mod en simpel liste af objekter (kode til s\u00f8gning: BFAC)</p> <p>Se opgave</p>"},{"location":"150_LINQ2Objects.html#opgave-150-3","title":"Opgave 150-3","text":"<p>Brug af (eksempelvis) LINQ til at finde point til Yatzy - ST\u00d8RRE OPGAVE (kode til s\u00f8gning: BFAD)</p> <p>Se opgave</p>"},{"location":"150_LINQ2Objects.html#opgave-150-4","title":"Opgave 150-4","text":"<p>Brug en liste af personer til at lege med LINQ (kode til s\u00f8gning: BFAE)</p> <p>Se opgave</p>"},{"location":"150_LINQ2Objects.html#linqpad","title":"LinqPad","text":"<p>Der findes et popul\u00e6rt og (til en vis grad) gratis v\u00e6rt\u00f8j p\u00e5 https://www.linqpad.net som giver en masse muligheder for at lege med Linq (og C#).</p>"},{"location":"150_LINQ2Objects.html#eksterne-biblioteker","title":"Eksterne biblioteker","text":"<p>Der findes en del 3. parts biblioteker der udvider LINQ - se eksempelvis</p> <ul> <li>morelinq/MoreLINQ</li> </ul>"},{"location":"150_LINQ2Objects.html#udvidelse-af-linq","title":"Udvidelse af LINQ","text":"<p>Man kan have behov for at oprette egne LINQ udvidelser, og det kan nemt lade sig g\u00f8re med extension metoder</p> <ul> <li>Simple udvidelser (eksempelvis giv med hvert andet element i en liste)</li> <li>Avancerede udvidelser som tager delegates (ala Where, OrderBy mv)</li> </ul> <p>Husk, at en extension metode skal - befinde sig i en offentlig statisk klasse - v\u00e6re offentlig - v\u00e6re statisk - benytte this-kodeordet</p> <p>Hvis man vil udvide LINQ to objects kan this v\u00e6re typen IEnumerable\\&lt;T&gt;:</p> <pre><code>public static class Ex\n{\npublic static IEnumerable&lt;T&gt; MinMetode1&lt;T&gt;(this IEnumerable&lt;T&gt; source)\n{\n// kode...\n// return ...\n}\npublic static IEnumerable&lt;T&gt; MinMetode2&lt;T&gt;(this IEnumerable&lt;T&gt; source, Func&lt;T,bool&gt; f) {\n// kode...\n// return ...\n}\n}\n</code></pre> <p>Info</p>"},{"location":"150_LINQ2Objects.html#opgave-150-5","title":"Opgave 150-5","text":"<p>Brug af extension metoder til at udvide og forbedre LINQ to objects (kode til s\u00f8gning: BFAF)</p> <p>Se opgave</p>"},{"location":"155_ASync.html","title":"Asynkron programmering","text":""},{"location":"155_ASync.html#om-modulet","title":"Om modulet","text":"<p>I dette modul vil vi fokusere p\u00e5 asynkron programmering og brugen af Task-typen.</p>"},{"location":"155_ASync.html#om-asykron-programmering","title":"Om asykron programmering","text":"<p>Asykron programmering handler om at afvikle kode samtidigt - eller nogenlunde samtidigt - enten p\u00e5 samme tr\u00e5d med \u2018timeslized\u2019 eller p\u00e5 flere tr\u00e5de i forskellige kontekst (med egen stack og dermed variabler).</p> <p>For at f\u00e5 lidt styr p\u00e5 begreberne</p> <ul> <li>Concurrency (samtidighed)</li> <li>Afvikling af flere opgaver p\u00e5 samme kerne<ul> <li>Benytter overlap eller timeslizing</li> <li>Form\u00e5let er af g\u00f8re en applikation brugbar og ikke blokere</li> <li>Afh\u00e6ngig af brug kan det vinde performance</li> <li>Benytter begr\u00e6nsede ressourcer</li> <li>Kan opn\u00e5s i C# ved hj\u00e6lp af Task, async og await</li> <li>Men bem\u00e6rk hvis en async metode benytter tr\u00e5de er der ikke tale om timeslizing mere</li> </ul> </li> <li>Parallelism (parallelisme)</li> <li>Afvikling af flere opgaver p\u00e5 forskellige kerner<ul> <li>Benytter to eller flere kerner</li> <li>Samt eventuelt timeslizing</li> <li>Form\u00e5let er direkte at vinde performance</li> <li>Benytter mange ressourcer</li> <li>Kan opn\u00e5s i C# ved hj\u00e6lp af System.Threading, TPL (Task Parallel Library), PLINQ (Parallel LINQ) mv</li> </ul> </li> </ul> <p>Der er typisk flere (kombinerede) \u00e5rsager til at rode sig ind i asynkron programmering</p> <ul> <li>Afvikling af ressourcekr\u00e6vende metoder p\u00e5 over flere kerner p\u00e5 en CPU</li> <li>Afvikling af flere tidskr\u00e6vende metoder p\u00e5 samme tid for p\u00e5 den m\u00e5de at spare tid</li> <li>Afvikling af funktionalitet p\u00e5 tr\u00e5de for selv for at holde en brugerflade applikation levende</li> </ul>"},{"location":"155_ASync.html#optimering-af-tidskrvende-metoder","title":"Optimering af tidskr\u00e6vende metoder","text":"<p>Pr\u00f8v f\u00f8lgende kode i en konsol applikation</p> <pre><code>using System;\nusing System.Threading;\nnamespace MinTest\n{\nclass Program\n{\nstatic void Main(string[] args)\n{\nSystem.Diagnostics.Stopwatch s = new System.Diagnostics.Stopwatch();\ns.Start();\nConsole.WriteLine(\"Start\");\nConsole.WriteLine(\"Sleep 1\");\nThread.Sleep(500);\nConsole.WriteLine(\"Sleep 2\");\nThread.Sleep(500);\nConsole.WriteLine(\"Sleep 3\");\nThread.Sleep(500);\nConsole.WriteLine(\"Slut\");\ns.Stop();\nConsole.WriteLine($\"Tid: {s.ElapsedMilliseconds}\");\n}\n}\n}\n</code></pre> <p>og bem\u00e6rk, at koden afvikles p\u00e5 lige omkring 1.5 sekund (3 x 500 ms + overhead). Hvis vi antager, at de tre operationer, som tager 500 ms hver, kan afvikles nogenlunde uafh\u00e6ngigt af hinanden, burde programmet kune afvikles p\u00e5 500 ms + overhead. Pr\u00f8v derfor f\u00f8lgende kode i en almindelig konsol applikation:</p> <pre><code>using System;\nusing System.Threading;\nusing System.Threading.Tasks;\nnamespace MinTest\n{\nclass Program\n{\nstatic async Task Main(string[] args)\n{\nSystem.Diagnostics.Stopwatch s = new System.Diagnostics.Stopwatch();\ns.Start();\nConsole.WriteLine(\"Start\");\nTask t1 = Task.Run(async () =&gt;\n{\nConsole.WriteLine(\"Sleep 1\");\nawait Task.Delay(500);\n});\nTask t2 = Task.Run(async () =&gt;\n{\nConsole.WriteLine(\"Sleep 2\");\nawait Task.Delay(500);\n});\nTask t3 = Task.Run(async () =&gt;\n{\nConsole.WriteLine(\"Sleep 3\");\nawait Task.Delay(500);\n});\nawait Task.WhenAll(t1, t2, t3);\nConsole.WriteLine(\"Slut\");\ns.Stop();\nConsole.WriteLine($\"Tid: {s.ElapsedMilliseconds}\");\n}\n}\n}\n</code></pre> <p>K\u00f8r koden nogle gange og bem\u00e6rk at</p> <ul> <li>Programmet nu afvikles p\u00e5 500 ms + overhead</li> <li>De tre operationer (sleep1, sleep2 og sleep3) ikke n\u00f8dvendigvis afvikles i r\u00e6kkef\u00f8lge, men at angivlese af tid samt \u201cslut\u201d altid kommer til sidst</li> </ul> <p>Samme kan opn\u00e5s i \u00e6gte parallel kode med TPL:</p> <pre><code>using System;\nusing System.Threading.Tasks;\nnamespace MinTest\n{\nclass Program\n{\nstatic void Main(string[] args)\n{\nSystem.Diagnostics.Stopwatch s = new System.Diagnostics.Stopwatch();\ns.Start();\nConsole.WriteLine(\"Start\");\nParallel.For(1, 4, nr =&gt; {\nConsole.WriteLine(\"Sleep \" + nr);\nSystem.Threading.Thread.Sleep(500);\n});\nConsole.WriteLine(\"Slut\");\ns.Stop();\nConsole.WriteLine($\"Tid: {s.ElapsedMilliseconds}\");\n}\n}\n}\n</code></pre>"},{"location":"155_ASync.html#optimering-af-en-brugerflade-applikation","title":"Optimering af en brugerflade applikation","text":"<p>For at se fordelen ved brugen af async kode i en UI applikation kan du hente f\u00f8lgende</p> <p></p> <p>Du kan finde det her</p> <p>devcronberg/async-winform-task-await</p> <p>og kan hente det ved enten af clone koden, eller blot hente projektet som en zip (klik p\u00e5 den store gr\u00f8nne knap). \u00c5bn det i Visual Studio og klik p\u00e5 F5.</p> <p>Programmet viser forskellen p\u00e5 sync og async kode ved at hente et tal fra nettet, og l\u00e6g m\u00e6rke til at den synkrone kode l\u00e5ser bugerfladen. Det g\u00f8r den asynkrone kode ikke, og giver samtidigt mulighed for at afbryde operationen.</p>"},{"location":"155_ASync.html#task-og-task","title":"Task og Task <p>Task er en klasse, der af hvilken kan skabes et objekt, som repr\u00e6senterer en enkelt asynkron operation. Objektet vil \u00e6ndre status l\u00f8bende s\u00e5 man kan finde ud af om operationen er</p> <ul> <li>startet</li> <li>f\u00e6rdig</li> <li>fejlet</li> <li>afbrudt</li> </ul> <p>Se et Task-objekt som en samling instruktioner, der p\u00e5 et tidspunkt enten er afviklet f\u00e6rdig eller fejlet. Men du ved ikke hvorn\u00e5r. Task betyder jo opgave - s\u00e5 objektet repr\u00e6senterer en opgave der p\u00e5 et tidpunkt er f\u00e6rdig. I andre sprog kendes et Task objekt som et Promise-objekt, hvilket ogs\u00e5 er et meget godt navn - et l\u00f8fte om en opgave der afviklet p\u00e5 et tidspunkt.</p> <p>Task findes i to versioner</p> <ul> <li>Task repr\u00e6senterer en operation uden returv\u00e6rdi</li> <li>Task\\&lt;T&gt; repr\u00e6senterer en operation med returv\u00e6rdi (svarende til typen T)</li> </ul> <p>I grundl\u00e6ggende C# modtager du Task og Task\\&lt;T&gt; objekter som returv\u00e6rdier fra metodekald - eksempelvis</p> <ul> <li>AppendAllTextAsync (System.IO.File)</li> <li>DownloadStringTaskAsync (System.Net.WebClient)</li> <li>GetAsync (System.Net.Http)</li> <li>ExecuteNonQueryAsync (System.Data.SqlClient)</li> </ul> <p>og mange mange flere.</p> <p>I den mere avancerede C# kan du selv skabe Task-objekter og eventuelt returnere disse.</p>","text":""},{"location":"155_ASync.html#en-asynkron-konsol-applikation","title":"En asynkron konsol applikation <p>Som bekendt ser en standard konsol applikation s\u00e5ledes ud:</p> <pre><code>using System;\n\nnamespace Demo\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n\n\n        }\n    }\n}\n</code></pre> <p>Main-metoden i er en void, og da await kun kan benyttes i en async metode, giver det nogle issues. Derfor kan man i de sidste versioner af framework\u2019et oprette en asynkron konsol applikation. Den skal se s\u00e5ledes ud:</p> <pre><code>using System;\nusing System.Threading.Tasks;\n\nnamespace Demo\n{\n    class Program\n    {\n        static async Task Main(string[] args)\n        {\n\n        }\n    }\n}\n</code></pre> <p>Bem\u00e6rk, at metoden nu returnerer en Task og ikke en void, og er makeret med async-kodeordet. Nu kan du bruge await direkte i metoden.</p>","text":""},{"location":"155_ASync.html#om-async-og-await","title":"Om async og await <p>Man kan afvente en Task p\u00e5 flere m\u00e5der, men generelt b\u00f8r du overlade det komplekse til kode, som autogenereres n\u00e5r du benytte async og await-kodeord. Der er mange fordele ved dette</p> <ul> <li>Meget af kompleksiteten ved async kode er simplificeret ved async/await</li> <li>Syntaks sukker (s\u00e5 det forsl\u00e5r)</li> <li>Langt bedre l\u00e6sbarhed</li> <li>Nem fejlh\u00e5ndtering</li> <li>H\u00f8jere sikkerhed mod deadlocks</li> <li>Cancellation er noget simplere</li> <li>kan fanges i en try catch som en TaskCanceledException</li> </ul> <p>Til geng\u00e6ld koster en lidt for hver <code>async</code>, idet der oprettes en state machine som holder styr p\u00e5 status, context og eventuelle fejl.</p> <p>Der er andre m\u00e5der at afvente et task-objekt - herunder eksempelvis en ContinueWith-metode, som minder om en traditionel \u201ccall back\u201d metode. Men i grundl\u00e6ggende C# b\u00f8r du holde dig til async og await.</p> <p>Blot til orientering er her to applikationer som g\u00f8r det samme - med og uden brug af await. F\u00f8rst hentes et tilf\u00e6ldigt tal asynkront fra random.org, s\u00e5 oprettes en streng med et antal stjerner svarende til det tilf\u00e6ldige tal, og slutteligt gemmes strengen asynkront i en fil.</p> <p>Uden brug af async/await ser det s\u00e5ledes ud:</p> <pre><code>using System;\nusing System.Threading.Tasks;\n\nnamespace MinTest\n{\n    internal class Program\n    {\n        private static readonly System.Net.Http.HttpClient httpClient = new System.Net.Http.HttpClient();\n\n        private static void Main(string[] args)\n        {\n            Task&lt;string&gt; antalTask = httpClient.GetStringAsync(\"https://www.random.org/integers/?num=1&amp;min=1&amp;max=6&amp;col=1&amp;base=10&amp;format=plain&amp;rnd=new\");\n            antalTask.ContinueWith(t =&gt;\n            {\n                int antal = Convert.ToInt32(t.Result);\n                string stjerner = new string('*', antal);\n                Task gemTask = System.IO.File.WriteAllTextAsync(@\"c:\\temp\\stjerner.txt\", stjerner);\n                gemTask.ContinueWith(t =&gt;\n                {\n                    Console.WriteLine($\"Der er gemt {antal} stjerne{(antal &gt; 1 ? \"r\" : \"\")} i c:\\\\temp\\\\stjerner.txt\");\n                });\n            });\n            Console.ReadKey();\n        }\n    }\n}\n</code></pre> <p>og med brug af async/await:</p> <pre><code>using System;\nusing System.Threading.Tasks;\n\nnamespace MinTest\n{\n    internal class Program\n    {\n        private static readonly System.Net.Http.HttpClient httpClient = new System.Net.Http.HttpClient();\n\n        private async static Task Main(string[] args)\n        {\n            string antalTxt = await httpClient.GetStringAsync(\"https://www.random.org/integers/?num=1&amp;min=1&amp;max=6&amp;col=1&amp;base=10&amp;format=plain&amp;rnd=new\");\n            int antal = Convert.ToInt32(antalTxt);\n            string stjerner = new string('*', antal);\n            await System.IO.File.WriteAllTextAsync(@\"c:\\temp\\stjerner.txt\", stjerner);\n            Console.WriteLine($\"Der er gemt {antal} stjerne{(antal &gt; 1 ? \"r\" : \"\")} i c:\\\\temp\\\\stjerner.txt\");\n        }\n    }\n}\n</code></pre> <p>L\u00e6g m\u00e6rke til hvor simpel koden pludselig er!</p>","text":""},{"location":"155_ASync.html#brug-af-await","title":"Brug af await <p>await kan du bruge foran Task- og Task\\&lt;T&gt;-objekter for at fort\u00e6lle runtime, at der skal afventes at afviklingen er f\u00e6rdig - men at afviklingen returneres til hovedtr\u00e5den. N\u00e5r afvikling af Task-objektet er f\u00e6rdig afvikles resten af instruktionerne efter await - og contekst reetableres.</p> <p>await-kodeordet kan kun benyttes i en async-metode.</p> <p>Som et eksempel p\u00e5 v\u00e6rdien ved async/await kan du se p\u00e5 denne kode, hvor metoden GemFilAsync(string sti, string indhold) gemmer indhold i en given fil asynkront, holder en lille pause, og samtidigt logger p\u00e5 konsollen hvad den g\u00f8r. Metoden returnerer en Task (action/void) s\u00e5 den kan \u201cawaites\u201d hvis du \u00f8nsker. Se bort fra syntaksen i metoden GemFilAsync i f\u00f8lgende - den er underordnet - men fokuser p\u00e5 det logiske i koden.</p> <p>Hvad tror du der sker:</p> <pre><code>using System;\nusing System.IO;\nusing System.Threading;\nusing System.Threading.Tasks;\n\nnamespace MinTest\n{\n    class Program\n    {\n        static async Task Main(string[] args)\n        {\n            Console.WriteLine(\"Start program\");\n            string indhold = \"123\";\n            string sti = @\"c:\\temp\\data.txt\";\n            GemFilAsync(sti, indhold);\n            Console.WriteLine(\"Slut program\");\n        }\n\n        static async Task GemFilAsync(string sti, string indhold)\n        {\n            await Task.Run(async () =&gt; {\n                Console.WriteLine(\"Gemmer \" + sti);\n                Thread.Sleep(100);\n                await File.AppendAllTextAsync(sti, indhold);\n                Console.WriteLine(\"Gemt \" + sti);\n            });\n        }\n    }\n}\n</code></pre> <p>Den skriver</p> <pre><code>Start program\nSlut program\n</code></pre> <p>hvilke jo kan undre fordi GemFilAsync bliver jo kaldt??</p> <p>Men GemFilAsync-metoden afvikle sin kode p\u00e5 en tr\u00e5d for sig selv, og den n\u00e5r aldrig at komme igang f\u00f8r programmet er afsluttet!!</p> <p>Pr\u00f8v at rette koden til</p> <pre><code>using System;\nusing System.IO;\nusing System.Threading;\nusing System.Threading.Tasks;\n\nnamespace MinTest\n{\n    class Program\n    {\n        static async Task Main(string[] args)\n        {\n            Console.WriteLine(\"Start program\");\n            string indhold = \"123\";\n            string sti = @\"c:\\temp\\data.txt\";\n            GemFilAsync(sti, indhold);\n            Console.WriteLine(\"Slut program\");\n            Console.ReadKey();\n        }\n\n        static async Task GemFilAsync(string sti, string indhold)\n        {\n            await Task.Run(async () =&gt; {\n                Console.WriteLine(\"Gemmer \" + sti);\n                Thread.Sleep(100);\n                await File.AppendAllTextAsync(sti, indhold);\n                Console.WriteLine(\"Gemt \" + sti);\n            });\n        }\n    }\n}\n</code></pre> <p>Den eneste forskel er den sidste linje i Main - Console.ReadKey() - som holder vinduet \u00e5bent og dermed programmet levende indtil der trykkes p\u00e5 en knap.</p> <p>Nu er resultatet:</p> <pre><code>Start program\nSlut program\nGemmer c:\\temp\\data.txt\nGemt c:\\temp\\data.txt\n</code></pre> <p>Nu bliver metoden da kaldt, men \u201cSlut program\u201d kommer f\u00f8r log fra metoden - hvorfor?? Igen - metoden afvikles p\u00e5 en tr\u00e5d for sig selv, og inden den er igang er programpointeren allerede videre til n\u00e6ste linje.</p> <p>Pr\u00f8v s\u00e5 at rette til</p> <pre><code>using System;\nusing System.IO;\nusing System.Threading;\nusing System.Threading.Tasks;\n\nnamespace MinTest\n{\n    class Program\n    {\n        static async Task Main(string[] args)\n        {\n            Console.WriteLine(\"Start program\");\n            string indhold = \"123\";\n            string sti = @\"c:\\temp\\data.txt\";\n            await GemFilAsync(sti, indhold);\n            Console.WriteLine(\"Slut program\");\n        }\n\n        static async Task GemFilAsync(string sti, string indhold)\n        {\n            await Task.Run(async () =&gt; {\n                Console.WriteLine(\"Gemmer \" + sti);\n                Thread.Sleep(100);\n                await File.AppendAllTextAsync(sti, indhold);\n                Console.WriteLine(\"Gemt \" + sti);\n            });\n        }\n    }\n}\n</code></pre> <p>Nu er Console.ReadKey() fjernet igen, men til geng\u00e6ld er await-kodeordet tilf\u00f8jet foran GemFilAsync. Nu er resultatet:</p> <pre><code>Start program\nGemmer c:\\temp\\data.txt\nGemt c:\\temp\\data.txt\nSlut program\n</code></pre> <p>hvilket er det vi gerne vil. R\u00e6kkef\u00f8lgen er nu logisk fordi await autogenerer en masse kode der har til form\u00e5l at genetablere kontekst og afvikling n\u00e5r den asynkrone funktion er f\u00e6rdig. Det ligner og kodes som synkron kode, men det er asynkront.</p>   <p>Info</p>","text":""},{"location":"155_ASync.html#opgave-155-1","title":"Opgave 155-1 <p>Forst\u00e5 brugen af async/await ved at \u2018beregne primtal\u2019. (kode til s\u00f8gning: BFFB)</p> <p>Se opgave</p>","text":""},{"location":"155_ASync.html#brug-af-async-og-await-til-asynkrone-action-delegates","title":"Brug af async og await til asynkrone action delegates <p>Der er masser metoder i frameworket som fra Microsofts side er kodet asynkront - is\u00e6r metoder relateret til IO, HTTP og databaser. Mange af disse returnerer en Task (og ikke en Task\\&lt;T&gt;), og kan dermed awaites. Her er et eksempler:</p> <pre><code>await System.IO.File.WriteAllTextAsync(@\"c:\\temp\\test.txt\", \"test\");\n</code></pre> <p>Koden afventer at der gemmes en fil asynkront. Det kunne ogs\u00e5 skrives som:</p> <pre><code>Task task = System.IO.File.WriteAllTextAsync(@\"c:\\temp\\test.txt\", \"test\");\nawait task;\n</code></pre> <p>Nu gemmes Task-objektet som s\u00e5 afventes.</p>  <p>Husk - at asynkron kode i en konsol applikation ikke altid giver den helt store mening. Applikationen \u201claver\u201d jo ikke noget alligevel medens den venter! Hvis der nu var tale om at s\u00e6tte flere tr\u00e5de igang samtidigt og s\u00e5 afventet dem alle sammen giver det mere mening - herom senere.</p>","text":""},{"location":"155_ASync.html#brug-af-async-og-await-til-asynkrone-func-delegates","title":"Brug af async og await til asynkrone func delegates  <p>Hvis der er tale om en asynkton metode der returnerer noget benyttes Task\\&lt;T&gt; klassen. Hvis man benytter await er resultatet jo allerede kendt, og man kan derfor tildele det direkte til en variabel af den korrekte type.</p> <pre><code>string txt = await System.IO.File.ReadAllTextAsync(@\"c:\\temp\\test.txt\");\nstring[] linjer = await System.IO.File.ReadAllLinesAsync(@\"c:\\temp\\test.txt\");\n</code></pre> <p>Du kan ogs\u00e5 gemme Task-objektet og await\u2019e det:</p> <pre><code>Task&lt;string&gt; t1 = System.IO.File.ReadAllTextAsync(@\"c:\\temp\\test.txt\");\nstring txt = await t1;\n\nTask&lt;string[]&gt; t2 = System.IO.File.ReadAllLinesAsync(@\"c:\\temp\\test.txt\");\nstring[] linjer = await t2;\n</code></pre>   <p>Info</p>    <p>Info</p>","text":""},{"location":"155_ASync.html#opgave-155-2","title":"Opgave 155-2 <p>Hent et tilf\u00e6ldigt tal fra random.org og gem det i en fil - asynkront (kode til s\u00f8gning: BFFC)</p> <p>Se opgave</p>","text":""},{"location":"155_ASync.html#opgave-155-3","title":"Opgave 155-3 <p>Brug async/await til at hente tilf\u00e6ldige brugere fra filltext.com (kode til s\u00f8gning: BFFD)</p> <p>Se opgave</p>","text":""},{"location":"155_ASync.html#afvent-flere-task-objekter","title":"Afvent flere Task-objekter <p>Der kan v\u00e6re flere \u00e5rsager til, at afvente at mere end en Task er afviklet f\u00e6rdig. Forestil dig at du skal hente tre tilf\u00e6ldige tal fra random.org og finde summen at disse.</p> <pre><code>using System;\nusing System.Net.Http;\nusing System.Threading.Tasks;\n\nnamespace MinTest\n{\n    class Program\n    {\n        static async Task Main(string[] args)\n        {\n            string url = \"https://www.random.org/integers/?num=1&amp;min=1&amp;max=6&amp;col=1&amp;base=10&amp;format=plain&amp;rnd=new\";\n            Console.WriteLine(\"Start program\");\n            using (HttpClient w = new HttpClient())\n            {\n                var s = System.Diagnostics.Stopwatch.StartNew();\n                Console.WriteLine(\"Finder numre fra random.org\");\n                string txt1 = await w.GetStringAsync(url);\n                string txt2 = await w.GetStringAsync(url);\n                string txt3 = await w.GetStringAsync(url);\n                s.Stop();\n                Console.WriteLine(\"Tid = \" + s.ElapsedMilliseconds);\n                int sum = Convert.ToInt32(txt1) + Convert.ToInt32(txt2) + Convert.ToInt32(txt3);\n                Console.WriteLine(\"Sum \" + sum);\n\n            }\n            Console.WriteLine(\"Slut program\");\n        }\n    }\n}\n</code></pre> <p>Det vil jo l\u00f8se opgaven - men hvert kald til DownloadStringTaskAsync venter jo p\u00e5 det forrige. Metoden tager derfor noget tid.</p> <pre><code>Start program\nFinder numre fra random.org\nTid = 947\nSum 6\nSlut program\n</code></pre> <p>Heldigvis indholder Task-klassen foreskellige statiske metoder som kan v\u00e6re brugbare - herunder:</p> <ul> <li>WhenAll(\u2026) (n\u00e5r alle task er afviklet)</li> <li>WhenAny(\u2026) (n\u00e5r en task enkelt er afviklet)</li> </ul> <p>Begge returnerer en ny Task, og tager som argumenter et antal task.</p> <p>WhenAll kunne benyttes i vores eksempel:</p> <pre><code>using System;\nusing System.Net.Http;\nusing System.Threading.Tasks;\n\nnamespace MinTest\n{\n    class Program\n    {\n        static async Task Main(string[] args)\n        {\n            string url = \"https://www.random.org/integers/?num=1&amp;min=1&amp;max=6&amp;col=1&amp;base=10&amp;format=plain&amp;rnd=new\";\n            Console.WriteLine(\"Start program\");\n            using (HttpClient w = new HttpClient())\n            {\n                var s = System.Diagnostics.Stopwatch.StartNew();\n                Console.WriteLine(\"Finder numre fra random.org\");\n                Task&lt;string&gt; t1 = w.GetStringAsync(url);\n                Task&lt;string&gt; t2 = w.GetStringAsync(url);\n                Task&lt;string&gt; t3 = w.GetStringAsync(url);\n                var r = await Task.WhenAll(t1, t2, t3);\n                s.Stop();\n                Console.WriteLine(\"Tid = \" + s.ElapsedMilliseconds);\n                int sum = Convert.ToInt32(r[0]) + Convert.ToInt32(r[1]) + Convert.ToInt32(r[2]);\n                Console.WriteLine(\"Sum \" + sum);\n\n            }\n            Console.WriteLine(\"Slut program\");\n        }\n    }\n}\n</code></pre> <p>Nu vil du ogs\u00e5 kunne se fordelen ved de asynkrone kald - koden er noget hurtigere end den forrige.</p> <pre><code>Start program\nFinder numre fra random.org\nTid = 588\nSum 14\nSlut program\n</code></pre>   <p>Info</p>","text":""},{"location":"155_ASync.html#opgave-155-4","title":"Opgave 155-4 <p>Hent HTML og gem i tre forskellige filer (kode til s\u00f8gning: BFFE)</p> <p>Se opgave</p>","text":""},{"location":"155_ASync.html#exceptions","title":"Exceptions <p>Fejlh\u00e5ndtering og tr\u00e5de er normalt noget rod men async og await g\u00f8r det simpelt og effektivt - du skal bare benytte try/catch som du plejer - exception flyttes til hovedtr\u00e5den. Det g\u00e6lder dog kun hvis der kun er en tr\u00e5d. Hvis en tr\u00e5d opretter en anden tr\u00e5d, og der sker en fejl i denne kan der v\u00e6re et problem som skal h\u00e5ndteres anderledes.</p> <pre><code>using System;\nusing System.Threading.Tasks;\n\nnamespace MinTest\n{\n    class Program\n    {\n        static async Task Main(string[] args)\n        {\n            try\n            {\n                int tal = await FindTal();\n                Console.WriteLine(tal);\n            }\n            catch (Exception ex)\n            {\n                Console.WriteLine(ex.ToString());\n            }\n        }\n\n        static Task&lt;int&gt; FindTal() {\n            Task&lt;int&gt; t = Task&lt;int&gt;.Run(() =&gt; {\n                System.Random r = new Random();\n                // simulerer en fejl\n                throw new ApplicationException(\"Hov - fejl i FindTal\");\n                return r.Next(1, 101);\n            });\n            return t;\n        }\n    }\n}\n</code></pre>","text":""},{"location":"155_ASync.html#best-pratice-ved-threading","title":"Best pratice ved threading <ul> <li>Undg\u00e5 at mixe sync og async kode</li> <li>Undg\u00e5 brugen af Wait og Result</li> <li>Brug await</li> <li>Hvis man skal bruge async kode fra sync kode s\u00e5 brug GetAwaiter().GetResult()<ul> <li>Bedre fejlh\u00e5ndtering</li> </ul> </li> <li>Overvej ConfigureAwait(false) hvis den nye tr\u00e5d ikke skal benytte context i den gamle tr\u00e5d efter afvikling</li> <li>Men pas p\u00e5<ul> <li>Giver mest mening i WinForm eller MVC</li> </ul> </li> <li>Undg\u00e5 async void</li> <li>Problemer med fejlh\u00e5ndtering</li> <li>Brug Task, Task\\&lt;T&gt;</li> </ul>","text":""},{"location":"155_ASync.html#oprettelse-af-en-task","title":"Oprettelse af en Task <p>Der er flere m\u00e5der at oprette en Task p\u00e5</p> <pre><code>// using System.Threading.Tasks;\nTask task1 = new Task(Method1);\n\nvoid Method1()\n{\n    Console.WriteLine(\"task1\");\n}\n\n\n// Gammel syntaks - brug lambda (=&gt;)\nTask task2 = new Task(delegate\n{\n    Console.WriteLine(\"task2\");\n});\n\nTask task3 = new Task(() =&gt; Console.WriteLine(\"task3\"));\n\n// oprettes og afvikles direkte!!\nTask tast4 = Task.Run(() =&gt; Console.WriteLine(\"task4\"));\n\nConsole.WriteLine(\"Tryk en tast for at afslutte\");\nConsole.ReadKey();\n</code></pre> <p>Hvis ovenn\u00e6vnte kode afvikles udskrives \u201ctask4\u201d fordi det er den eneste som reelt er startet ved hj\u00e6lp af Run-metoden.</p> <p>Task er generisk s\u00e5 man kan ogs\u00e5 oprette en Task som p\u00e5 et tidspunkt - m\u00e5ske - returnerer en konkret v\u00e6rdi.</p> <p>Her er et eksempel p\u00e5 Task\\&lt;int&gt;:</p> <pre><code>using System;\nusing System.Threading.Tasks;\n\nnamespace MinTest\n{\n    class Program\n    {\n        static async Task Main(string[] args)\n        {\n\n            int t1 = FindTilf\u00e6ldigTerningV\u00e6rdi();\n            Console.WriteLine($\"t1 = {t1}\");\n\n            Task&lt;int&gt; t2 = FindTilf\u00e6ldigTerningV\u00e6rdiASync();\n            Console.WriteLine($\"t2 status = {t2.Status}\");\n            Console.WriteLine(\"Tryk en tast for at forts\u00e6tte\");\n            Console.ReadKey();\n            Console.WriteLine($\"t2 status = {t2.Status}\");\n            if(t2.Status== TaskStatus.RanToCompletion)\n                Console.WriteLine($\"t2 = {t2.Result}\");\n\n            int t3 = await FindTilf\u00e6ldigTerningV\u00e6rdiASync().ConfigureAwait(false);\n            Console.WriteLine($\"t3 = {t3}\");\n\n            Console.WriteLine(\"Tryk en tast for at afslutte\");\n            Console.ReadKey();\n        }\n\n        private static int FindTilf\u00e6ldigTerningV\u00e6rdi()\n        {\n            return new Random().Next(1, 7);\n        }\n\n        private static Task&lt;int&gt; FindTilf\u00e6ldigTerningV\u00e6rdiASync()\n        {\n            return Task&lt;int&gt;.Run(() =&gt; new Random().Next(1, 7));\n        }\n    }\n}\n</code></pre> <p>Bem\u00e6rk at:</p> <ul> <li>FindTilf\u00e6ldigTerningV\u00e6rdi() er en almindelig synkron metode</li> <li>FindTilf\u00e6ldigTerningV\u00e6rdiASync() er en async metode som returnerer en Task\\&lt;int&gt;</li> <li>(N\u00e5r metoden engang er afviklet f\u00e6rdig kan resultatet afl\u00e6ses som en int)</li> <li>Resultatet t1 (int) findes synkront</li> <li>Resultatet t2 (Task) har en status</li> <li>F\u00f8rst WaitingToRun</li> <li>Herefter RanToCompletion</li> <li>Resultat kan nu afl\u00e6ses med Result<ul> <li>!! Result (eller Wait) b\u00f8r ikke benyttes (brug await). Det er blot et eksempel</li> </ul> </li> <li>Resultatet t3 (int) bliver tildelt en v\u00e6rdi automatisk n\u00e5r Task er f\u00e6rdig</li> </ul> <p>Her er et andet eksempel p\u00e5 Task\\&lt;string&gt;:</p> <pre><code>using System;\nusing System.Threading.Tasks;\n\nnamespace MinTest\n{\n    class Program\n    {\n        static async Task Main(string[] args)\n        {\n\n            string indhold = await System.IO.File.ReadAllTextAsync(@\"c:\\temp\\data.txt\");\n            Console.WriteLine(indhold);\n            Console.WriteLine(\"Tryk en tast for at afslutte\");\n            Console.ReadKey();\n        }\n\n    }\n}\n</code></pre>","text":""},{"location":"155_ASync.html#afvikling-af-en-task","title":"Afvikling af en Task <pre><code>using System;\nusing System.Threading;\nusing System.Threading.Tasks;\n\nnamespace MinTest\n{\n    class Program\n    {\n        static async Task Main(string[] args)\n        {\n            Task task1 = Task.Run(async () =&gt; {\n                await Task.Delay(2000);\n            });\n            Console.WriteLine(\"1 \" + task1.Status);\n            Console.ReadKey();\n            Console.WriteLine(\"2 \" + task1.Status);\n            Console.ReadKey();\n            Console.WriteLine(\"3 \" + task1.Status);\n\n        }\n    }\n}\n</code></pre>   <p>Info</p>    <p>Info</p>","text":""},{"location":"155_ASync.html#opgave-155-5","title":"Opgave 155-5 <p>\u00d8v dig p\u00e5 brug af Task og async/await gennem IO-operationer. (kode til s\u00f8gning: BFFF)</p> <p>Se opgave</p>","text":""},{"location":"155_ASync.html#opgave-155-6","title":"Opgave 155-6 <p>Her kan du \u00f8ve dig lidt p\u00e5 at skabe metoder der returnerer en Task (kode til s\u00f8gning: BFFG)</p> <p>Se opgave</p>","text":""},{"location":"155_ASync.html#cancellation","title":"Cancellation <p>Man kan benytte en CancellationToken som ved hj\u00e6lp af en CancellationTokenSource-instans kan afbryde.</p> <pre><code>CancellationTokenSource tokenSource = new CancellationTokenSource();\nConsole.WriteLine(\"Start\");\ntokenSource.Cancel();\nvar t = Task.Run(() =&gt; {\n    Console.WriteLine(\"Arbejde...\");\n}, tokenSource.Token);\nt.ContinueWith(task =&gt; {\n    switch (task.Status)\n    {\n        case TaskStatus.Canceled:\n            Console.WriteLine(\"Afbrudt\");\n            break;\n        case TaskStatus.RanToCompletion:\n            Console.WriteLine(\"Slut\");\n            break;\n    }\n});\n</code></pre>","text":""},{"location":"155_ASync.html#progress","title":"Progress <p>Burg IProgress til at give besked retur.</p> <pre><code>using System;\nusing System.Diagnostics;\nusing System.Linq;\nusing System.Net.Http;\nusing System.Threading;\nusing System.Threading.Tasks;\n\nnamespace MinTest\n{\n    class Program\n    {\n        static HttpClient httpClient = new HttpClient();\n\n        static async Task Main(string[] args)\n        {\n            int antal = 50, min = 1, max = 10;\n            Stopwatch s = new Stopwatch();\n            s.Start();\n            var progress = new Progress&lt;double&gt;(nr =&gt; Console.WriteLine(nr.ToString(\"P\")));\n            var sum = await FindSumAsync(min, max, antal, progress);\n            s.Stop();\n            Console.WriteLine(\"Sum: \" + sum);\n            Console.WriteLine(\"Ms:  \" + s.ElapsedMilliseconds);\n\n            Console.WriteLine();\n\n            s.Restart();\n            sum = 0;\n            sum = await FindSumParallelAsync(min, max, antal, progress);\n            s.Stop();\n            Console.WriteLine(\"Sum: \" + sum);\n            Console.WriteLine(\"Ms:  \" + s.ElapsedMilliseconds);\n\n        }\n\n        // Klassisk\n        static async Task&lt;int&gt; FindSumAsync(int min, int max, int antal, IProgress&lt;double&gt; progress = null)\n        {\n\n            int sum = 0;\n            for (int i = 0; i &lt; antal; i++)\n            {\n                progress?.Report((i+1) / Convert.ToDouble(antal));\n                string nr = await httpClient.GetStringAsync($\"https://www.random.org/integers/?num=1&amp;min={min}&amp;max={max}&amp;col=1&amp;base=10&amp;format=plain&amp;rnd=new\");\n                sum += Convert.ToInt32(nr);\n            }\n            return sum;\n        }\n\n        // C# 10\n        static async Task&lt;int&gt; FindSumParallelAsync(int min, int max, int antal, IProgress&lt;double&gt; progress = null)\n        {\n\n            var liste = Enumerable.Range(0, antal).ToList();\n            int sum = 0;\n            int i = 0;\n            await Parallel.ForEachAsync(liste, async (nummer, cancel) =&gt;\n            {\n                i++;\n                progress?.Report(i / Convert.ToDouble(antal));\n                string nr = await httpClient.GetStringAsync($\"https://www.random.org/integers/?num=1&amp;min={min}&amp;max={max}&amp;col=1&amp;base=10&amp;format=plain&amp;rnd=new\");\n                sum += Convert.ToInt32(nr);\n            });\n            return sum;\n        }\n    }\n}\n</code></pre>","text":""},{"location":"155_ASync.html#lock","title":"Lock <p>F\u00f8lgende kode er et problem for n aldrig vil f\u00e5 samme resultat (bliver p\u00e5virket fra to tr\u00e5de)</p> <pre><code>static void Lock1()\n{\n    int n = 0;\n\n    var t = Task.Run(() =&gt; {\n        for (int i = 0; i &lt; 1000000; i++)\n            n++;\n    });\n\n    for (int i = 0; i &lt; 1000000; i++)\n        n--;\n\n    t.Wait();\n    Console.WriteLine(n);\n\n}\n</code></pre> <ul> <li>kan l\u00f8ses ved lock som l\u00e5ser den tr\u00e5d hvor lock-objektet er skabt</li> </ul> <pre><code>static void Lock2()\n{\n    int n = 0;\n    object _lock = new object();\n    var t = Task.Run(() =&gt; {\n        for (int i = 0; i &lt; 1000000; i++)\n            lock (_lock)\n                n++;\n    });\n\n    for (int i = 0; i &lt; 1000000; i++)\n        lock (_lock)\n            n--;\n\n\n    t.Wait();\n    Console.WriteLine(n);\n\n}\n</code></pre> <ul> <li>kan evt ogs\u00e5 benytte Interlocked-objektet som indholde simple metoder til at arbejde med atomare variabler. Brug lock ved mere komplicerede operationer</li> </ul> <pre><code>static void Lock2a()\n{\n    int n = 0;\n\n    var t = Task.Run(() =&gt; {\n        for (int i = 0; i &lt; 1000000; i++)\n            Interlocked.Increment(ref n);\n    });\n\n    for (int i = 0; i &lt; 1000000; i++)\n        Interlocked.Decrement(ref n);\n\n    t.Wait();\n    Console.WriteLine(n);\n\n}\n</code></pre>","text":""},{"location":"155_ASync.html#deadlock-som-begreb","title":"Deadlock som begreb","text":"<ul> <li>man skal passe en del p\u00e5 lock og s\u00f8rge for frigive lock i samme r\u00e6kkef\u00f8lge</li> <li>a venter p\u00e5 at b bliver frigivet, og b venter p\u00e5 at a bliver frigivet</li> <li>eksempel p\u00e5 deadlock<ul> <li>(pr\u00f8v det evt i WinForm eller lign med en \u201clevende\u201d UI tr\u00e5d)</li> </ul> </li> <li>is\u00e6r brugen af async void og manglende brug af async/await kan give udfordringer</li> </ul> <pre><code>static void Lock3()\n{\nobject a = new object();\nobject b = new object();\nvar t = Task.Run(() =&gt; {\nlock (a) {\nThread.Sleep(1000);\n// kode\nlock (b) {\n// kode\n}\n}\n});\nlock (b) {\n// kode\nlock (a) {\n// kode\n}\n}\nt.Wait();\n}\n</code></pre>"},{"location":"155_ASync.html#async-streams","title":"Async streams <p>En del af C# 8 er muligheden for at benytte async stream (yield og foreach). Det er en af de mere avancerede features, men her er et simpelt eksempel.</p> <pre><code>using System;\nusing System.Collections.Generic;\nusing System.Net.Http;\nusing System.Threading.Tasks;\n\nnamespace Demo\n{\n    class Program\n    {\n        private static HttpClient client = new HttpClient();\n        static async Task Main(string[] args)\n        {\n            await foreach (var item in FindTerningV\u00e6rdiASync(30))\n            {\n                Console.WriteLine(item);\n            }\n        }\n\n        static async IAsyncEnumerable&lt;int&gt; FindTerningV\u00e6rdiASync(int antal)\n        {\n            for (int i = 0; i &lt; antal; i++)\n            {\n                string tal = await client.GetStringAsync(\"https://www.random.org/integers/?num=1&amp;min=1&amp;max=6&amp;col=1&amp;base=10&amp;format=plain&amp;rnd=new\");\n                yield return Convert.ToInt32(tal);\n            }\n        }\n    }\n}\n</code></pre>","text":""},{"location":"155_ASync.html#task-parallel-library","title":"Task Parallel Library <p>TPL er en abstraktion over System.Threading med det form\u00e5l at udnytte flere kerner i en CPU til \u2018\u00e6gte\u2019 parallel kode. Der er flere metoder - herunder Invoke, For, ForEach, ForAsync mv. Her er et eksempel p\u00e5 brug af Invoke, For og ForAsync (C# 6):</p> <pre><code>using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Threading.Tasks;\n\nnamespace MinTest\n{\n    class Program\n    {\n        static async Task Main(string[] args)\n        {\n            char tegn ='a';\n            int antal = 4;\n\n\n            Console.WriteLine(\"Synkront\");\n            FindGuid(tegn, antal);\n            FindGuid(tegn, antal);\n            FindGuid(tegn, antal);\n\n            Console.WriteLine(\"Parallelt\");\n            Parallel.Invoke(() =&gt;\n            {\n                FindGuid(tegn, antal);\n            }, () =&gt;\n            {\n                FindGuid(tegn, antal);\n            }, () =&gt;\n            {\n                FindGuid(tegn, antal);\n            });\n\n            ParallelOptions parallelOptions = new()\n            {\n                MaxDegreeOfParallelism = 3\n            };\n\n            Console.WriteLine(\"Parallelt med for\");\n            Parallel.For(1, 4, parallelOptions, nr =&gt; FindGuid(tegn, antal));\n\n            Console.WriteLine(\"Parallelt med ForeachAsync\");\n\n            IEnumerable&lt;int&gt; a = Enumerable.Range(1, 3);\n            await Parallel.ForEachAsync(a, parallelOptions, async (c, i) =&gt; {\n                await FindGuidAsync(tegn, antal);\n            });\n\n            Console.WriteLine(\"Samtidigt\");\n            await Task.WhenAll(FindGuidAsync(tegn, antal), FindGuidAsync(tegn, antal), FindGuidAsync(tegn, antal));\n\n        }\n\n        static void FindGuid(char tegn, int antal)\n        {\n            string guid;\n            int i = 0;\n            System.Diagnostics.Stopwatch sw = new System.Diagnostics.Stopwatch();\n            sw.Start();\n            do\n            {\n                guid = Guid.NewGuid().ToString();\n                i++;\n            } while (!guid.StartsWith(new string(tegn, antal)));\n            sw.Stop();\n            Console.WriteLine($\"Guid {guid} fundet p\u00e5 {i} fors\u00f8g p\u00e5 {sw.ElapsedMilliseconds} ms\");\n        }\n\n        static async Task FindGuidAsync(char tegn, int antal)\n        {\n            await Task.Run(() =&gt;\n            {\n                string guid;\n                int i = 0;\n                System.Diagnostics.Stopwatch sw = new System.Diagnostics.Stopwatch();\n                sw.Start();\n                do\n                {\n                    guid = Guid.NewGuid().ToString();\n                    i++;\n                } while (!guid.StartsWith(new string(tegn, antal)));\n                sw.Stop();\n                Console.WriteLine($\"Guid {guid} fundet p\u00e5 {i} fors\u00f8g p\u00e5 {sw.ElapsedMilliseconds} ms\");\n            });\n        }\n    }\n}\n</code></pre>","text":""},{"location":"155_ASync.html#tilstandsmaskine","title":"Tilstandsmaskine <p>Hvis du vil se koden bag tilstandsmaskinen (async) kan du eventuelt bruge https://sharplab.io med f\u00f8lgende</p> <pre><code>using System;\nusing System.Net.Http;\nusing System.Threading.Tasks;\n\nnamespace async_henttaloggem\n{\n    class Program\n    {\n        static async Task Main(string[] args)\n        {\n            Console.WriteLine(\"1\");\n            await Test1();\n            Console.WriteLine(\"3\");\n            await Test2();\n            Console.WriteLine(\"5\");\n        }\n\n        static Task Test1()\n        {\n            return Task.Run(() =&gt; {\n                Console.WriteLine(\"2\");\n            });\n        }\n\n        static Task Test2()\n        {\n            return Task.Run(() =&gt; {\n                Console.WriteLine(\"4\");\n            });\n        }\n\n    }\n}\n</code></pre> <p>Pr\u00f8v evt at rette Test2 til</p> <pre><code>static async Task Test2()\n{\n    await Task.Run(() =&gt; {\n        Console.WriteLine(\"4\");\n    });\n}\n</code></pre> <p>og bem\u00e6rk at der genereres en ekstra tilstandsmaskine.</p>","text":""},{"location":"160_XML.html","title":"Kommunikation med XML","text":""},{"location":"160_XML.html#om-modulet","title":"Om modulet","text":"<p>Dette modul vil introducere dig til brugen af XML p\u00e5 forskellige m\u00e5der i C#.</p>"},{"location":"160_XML.html#systemxml","title":"System.XML","text":"<p>Brug af den \u201cgamle\u201d System.Xml.Document klasse</p> <p>Helt grundl\u00e6ggende brug:</p> <ul> <li>Load (loader fil)</li> <li>LoadXml (loader string)</li> <li>DocumentElement (rod)</li> <li>SelectSingleNode (returnerer en enkelt node via XPath)</li> <li>SelectNodes (returnerer flere noder via XPath)</li> </ul> <p>En enkelt node kan v\u00e6re repr\u00e6senteret med XmlNode som beat\u00e5r af </p> <ul> <li>InnerText</li> <li>Attributtes</li> <li>SelectSingleNode (returnerer en enkelt node via XPath)</li> <li>SelectNodes (returnerer flere noder via XPath)</li> </ul>"},{"location":"160_XML.html#til-test","title":"Til test","text":"<p><pre><code>&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n\n&lt;bookstore&gt;\n\n&lt;book category=\"cooking\"&gt;\n  &lt;title lang=\"en\"&gt;Everyday Italian&lt;/title&gt;\n  &lt;author&gt;Giada De Laurentiis&lt;/author&gt;\n  &lt;year&gt;2005&lt;/year&gt;\n  &lt;price&gt;30.00&lt;/price&gt;\n&lt;/book&gt;\n\n&lt;book category=\"children\"&gt;\n  &lt;title lang=\"en\"&gt;Harry Potter&lt;/title&gt;\n  &lt;author&gt;J K. Rowling&lt;/author&gt;\n  &lt;year&gt;2005&lt;/year&gt;\n  &lt;price&gt;29.99&lt;/price&gt;\n&lt;/book&gt;\n\n&lt;book category=\"web\"&gt;\n  &lt;title lang=\"en\"&gt;XQuery Kick Start&lt;/title&gt;\n  &lt;author&gt;James McGovern&lt;/author&gt;\n  &lt;author&gt;Per Bothner&lt;/author&gt;\n  &lt;author&gt;Kurt Cagle&lt;/author&gt;\n  &lt;author&gt;James Linn&lt;/author&gt;\n  &lt;author&gt;Vaidyanathan Nagarajan&lt;/author&gt;\n  &lt;year&gt;2003&lt;/year&gt;\n  &lt;price&gt;49.99&lt;/price&gt;\n&lt;/book&gt;\n\n&lt;book category=\"web\"&gt;\n  &lt;title lang=\"en\"&gt;Learning XML&lt;/title&gt;\n  &lt;author&gt;Erik T. Ray&lt;/author&gt;\n  &lt;year&gt;2003&lt;/year&gt;\n  &lt;price&gt;39.95&lt;/price&gt;\n&lt;/book&gt;\n\n&lt;/bookstore&gt;\n</code></pre> ref</p>"},{"location":"160_XML.html#grundlggende-xpath-syntax","title":"Grundl\u00e6ggende XPath syntax","text":"<p><pre><code>//title[@lang]  \nSelects all the title elements that have an attribute named lang\n\n//title[@lang='en'] \nSelects all the title elements that have a \"lang\" attribute with a value of \"en\"\n\n/bookstore/book[1]  \nSelects the first book element that is the child of the bookstore element\n\n/bookstore/book[last()] \nSelects the last book element that is the child of the bookstore element\n\n/bookstore/book[last()-1]\nSelects the last but one book element that is the child of the bookstore element\n\n/bookstore/book[position()&lt;3]   \nSelects the first two book elements that are children of the bookstore element\n\n/bookstore/book[price&gt;35.00]    \nSelects all the book elements of the bookstore element that have a price element with a value greater than 35.00\n\n/bookstore/book[price&gt;35.00]/title  \nSelects all the title elements of the book elements of the bookstore element that have a price element with a value greater than 35.00\n</code></pre> ref</p>"},{"location":"160_XML.html#linq-to-xml","title":"LINQ to XML","text":"<ul> <li>In memory programmering interface til XML data</li> <li>L\u00e6s og opret XML</li> </ul>"},{"location":"160_XML.html#med-udgangspunkt-i-denne","title":"Med udgangspunkt i denne","text":"<pre><code>&lt;?xml version=\"1.0\" encoding=\"utf-8\" ?&gt;\n&lt;personer&gt;\n&lt;person id=\"1\"&gt;\n&lt;navn&gt;Mikkel&lt;/navn&gt;\n&lt;alder&gt;15&lt;/alder&gt;\n&lt;/person&gt;\n&lt;person id=\"2\"&gt;\n&lt;navn&gt;Mathias&lt;/navn&gt;\n&lt;alder&gt;12&lt;/alder&gt;\n&lt;/person&gt;\n&lt;person id=\"3\"&gt;\n&lt;navn&gt;Lene&lt;/navn&gt;\n&lt;alder&gt;51&lt;/alder&gt;\n&lt;/person&gt;\n&lt;/personer&gt;\n</code></pre>"},{"location":"160_XML.html#load-data","title":"Load data","text":"<ul> <li>Brug Load for at hente XML til en samling af XElement</li> <li>Brug Where, Order, Group til at skabe et udtryk</li> </ul> <pre><code>// kr\u00e6ver using System.Xml.Linq og using System.Linq;\n// Hele dokumentet\nXDocument doc = XDocument.Load(@\"data.xml\");\nforeach (var item in doc.Elements())\n{\nConsole.WriteLine(item);\n}\nConsole.WriteLine();\n// Del af dokumentet\nIEnumerable&lt;XElement&gt; personer = XElement.Load(@\"data.xml\").Elements();\nforeach (var item in personer)\n{\nConsole.WriteLine(item);\n}\n/*\n ---------- Output: ----------\n&lt;personer&gt;\n  &lt;person id=\"1\"&gt;\n    &lt;navn&gt;Mikkel&lt;/navn&gt;\n    &lt;alder&gt;15&lt;/alder&gt;\n  &lt;/person&gt;\n  &lt;person id=\"2\"&gt;\n    &lt;navn&gt;Mathias&lt;/navn&gt;\n    &lt;alder&gt;12&lt;/alder&gt;\n  &lt;/person&gt;\n  &lt;person id=\"3\"&gt;\n    &lt;navn&gt;Lene&lt;/navn&gt;\n    &lt;alder&gt;51&lt;/alder&gt;\n  &lt;/person&gt;\n&lt;/personer&gt;\n&lt;person id=\"1\"&gt;\n  &lt;navn&gt;Mikkel&lt;/navn&gt;\n  &lt;alder&gt;15&lt;/alder&gt;\n&lt;/person&gt;\n&lt;person id=\"2\"&gt;\n  &lt;navn&gt;Mathias&lt;/navn&gt;\n  &lt;alder&gt;12&lt;/alder&gt;\n&lt;/person&gt;\n&lt;person id=\"3\"&gt;\n  &lt;navn&gt;Lene&lt;/navn&gt;\n  &lt;alder&gt;51&lt;/alder&gt;\n&lt;/person&gt;\n*/\n</code></pre>"},{"location":"160_XML.html#ls-data","title":"L\u00e6s data","text":"<ul> <li>Brug element Value til at l\u00e6se data</li> </ul> <pre><code>// kr\u00e6ver using System.Xml.Linq og using System.Linq;\n// Hele dokumentet\nvar doc = XElement.Load(@\"data.xml\").Descendants(\"person\");\nforeach (var item in doc)\nConsole.WriteLine(item.Element(\"navn\").Value);\n/*\n ---------- Output: ----------\nMikkel\nMathias\nLene\n*/\n</code></pre>"},{"location":"160_XML.html#find-data","title":"Find data","text":"<ul> <li>Brug where og order mv til at finde data</li> </ul> <pre><code>// kr\u00e6ver using System.Xml.Linq og using System.Linq;\nXElement personer = XElement.Load(@\"data.xml\");\nConsole.WriteLine(personer);\nvar res1 = from node in personer.Descendants(\"person\")\nwhere (int)node.Element(\"alder\") &gt; 13 orderby (int)node.Element(\"alder\") descending select node;\nvar res2 = personer.Descendants(\"person\").Where(i =&gt; (int)i.Element(\"alder\") &gt; 13)\n.OrderByDescending(i =&gt; (int)i.Element(\"alder\")); ;\nConsole.WriteLine();\nforeach (var item in res1)\n{\nConsole.WriteLine(item.Element(\"navn\").Value);\n}\nConsole.WriteLine();\nforeach (var item in res2)\n{             Console.WriteLine(item.Element(\"navn\").Value);\n}\n/*\n ---------- Output: ----------\n&lt;personer&gt;\n  &lt;person id=\"1\"&gt;\n    &lt;navn&gt;Mikkel&lt;/navn&gt;\n    &lt;alder&gt;15&lt;/alder&gt;\n  &lt;/person&gt;\n  &lt;person id=\"2\"&gt;\n    &lt;navn&gt;Mathias&lt;/navn&gt;\n    &lt;alder&gt;12&lt;/alder&gt;\n  &lt;/person&gt;\n  &lt;person id=\"3\"&gt;\n    &lt;navn&gt;Lene&lt;/navn&gt;\n    &lt;alder&gt;51&lt;/alder&gt;\n  &lt;/person&gt;\n&lt;/personer&gt;\nLene\nMikkel\nLene\nMikkel\n*/\n</code></pre> <pre><code>// kr\u00e6ver using System.Xml.Linq og using System.Linq;\nXElement personer = XElement.Load(@\"data.xml\");\nConsole.WriteLine(personer);\nvar res1 = from node in personer.Descendants(\"person\")\nwhere (int)node.Attribute(\"id\") ==1 select node;\nvar res2 = personer.Descendants(\"person\").Where(i =&gt; (int)i.Attribute(\"id\") == 1);\nConsole.WriteLine();\nforeach (var item in res1)\n{\nConsole.WriteLine(item.Element(\"navn\").Value);\n}\nConsole.WriteLine();\nforeach (var item in res2)\n{\nConsole.WriteLine(item.Element(\"navn\").Value);\n}\n/*\n ---------- Output: ----------\n&lt;personer&gt;\n  &lt;person id=\"1\"&gt;\n    &lt;navn&gt;Mikkel&lt;/navn&gt;\n    &lt;alder&gt;15&lt;/alder&gt;\n  &lt;/person&gt;\n  &lt;person id=\"2\"&gt;\n    &lt;navn&gt;Mathias&lt;/navn&gt;\n    &lt;alder&gt;12&lt;/alder&gt;\n  &lt;/person&gt;\n  &lt;person id=\"3\"&gt;\n    &lt;navn&gt;Lene&lt;/navn&gt;\n    &lt;alder&gt;51&lt;/alder&gt;\n  &lt;/person&gt;\n&lt;/personer&gt;\nMikkel\nMikkel\n*/\n</code></pre>"},{"location":"160_XML.html#opret-data","title":"Opret data","text":"<pre><code>// kr\u00e6ver using System.Xml.Linq og using System.Linq;\nXDocument xDoc = new XDocument(\nnew XDeclaration(\"1.0\", \"UTF-16\", null),\nnew XElement(\"Personer\",\nnew XElement(\"Person\",\nnew XComment(\"Kommentar\"),\nnew XElement(\"Id\", \"1\"),\nnew XElement(\"Navn\", \"Mathias\")                    )));\nConsole.WriteLine(xDoc);\n/*\n ---------- Output: ----------\n&lt;Personer&gt;\n  &lt;Person&gt;\n    &lt;!--Kommentar--&gt;\n    &lt;Id&gt;1&lt;/Id&gt;\n    &lt;Navn&gt;Mathias&lt;/Navn&gt;\n  &lt;/Person&gt;\n&lt;/Personer&gt;\n*/\n</code></pre>"},{"location":"160_XML.html#manipulering","title":"Manipulering","text":"<ul> <li>Opdater, slet, tilf\u00f8j</li> </ul> <pre><code>// kr\u00e6ver using System.Xml.Linq og using System.Linq;\nXElement personer = XElement.Load(@\"data.xml\");\nConsole.WriteLine(personer);\nConsole.WriteLine();\nvar res1 = from node in personer.Descendants(\"person\")\nwhere (int)node.Attribute(\"id\") == 1\nselect node;\nres1.FirstOrDefault().Element(\"navn\").Value = \"MIKKEL\";\npersoner.Descendants(\"person\").\nWhere(i =&gt; (int)i.Attribute(\"id\") == 2)\n.FirstOrDefault().Element(\"navn\").Value = \"MATHIAS\";\nvar ny = new XElement(\"Land\", \"Danmark\", new XAttribute(\"eu\",\"true\"));\npersoner.Descendants(\"person\").\nWhere(i =&gt; (int)i.Attribute(\"id\") == 2)\n.FirstOrDefault().Add(ny);\npersoner.Descendants(\"person\").\nWhere(i =&gt; (int)i.Attribute(\"id\") == 3)\n.FirstOrDefault().Element(\"alder\").Remove();\nConsole.WriteLine(personer);\n/*\n ---------- Output: ----------\n&lt;personer&gt;\n  &lt;person id=\"1\"&gt;\n    &lt;navn&gt;Mikkel&lt;/navn&gt;\n    &lt;alder&gt;15&lt;/alder&gt;\n  &lt;/person&gt;\n  &lt;person id=\"2\"&gt;\n    &lt;navn&gt;Mathias&lt;/navn&gt;\n    &lt;alder&gt;12&lt;/alder&gt;\n  &lt;/person&gt;\n  &lt;person id=\"3\"&gt;\n    &lt;navn&gt;Lene&lt;/navn&gt;\n    &lt;alder&gt;51&lt;/alder&gt;\n  &lt;/person&gt;\n&lt;/personer&gt;\n&lt;personer&gt;\n  &lt;person id=\"1\"&gt;\n    &lt;navn&gt;MIKKEL&lt;/navn&gt;\n    &lt;alder&gt;15&lt;/alder&gt;\n  &lt;/person&gt;\n  &lt;person id=\"2\"&gt;\n    &lt;navn&gt;MATHIAS&lt;/navn&gt;\n    &lt;alder&gt;12&lt;/alder&gt;\n    &lt;Land eu=\"true\"&gt;Danmark&lt;/Land&gt;\n  &lt;/person&gt;\n  &lt;person id=\"3\"&gt;\n    &lt;navn&gt;Lene&lt;/navn&gt;\n  &lt;/person&gt;\n&lt;/personer&gt;\n*/\n</code></pre> <p>Info</p>"},{"location":"160_XML.html#opgave-160-1","title":"Opgave 160-1","text":"<p>Simpel LINQ2XML opgave (kode til s\u00f8gning: BGAB)</p> <p>Se opgave</p>"},{"location":"165_Kommunikation_med_filer.html","title":"Kommunikation med filer","text":""},{"location":"165_Kommunikation_med_filer.html#om-modulet","title":"Om modulet","text":"<p>Dette model er blot til orientering og indeholder kodeeksempler der viser hvordan man kan arbejde med filer, mappe og str\u00f8mme af data. Der findes ikke nogen video til dette modul.</p>"},{"location":"165_Kommunikation_med_filer.html#filer-og-mapper","title":"Filer og mapper","text":"<p>Der er overordnet to forskellige muligheder til at arbejde med filer og mapper</p>"},{"location":"165_Kommunikation_med_filer.html#statiske-metoder","title":"Statiske metoder","text":"<p>Meget brugbare og simple statiske metoder i:</p> <ul> <li>System.IO.File</li> <li>System.IO.Directory</li> <li>System.IO.Path</li> </ul> <pre><code>// HUSK fejlh\u00e5ndtering\n// Eksisterer\nbool res1 = System.IO.File.Exists(@\"c:\\temp\\data.txt\");\nbool res2 = System.IO.Directory.Exists(@\"c:\\temp\");\n// Opret / Skriv\nSystem.IO.Directory.CreateDirectory(@\"c:\\temp\\testmappe\");\nSystem.IO.File.WriteAllText(@\"c:\\temp\\test.txt\", \"***\");\n// Slet\nSystem.IO.Directory.Delete(@\"c:\\temp\\testmappe\");\nSystem.IO.File.Delete(@\"c:\\temp\\test.txt\");\n// L\u00e6s\nSystem.IO.File.WriteAllText(@\"c:\\temp\\data.txt\", \"*\\r\\n*\\r\\n*\");\nstring indhold1 = System.IO.File.ReadAllText(@\"c:\\temp\\data.txt\");\nstring[] indholder2 = System.IO.File.ReadAllLines(@\"c:\\temp\\data.txt\");\n// Mange andre statiske metoder!!!\n// System.IO.Path er ogs\u00e5 ret fiks\nConsole.WriteLine(System.IO.Path.GetTempFileName());\nConsole.WriteLine(System.IO.Path.GetRandomFileName());\nConsole.WriteLine(System.IO.Path.GetFileNameWithoutExtension(@\"c:\\temp\\data.txt\"));\n// Is\u00e6r Combine\nstring sti = System.IO.Path.Combine(@\"c:\\\", \"temp\", \"tmp\", \"txt.txt\");\nConsole.WriteLine(sti);\n/*\n ---------- Output: ----------\nC:\\Users\\cskonto\\AppData\\Local\\Temp\\tmpB1FB.tmp\nmxeuts12.z1p\ndata\nc:\\temp\\tmp\\txt.txt\n*/\n</code></pre>"},{"location":"165_Kommunikation_med_filer.html#instans-metoder","title":"Instans metoder","text":"<p>Her skal man skabe en instans af et objekt der repr\u00e6senterer en konkret fil eller mappe:</p> <ul> <li>System.IO.FileInfo</li> <li>System.IO.DirectoryInfo</li> </ul> <pre><code>// HUSK fejlh\u00e5ndtering\n// Test fil og mappe\nSystem.IO.Directory.CreateDirectory(@\"c:\\temp\\testmappe\");\nSystem.IO.File.WriteAllText(@\"c:\\temp\\test.txt\", \"***\");\nSystem.IO.FileInfo f = new System.IO.FileInfo(@\"c:\\temp\\test.txt\");\n// Masser af metoder og egenskaber relateret til denne fil\nConsole.WriteLine($\"FullName: {f.FullName}\");\nConsole.WriteLine($\"Name: {f.Name}\");\nConsole.WriteLine($\"Size: {f.Length}\");\nConsole.WriteLine($\"Access time: {f.LastAccessTimeUtc}\");\n// f.AppendText(...)\n// f.CopyTo(...)\n// f.Delete(...)\nSystem.IO.DirectoryInfo d = new System.IO.DirectoryInfo(@\"c:\\temp\\testmappe\");\nConsole.WriteLine($\"FullName: {d.FullName}\");\nConsole.WriteLine($\"Name: {d.Name}\");\nConsole.WriteLine($\"Access time: {d.LastAccessTimeUtc}\");\n// d.CreateSubdirectory(...)\n// d.Delete(...)\n// d.GetDirectories(...)\n// d.GetFiles(...)\n// d.MoveTo(...)\n/*\n ---------- Output: ----------\nFil c:\\temp\\testmappe oprettet\nFil c:\\temp\\testmappe oprettet\nFil c:\\temp\\test.txt oprettet\nFil c:\\temp\\test.txt oprettet\nFullName: c:\\temp\\test.txt\nName: test.txt\nSize: 3\nAccess time: 04-03-2019 15:01:39\nFullName: c:\\temp\\testmappe\nName: testmappe\nAccess time: 04-03-2019 15:01:39\n*/\n</code></pre>"},{"location":"165_Kommunikation_med_filer.html#fejlhandtering","title":"Fejlh\u00e5ndtering","text":"<ul> <li> <p>Husk fejl h\u00e5ndtering</p> <ul> <li>shit happens n\u00e5r der er tale om IO, Netv\u00e6rk mv</li> </ul> </li> </ul> <pre><code>try\n{\nif (System.IO.File.Exists(@\"c:\\temp\\test.txt\"))\n{\nSystem.IO.File.AppendAllText(@\"c:\\temp\\test.txt\", \"***\");\n}\n}\n// Mangler fejlh\u00e5ndtering!!\ncatch (System.IO.FileLoadException) { }\ncatch (System.IO.FileNotFoundException) { }\ncatch (System.IO.IOException) { }\ncatch (System.Exception ex) { }\n</code></pre>"},{"location":"165_Kommunikation_med_filer.html#streams","title":"Streams","text":"<p>Bruges til at l\u00e6se og skrive en str\u00f8m af byte</p> <ul> <li>FileStream</li> <li>TextReader</li> <li>StreamReader</li> <li>TextWriter</li> <li>StreamWriter</li> </ul> <p>Husk at bruge using (Dispose)</p> <pre><code>string fil = @\"c:\\temp\\test.txt\";\nusing (System.IO.FileStream fs = System.IO.File.OpenRead(fil))\n{\nbyte[] byteArray = new byte[fs.Length];\nfs.Read(byteArray, 0, byteArray.Length);\nConsole.WriteLine(Encoding.UTF8.GetString(byteArray));\n}\n// StreamReader er noget nemmere\nusing (System.IO.StreamReader sr = System.IO.File.OpenText(fil))\n{\nint r = 0;\ndo\n{\nchar[] buffer = new char[10];\nr = sr.ReadBlock(buffer, 0, 10);\n// G\u00f8r noget med data\n} while (r != 0);\n}\nstring txt = \"Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nam felis lorem, placerat nec tellus metus.\";\nusing (System.IO.StreamWriter sw = System.IO.File.CreateText(fil)) // eller OpenWrite\n{\nsw.WriteLine(txt);\n}\n</code></pre> <p>Info</p> <p>Info</p> <p>Info</p>"},{"location":"165_Kommunikation_med_filer.html#opgave-165-1","title":"Opgave 165-1","text":"<p>Brug af File og Directory-klasserne (kode til s\u00f8gning: BGFB)</p> <p>Se opgave</p>"},{"location":"165_Kommunikation_med_filer.html#opgave-165-2","title":"Opgave 165-2","text":"<p>Brug af FileInfo og DirectoryInfo-klasserne (kode til s\u00f8gning: BGFC)</p> <p>Se opgave</p>"},{"location":"165_Kommunikation_med_filer.html#opgave-165-3","title":"Opgave 165-3","text":"<p>Brug af StreamWriter til at gemme en stor tekstfil (kode til s\u00f8gning: BGFD)</p> <p>Se opgave</p>"},{"location":"165_Kommunikation_med_filer.html#async-io","title":"Async IO","text":"<p>B\u00e5de de statiske metoder p\u00e5 File og Directory, samt stream har async metoder. Med async/await er det rimelige simpel kode:</p> <pre><code>// Setup\nstring fil1 = @\"c:\\temp\\f1.txt\";\nstring fil2 = @\"c:\\temp\\f2.txt\";\nSystem.IO.File.WriteAllText(fil1, \"123\");\nSystem.IO.File.WriteAllText(fil2, \"456\");\nstring indhold = HentIndholdAsync(fil1, fil2).Result;\nConsole.WriteLine(indhold);\nasync Task&lt;string&gt; HentIndholdAsync(string f1, string f2)\n{\nTask&lt;string&gt; r1 = System.IO.File.ReadAllTextAsync(f1);\nTask&lt;string&gt; r2 = System.IO.File.ReadAllTextAsync(f2);\nawait Task.WhenAll(r1, r2);\nreturn r1.Result + r2.Result;\n}\n/*\n ---------- Output: ----------\n123456\n*/\n</code></pre> <pre><code>// Setup\nstring fil1 = @\"c:\\temp\\f1.txt\";\nstring fil2 = @\"c:\\temp\\f2.txt\";\nSystem.IO.File.WriteAllText(fil1, \"123\");\nSystem.IO.File.WriteAllText(fil2, \"456\");\nstring indhold = HentIndholdAsync(fil1, fil2).Result;\nConsole.WriteLine(indhold);\nasync Task&lt;string&gt; HentIndholdAsync(string f1, string f2)\n{\nTask&lt;string&gt; r1, r2;\nSystem.IO.StreamReader sr1 = null;\nSystem.IO.StreamReader sr2 = null;\ntry\n{\nsr1 = System.IO.File.OpenText(f1);\nr1 = sr1.ReadToEndAsync();\nsr2 = System.IO.File.OpenText(f2);\nr2 = sr2.ReadToEndAsync();\nawait Task.WhenAll(r1, r2);\nreturn r1.Result + r2.Result;\n}\ncatch (Exception)\n{\nsr1?.Dispose();\nsr2?.Dispose();\nsr1 = null;\nsr2 = null;\n// log\nthrow;\n}\nfinally\n{\nsr1?.Dispose();\nsr2?.Dispose();\nsr1 = null;\nsr2 = null;\n}\n}\n/*\n ---------- Output: ----------\n123456\n*/\n</code></pre>"},{"location":"167_Kommunikation_over_HTTP.html","title":"Kommunikation over HTTP","text":""},{"location":"167_Kommunikation_over_HTTP.html#om-modulet","title":"Om modulet","text":"<p>I dette modul vil du l\u00e6re om HTTP kommunikation med HttpClient. Der findes ingen videoer til dette modul.</p>"},{"location":"167_Kommunikation_over_HTTP.html#brug-af-httpclient-til-text","title":"Brug af HttpClient til text","text":"<p>I .NET Core er System.Net.Http.HttpClient den bedste m\u00e5de at kommunikere over HTTP, og der b\u00f8r kun v\u00e6re en statisk instans for hele applikationen.</p> <pre><code>private static readonly HttpClient httpClient = new HttpClient();\n// eller initialisering i constructor\n</code></pre> <p>HttpClient best\u00e5r en af del metoder hvoraf f\u00f8lgende er threadsafe:</p> <ul> <li>CancelPendingRequests</li> <li>DeleteAsync</li> <li>GetAsync</li> <li>GetByteArrayAsync</li> <li>GetStreamAsync</li> <li>GetStringAsync</li> <li>PostAsync</li> <li>PutAsync</li> <li>SendAsync</li> </ul> <p>Hvis man blot skal hente text er GetASync eller GetStringAsync nemme</p> <pre><code>using System;\nusing System.Net.Http;\nusing System.Threading.Tasks;\nnamespace Demo\n{\nclass Program\n{\nprivate static readonly HttpClient httpClient = new HttpClient();\nstatic async Task Main(string[] args)\n{\n// Henter et tilf\u00e6ldigt tal som text\nhttpClient.DefaultRequestHeaders.Clear();\nhttpClient.DefaultRequestHeaders.Accept.Add(new MediaTypeWithQualityHeaderValue(\"text/html\"));\n// Enten via den nemme GetStringAsync\nvar response1 = await httpClient.GetStringAsync(\"https://www.random.org/integers/?num=1&amp;min=1&amp;max=6&amp;col=1&amp;base=10&amp;format=plain&amp;rnd=new\");\nConsole.WriteLine(response1);\n// Eller via Get\nvar response2 = await httpClient.GetAsync(\"https://www.random.org/integers/?num=1&amp;min=1&amp;max=6&amp;col=1&amp;base=10&amp;format=plain&amp;rnd=new\");\nif (response2.IsSuccessStatusCode)\n{\nstring tal = await response2.Content.ReadAsStringAsync();\nConsole.WriteLine(tal);\n}\n}\n}\n}\n</code></pre>"},{"location":"167_Kommunikation_over_HTTP.html#brug-af-httpclient-til-json","title":"Brug af HttpClient til JSON","text":"<p>Et kald mod en JSON-service kr\u00e6ver en \u00e6ndring af accept-header samt en deserialisering. Nemmest er at benytte WebApi fra NuGet:</p> <pre><code>Microsoft.AspNet.WebApi.Client\n</code></pre> <p>Eksempelvis vil et kald mod \u201cDanmarks Adressers Web API\u201d for at finde regioner i Danmark fra adressen https://dawa.aws.dk/Regioner, der returnerer:</p> <pre><code>[\n{\n\"\u00e6ndret\": \"2019-08-27T14:05:49.915Z\",\n\"geo_version\": 20,\n\"geo_\u00e6ndret\": \"2019-07-01T21:11:51.749Z\",\n\"bbox\": [8.18951662, 56.53454667, 11.22599137, 57.76025478],\n\"visueltcenter\": [10.11282907, 57.30715928],\n\"dagi_id\": \"389098\",\n\"kode\": \"1081\",\n\"navn\": \"Region Nordjylland\",\n\"nuts2\": \"DK05\",\n\"href\": \"https://dawa.aws.dk/regioner/1081\"\n},\n{\n\"\u00e6ndret\": \"2019-08-27T14:05:49.915Z\",\n\"geo_version\": 24,\n\"geo_\u00e6ndret\": \"2018-11-02T22:06:29.440Z\",\n\"bbox\": [8.07887623, 55.64437916, 11.66419061, 56.84325702],\n\"visueltcenter\": [9.60503157, 56.23399042],\n\"dagi_id\": \"389101\",\n\"kode\": \"1082\",\n\"navn\": \"Region Midtjylland\",\n\"nuts2\": \"DK04\",\n\"href\": \"https://dawa.aws.dk/regioner/1082\"\n},\n...\n]\n</code></pre> <p>kunne skrives som:</p> <pre><code>using System;\nusing System.Collections.Generic;\nusing System.Net.Http;\nusing System.Net.Http.Headers;\nusing System.Threading.Tasks;\nnamespace Demo\n{\nclass Program\n{\nprivate static readonly HttpClient httpClient = new HttpClient();\nstatic async Task Main(string[] args)\n{\nhttpClient.DefaultRequestHeaders.Accept.Clear();\nhttpClient.DefaultRequestHeaders.Accept.Add(\nnew MediaTypeWithQualityHeaderValue(\"application/json\"));\nvar response = await httpClient.GetAsync(\"https://dawa.aws.dk/Regioner\");\nif (response.IsSuccessStatusCode) {\n// ren streng\n// string json = await response.Content.ReadAsStringAsync();\n// direkte deserialisering kr\u00e6ver NuGet-pakken: Microsoft.AspNet.WebApi.Client\nList&lt;Region&gt; lst = await response.Content.ReadAsAsync&lt;List&lt;Region&gt;&gt;();\nlst.ForEach(i =&gt; Console.WriteLine($\"{i.Kode} {i.Navn}\"));\n}\n}\n}\nclass Region {\npublic string Navn { get; set; }\npublic string Href { get; set; }\npublic string Kode { get; set; }\n}\n}\n</code></pre> <p>Resultatet vil v\u00e6re noget ala:</p> <pre><code>1081 Region Nordjylland\n1082 Region Midtjylland\n1083 Region Syddanmark\n1084 Region Hovedstaden\n1085 Region Sj\u00e6lland\n</code></pre>"},{"location":"167_Kommunikation_over_HTTP.html#systemtextjson","title":"System.Text.Json","text":"<p>I Json-namespacet findes ogs\u00e5 JsonSerializer som kan bruges til at serialisere og deserialisere. Her er samme kode som tidligere nu bare med brug af JsonSerializer</p> <pre><code>using System;\nusing System.Collections.Generic;\nusing System.Net.Http;\nusing System.Net.Http.Headers;\nusing System.Threading.Tasks;\nnamespace Demo\n{\nclass Program\n{\nprivate static readonly HttpClient httpClient = new HttpClient();\nstatic async Task Main(string[] args)\n{\nhttpClient.DefaultRequestHeaders.Accept.Clear();\nhttpClient.DefaultRequestHeaders.Accept.Add(\nnew MediaTypeWithQualityHeaderValue(\"application/json\"));\nvar response = await httpClient.GetAsync(\"https://api.dataforsyningen.dk/regioner\");\nif (response.IsSuccessStatusCode)\n{\nstring json = await response.Content.ReadAsStringAsync();\nList&lt;Region&gt; lst = System.Text.Json.JsonSerializer.Deserialize&lt;List&lt;Region&gt;&gt;(json);\nlst.ForEach(i =&gt; Console.WriteLine($\"{i.kode} {i.navn}\"));\n}\n}\n}\nclass Region\n{\npublic string navn { get; set; }\npublic string kode { get; set; }\n}\n}\n</code></pre> <p>Info</p>"},{"location":"167_Kommunikation_over_HTTP.html#opgave-167-1","title":"Opgave 167-1","text":"<p>Hent og vis samtlige kommuner i Danmark fra DAWA (kode til s\u00f8gning: BGHB)</p> <p>Se opgave</p>"},{"location":"167_Kommunikation_over_HTTP.html#post-data","title":"POST data","text":"<p>Hvis du \u00f8nsker at POST\u2019e standard formdata over HTTP (se http://webdemo.cronberg.dk) kan du bruge PostAsync:</p> <pre><code>using System.Collections.Generic;\nusing System.Net.Http;\nusing System.Net.Http.Headers;\nusing System.Threading.Tasks;\nnamespace Demo\n{\nclass Program\n{\nprivate static readonly HttpClient httpClient = new HttpClient();\nstatic async Task Main(string[] args)\n{\nvar formContent = new FormUrlEncodedContent(new[]\n{\nnew KeyValuePair&lt;string, string&gt;(\"navn\", \"abc\")\n});\nvar response = await httpClient.PostAsync(\"http://webdemo.cronberg.dk/posttome\", formContent);\nresponse.EnsureSuccessStatusCode();\n// retur fra server\nstring content = await response.Content.ReadAsStringAsync();\n}\n}\n}\n</code></pre> <p>Det vil skabe f\u00f8lgende POST:</p> <pre><code>POST http://webdemo.cronberg.dk/posttome HTTP/1.1\nHost: webdemo.cronberg.dk\nContent-Type: application/x-www-form-urlencoded\nContent-Length: 8\n\nnavn=abc\n</code></pre>"},{"location":"167_Kommunikation_over_HTTP.html#post-json","title":"POST JSON","text":"<p>Hvis du \u00f8nsker at POSTe til et standard JSON API er metoden PostAsJsonAsync fra WebApi (se ovenfor) nem at bruge. Her et eksempel mod en fake service (https://jsonplaceholder.com).</p> <pre><code>using System.Collections.Generic;\nusing System.Net.Http;\nusing System.Net.Http.Headers;\nusing System.Threading.Tasks;\nnamespace Demo\n{\nclass Program\n{\nprivate static readonly HttpClient httpClient = new HttpClient();\nstatic async Task Main(string[] args)\n{\nHttpResponseMessage response = await\nhttpClient.PostAsJsonAsync(\"https://jsonplaceholder.typicode.com/posts\",\nnew Customer { UserId = 1, Title = \"a\", Body = \"b\" });\nresponse.EnsureSuccessStatusCode();\nSystem.Console.WriteLine(response.StatusCode);\n// retur fra server\nstring content = await response.Content.ReadAsStringAsync();\n}\n}\nclass Customer {\npublic string Title { get; set; }\npublic string Body { get; set; }\npublic int UserId { get; set; }\n}\n}\n</code></pre> <p>Det vil skabe en POST som f\u00f8lger:</p> <pre><code>POST https://jsonplaceholder.typicode.com/posts HTTP/1.1\nHost: jsonplaceholder.typicode.com\nContent-Type: application/json; charset=utf-8\nContent-Length: 35\n\n{\"Title\":\"a\",\"Body\":\"b\",\"UserId\":1}\n</code></pre> <p>og returnere en \u201c201 Created\u201d statuskode.</p>"},{"location":"167_Kommunikation_over_HTTP.html#synkrone-kald-med-webclient","title":"Synkrone kald med WebClient","text":"<p>Du kan eventuelt bruge den \u201cgamle\u201d WebClient (System.Net.WebClient) hvis du \u00f8nsker et rent synkront kald - eksempelvis til at hente en streng:</p> <pre><code>using (WebClient w = new WebClient())\n{\nstring s = w.DownloadString(\"https://www.random.org/integers/?num=1&amp;min=1&amp;max=6&amp;col=1&amp;base=10&amp;format=plain&amp;rnd=new\");\n}\n</code></pre>"},{"location":"167_Kommunikation_over_HTTP.html#restsharp","title":"RestSharp","text":"<p>Der findes et hav af pakke relateret til at simplificere HTTP kald. Den st\u00f8rste er nok RestSharp som tilbyder en masse yderligere funktionalitet. Her er et simpelt eksempel der henter alle kommuner i DK:</p> <pre><code>using System;\nusing System.Collections.Generic;\nusing System.Threading.Tasks;\nusing RestSharp;\nnamespace RetryPattern\n{\nclass Program\n{\nstatic async Task Main(string[] args)\n{\nvar client = new RestClient(\"https://dawa.aws.dk/\");\nvar request = new RestRequest(\"kommuner\", DataFormat.Json);\nvar kommuner = await client.GetAsync&lt;List&lt;Kommune&gt;&gt;(request);\nkommuner.ForEach(k =&gt; Console.WriteLine(k));\n}\n}\nclass Kommune\n{\npublic string Kode { get; set; }\npublic string Navn { get; set; }\npublic override string ToString()\n{\nreturn $\"{Kode} {Navn}\";\n}\n}\n}\n</code></pre>"},{"location":"168_Kommunikation_med_databaser.html","title":"Kommunikation med databaser","text":""},{"location":"168_Kommunikation_med_databaser.html#om-modulet","title":"Om modulet","text":"<p>I dette modul vil du l\u00e6re om kommunikation med databaser ved hj\u00e6lp af klassiske typer i System.Data - samt introduceres til Entity Framework. Der findes ingen videoer til dette modul.</p>"},{"location":"168_Kommunikation_med_databaser.html#demo-database","title":"Demo database","text":"<p>For ikke at skulle have adgang til en SQL Server, MySql eller lign. kan du benytte SQLite. Det er en effektiv filbaseret database som ikke kr\u00e6ver installation men blot en enkelt NuGet-pakke (under .NET Core).</p> <p>Du kan eventult hente en test database samt info om brug her:</p> <p>https://github.com/devcronberg/undervisning-db-sqlite/#sqlite-demo-database</p>"},{"location":"168_Kommunikation_med_databaser.html#connected","title":"Connected","text":"<ul> <li> <p>ADO.NET providere (System.Data)</p> </li> <li> <p>SqlClient</p> </li> <li>OldDb</li> <li>ODBC</li> <li> <p>Masser af NuGet-pakker</p> <ul> <li>SQLite</li> <li>Oracle</li> <li>MySql</li> </ul> </li> <li> <p>Vigtige interface</p> </li> <li>IDbConnection<ul> <li>DbConnection</li> </ul> </li> <li>IDbCommand<ul> <li>DbCommand</li> </ul> </li> <li>IDataReader<ul> <li>DbDataReader</li> </ul> </li> </ul>"},{"location":"168_Kommunikation_med_databaser.html#dbconnection","title":"DbConnection","text":"<ul> <li>Brug DbConnection til at \u00e5bne en forbindelse</li> <li>Husk at using kalder Dispose som kalder Close()</li> </ul> <pre><code>using System;\nusing System.Data.SQLite;\nnamespace demo\n{\nclass Program\n{\nprivate static string databaseFil = \"c:\\\\temp\\\\people.db\";\nprivate static string connectionString = \"Data Source=\" + databaseFil;\nstatic void Main(string[] args)\n{\nusing (SQLiteConnection cn = new SQLiteConnection(connectionString))\n{\ncn.Open();\nConsole.WriteLine(\"Forbindelse \u00e5bn\");\n}\nConsole.WriteLine(\"Forbindelse lukket\");\n}\n}\n}\n</code></pre>"},{"location":"168_Kommunikation_med_databaser.html#dbcommand","title":"DbCommand","text":"<ul> <li>DbCommand indeholder medlemmer relateret til sql kald</li> <li>CommandText</li> <li>CommandType<ul> <li>text, stored proc.</li> </ul> </li> <li>ExecuteScalar()<ul> <li>Enkelt svar (ala count)</li> </ul> </li> <li>ExecuteNonQuery()<ul> <li>typisk update/insert</li> <li>return antal poster p\u00e5virkede</li> </ul> </li> <li>ExecuteReader()<ul> <li>typisk select</li> </ul> </li> </ul> <pre><code>using System;\nusing System.Data.SQLite;\nnamespace demo\n{\nclass Program\n{\nprivate static string databaseFil = \"c:\\\\temp\\\\people.db\";\nprivate static string connectionString = \"Data Source=\" + databaseFil;\nstatic void Main(string[] args)\n{\nusing (SQLiteConnection cn = new SQLiteConnection(connectionString))\n{\ncn.Open();\nusing (SQLiteCommand cm = new SQLiteCommand(cn))\n{\ncm.CommandType = System.Data.CommandType.Text;\ncm.CommandText = \"Select * from person\";\n// command.ExecuteReader\n// command.ExecuteNonQuery\n// command.ExecuteScalar\n}\n}\n}\n}\n}\n</code></pre>"},{"location":"168_Kommunikation_med_databaser.html#dbdatareader","title":"DbDataReader","text":"<ul> <li>Stream af data</li> <li>forward-only, read-only server side cursor</li> <li>husk using</li> </ul> <pre><code>using System;\nusing System.Data.SQLite;\nnamespace demo\n{\nclass Program\n{\nprivate static string databaseFil = \"c:\\\\temp\\\\people.db\";\nprivate static string connectionString = \"Data Source=\" + databaseFil;\nstatic void Main(string[] args)\n{\nusing (SQLiteConnection cn = new SQLiteConnection(connectionString))\n{\ncn.Open();\nusing (SQLiteCommand cm = new SQLiteCommand(cn))\n{\ncm.CommandType = System.Data.CommandType.Text;\ncm.CommandText = \"Select * from person\";\nusing (SQLiteDataReader reader = cm.ExecuteReader())\n{\nwhile (reader.Read())\n{\nConsole.WriteLine($\"{reader[\"PersonId\"]} {reader[\"LastName\"]}\");\n}\n}\n}\n}\n}\n}\n}\n</code></pre>"},{"location":"168_Kommunikation_med_databaser.html#executenonquery","title":"ExecuteNonQuery","text":"<pre><code>using System;\nusing System.Data.SQLite;\nnamespace demo\n{\nclass Program\n{\nprivate static string databaseFil = \"c:\\\\temp\\\\people.db\";\nprivate static string connectionString = \"Data Source=\" + databaseFil;\nstatic void Main(string[] args)\n{\nusing (SQLiteConnection cn = new SQLiteConnection(connectionString))\n{\ncn.Open();\nusing (SQLiteCommand cm = new SQLiteCommand(cn))\n{\ncm.CommandType = System.Data.CommandType.Text;\ncm.CommandText = \"update person set lastname = '*' where personid = 1\";\nint antal = cm.ExecuteNonQuery();\nConsole.WriteLine($\"{antal} {(antal==1?\"post\":\"poster\")} p\u00e5virket\");\n}\n}\n}\n}\n}\n</code></pre>"},{"location":"168_Kommunikation_med_databaser.html#executescalar","title":"ExecuteScalar","text":"<pre><code>using System;\nusing System.Data.SQLite;\nnamespace demo\n{\nclass Program\n{\nprivate static string databaseFil = \"c:\\\\temp\\\\people.db\";\nprivate static string connectionString = \"Data Source=\" + databaseFil;\nstatic void Main(string[] args)\n{\nusing (SQLiteConnection cn = new SQLiteConnection(connectionString))\n{\ncn.Open();\nusing (SQLiteCommand cm = new SQLiteCommand(cn))\n{\ncm.CommandType = System.Data.CommandType.Text;\ncm.CommandText = \"select count(*) from person\";\nlong antal = (long)cm.ExecuteScalar();\nConsole.WriteLine($\"Der er {antal} {(antal==1?\"person\":\"personer\")} i databasen\");\n}\n}\n}\n}\n}\n</code></pre> <p>Info</p>"},{"location":"168_Kommunikation_med_databaser.html#opgave-168-1","title":"Opgave 168-1","text":"<p>Brug SQLLite til at lege med DataConnection, DataCommand mv (kode til s\u00f8gning: BGIB)</p> <p>Se opgave</p>"},{"location":"168_Kommunikation_med_databaser.html#datasetdatatable","title":"DataSet/DataTable","text":"<p>Ren offline/disconnected datastruktur som b\u00e5de benyttes sammen med databaser og som en ren disconnected heap baseret struktur</p> <ul> <li>DataSet</li> <li>DataTable<ul> <li>DataColumns</li> <li>DataRows</li> </ul> </li> </ul> <p>Klasserne kan findes under System.Data.</p>"},{"location":"168_Kommunikation_med_databaser.html#dataadapter","title":"DataAdapter","text":"<ul> <li>DataAdapter</li> <li>arbejder med dataset/datatable</li> </ul> <pre><code>using System;\nusing System.Data;\nusing System.Data.SQLite;\nnamespace demo\n{\nclass Program\n{\nprivate static string databaseFil = \"c:\\\\temp\\\\people.db\";\nprivate static string connectionString = \"Data Source=\" + databaseFil;\nstatic void Main(string[] args)\n{\nDataTable dt = new DataTable(\"data\");\nusing (SQLiteConnection cn = new SQLiteConnection(connectionString))\n{\nusing (SQLiteCommand cm = new SQLiteCommand(cn))\n{\nstring sql = \"select * from person\";\nusing (SQLiteDataAdapter da = new SQLiteDataAdapter(sql, cn))\n{\nda.Fill(dt);\n}\n}\n}\nConsole.WriteLine($\"Der er {dt.Rows.Count} {(dt.Rows.Count == 1 ? \"post\" : \"poster\")} i databasen\");\nforeach (DataRow row in dt.Rows)\n{\nConsole.WriteLine(row[\"lastname\"]);\n}\n}\n}\n}\n</code></pre> <p>Info</p>"},{"location":"168_Kommunikation_med_databaser.html#opgave-168-2","title":"Opgave 168-2","text":"<p>Brug SQLLite til at lege med DataAdapter og DataTable mv (kode til s\u00f8gning: BGIC)</p> <p>Se opgave</p>"},{"location":"168_Kommunikation_med_databaser.html#dynamisk-struktur-i-hukommelsen","title":"Dynamisk struktur i hukommelsen","text":"<p>Man kan ogs\u00e5 benytte DataSet/DataTable direkte i hukommelsen ved at oprette b\u00e5de r\u00e6kker og felter - ala</p> <pre><code>using System.Data;\nnamespace demo\n{\nclass Program\n{\nstatic void Main(string[] args)\n{\nDataTable dt = new DataTable();\ndt.Columns.Add(\"Name\", typeof(string));\ndt.Columns.Add(\"Age\", typeof(int));\nDataRow dr = dt.NewRow();\ndr[\"Name\"] = \"a\";\ndr[\"Age\"] = 24;\ndt.Rows.Add(dr);\ndr = dt.NewRow();\ndr[\"Name\"] = \"b\";\ndr[\"Age\"] = 20;\ndt.Rows.Add(dr);\n}\n}\n}\n</code></pre>"},{"location":"168_Kommunikation_med_databaser.html#intro-til-entity-framework","title":"Intro til Entity Framework","text":"<ul> <li>MS\u2019s ORM produkt</li> <li>abstraktion af database til objekter</li> <li>sikkert mere brugt i dag end System.Data.xxx</li> </ul> <p>Fungerer ved hj\u00e6lp af et overordnet context som er bindeled mellem databasen og et objektlag. S\u00e5vel context som objektlag kan enten autogenereres eller skrives manauelt. EF benytter LINQ to EF og IQueryable-samlinger til at skabe SQL kald ved at konvertere expressions (typisk fra Lamdba-udtryk). EF fungerer med mange forskellige databaser - herunder naturligvis SQL Server.</p> <p>Helt grundl\u00e6ggende kan man udbytte sin viden fra LINQ to objects til at hente data, men hvor Linq to objects benytter IEnumerable og delegates benytter LINQ to EF IQueryable og expressions.</p>"},{"location":"168_Kommunikation_med_databaser.html#demo","title":"Demo","text":"<p>Hent .NET6 projektet</p> <p>devcronberg/EFDemo</p> <p>og se kode.</p>"},{"location":"168_Kommunikation_med_databaser.html#intro-til-dapper","title":"Intro til Dapper","text":"<p>Som et noget mere simpelt alternativ til EF skulle du m\u00e5ske se p\u00e5 Dappper (fra StackOverflow). Det genererer ikke ikke SQL men er et rent mapping framework. Til geng\u00e6ld er det super hurtigt og nemt at arbejde med.</p> <p>Pr\u00f8v eventuelt dette - kr\u00e6ver NuGet-pakkerne:</p> <pre><code>System.Data.SQLite.Core\nDapper\n</code></pre> <p>som demo databasen fra https://github.com/devcronberg/undervisning-db-sqlite/#sqlite-demo-database.</p> <pre><code>using Dapper;\nusing System;\nusing System.Collections.Generic;\nusing System.Data.SQLite;\nusing System.Linq;\nnamespace DapperDemo\n{\nclass Program\n{\nprivate static string databaseFil = \"c:\\\\temp\\\\people.db\";\nprivate static string connectionString = \"Data Source=\" + databaseFil;\nstatic void Main(string[] args)\n{\nusing (var cnn = new SQLiteConnection(connectionString))\n{\ncnn.Open();\nList&lt;Person&gt; personer = cnn.Query&lt;Person&gt;(\"SELECT * from Person\").ToList();\nforeach (var person in personer)\nConsole.WriteLine(person.PersonId + \" \" + person.LastName);\n}\n}\n}\npublic class Person\n{\npublic int PersonId { get; set; }\npublic string FirstName { get; set; }\npublic string LastName { get; set; }\npublic DateTime DateOfBirth { get; set; }\npublic bool IsHealthy { get; set; }\npublic int Gender { get; set; }\npublic int Height { get; set; }\n}\n}\n</code></pre>"},{"location":"168_Kommunikation_med_databaser.html#csv","title":"CSV","text":"<p>At skrive eller l\u00e6se CSV filer kan naturligvis g\u00f8res manuelt ved at hente og splitte data selv men det er noget nemmere at benytte NuGet-pakker som CsvHelper eller lign. Der er alt det h\u00e5rde arbejde gjort relateret til serialisering og deserialisering til objekter som eksempelvis:</p> <pre><code>using (var reader = new StreamReader(\"c:\\\\temp\\data.csv\"))\nusing (var csv = new CsvReader(reader, new CultureInfo(\"da-DK\")))\n{\nvar records = csv.GetRecords&lt;Person&gt;().ToList();\n}\n</code></pre> <p>hvor Person repr\u00e6senterer den datastruktur som er defineret i data.csv - ala</p> <pre><code>Id;Navn;ErDansk;Dato\n1;Anders;true;29-07-1972\n2;Mikkel;false;08-01-1996\n</code></pre> <p>Info</p>"},{"location":"168_Kommunikation_med_databaser.html#opgave-168-3","title":"Opgave 168-3","text":"<p>Leg med manuel og automatisk serialisering af CSV filer (kode til s\u00f8gning: BGID)</p> <p>Se opgave</p>"},{"location":"168_Kommunikation_med_databaser.html#excel","title":"Excel","text":"<p>Der findes masser af NuGet-pakker relateret til Excel - her er et par af de popul\u00e6re</p> <ul> <li>ClosedXml</li> <li>Se ogs\u00e5 ClosedXML.Report</li> <li>ExcelDataReader</li> <li>ExcelDataReader.DataSet (extension)</li> <li>System.Text.Encoding.CodePages (n\u00f8dvendig i core)</li> </ul> <p>ExcelDataReader er god og hurtig til at l\u00e6se fra Excel. ClosedXml kan bruges til at l\u00e6se og skrive.</p>"},{"location":"168_Kommunikation_med_databaser.html#skriv-med-closedxml","title":"Skriv med ClosedXML","text":"<p>Denne kode danner et ark med data og gemmer i c:\\temp\\data.xlsx.</p> <p></p> <pre><code>using ClosedXML.Excel;\nusing System;\nnamespace ExcelDemo\n{\nclass Program\n{\nstatic void Main(string[] args)\n{\nusing (var workbook = new XLWorkbook())\n{\nRandom rnd = new Random();\nint rows = 10;\nvar ws = workbook.Worksheets.Add(\"Sheet1\");\nws.Cell(1, 1).Value = \"Nr\";\nws.Cell(1, 2).Value = \"Navn\";\nws.Cell(1, 3).Value = \"L\u00f8n\";\nfor (int row = 2; row &lt; rows+1; row++)\n{\nws.Cell(row, 1).Value = row - 1;\nws.Cell(row, 2).Value = Convert.ToChar(row + 63);\nws.Cell(row, 3).Value = rnd.Next(10000, 100000);\n}\nvar rngTable = ws.Range(\"A1:C\" + rows);\nvar rngHeaders = rngTable.Range(\"A1:C1\");\nrngHeaders.Style.Alignment.Horizontal = XLAlignmentHorizontalValues.Center;\nrngHeaders.Style.Font.Bold = true;\nrngTable.Range(\"C2:C\" + rows).Style.NumberFormat.Format = \"#,##0.00\";\nws.Columns(1, 3).AdjustToContents();\nworkbook.SaveAs(@\"c:\\temp\\data.xlsx\");\n}\n}\n}\n}\n</code></pre> <p>Du kan overveje at skabe rapporter med ClosedXml.Reports i stedet for at g\u00f8re det manuelt.</p>"},{"location":"168_Kommunikation_med_databaser.html#ls-med-closedxml","title":"L\u00e6s med ClosedXml","text":"<p>Her er koden til at l\u00e6se data fra tidligere:</p> <pre><code>using ClosedXML.Excel;\nusing System;\nusing System.Collections.Generic;\nnamespace ExcelDemo\n{\nclass Program\n{\nstatic void Main(string[] args)\n{\nusing (FileStream fileStream = new FileStream(@\"c:\\temp\\data.xlsx\",\nFileMode.Open, FileAccess.Read, FileShare.ReadWrite))\n{\nvar wb = new XLWorkbook(fileStream);\nvar ws = wb.Worksheet(\"Sheet1\");\nList&lt;MineData&gt; lst = new List&lt;MineData&gt;();\nfor (int i = 2; i &lt; 100; i++)\n{\nif (!ws.Cell(i, 1).IsEmpty())\n{\nlst.Add(new MineData\n{\nNr = ws.Cell(i, 1).GetValue&lt;int&gt;(),\nNavn = ws.Cell(i, 2).GetValue&lt;string&gt;(),\nL\u00f8n = ws.Cell(i, 3).GetValue&lt;double&gt;()\n});\n}\n}\n// g\u00f8r noget med lst\nlst.ForEach(i =&gt; Console.WriteLine(i.Navn));\n}\n}\n}\nclass MineData {\npublic int Nr { get; set; }\npublic string Navn { get; set; }\npublic double L\u00f8n { get; set; }\n}\n}\n</code></pre>"},{"location":"168_Kommunikation_med_databaser.html#serialisering-med-data-fra-excel","title":"Serialisering med data fra Excel","text":"<p>Hvis du gerne vil kunne serialisere og deserialisere data fra Excel s\u00e5 pr\u00f8v youngcm2/CsvHelper.Excel</p>"},{"location":"168_Kommunikation_med_databaser.html#excel-dna","title":"Excel-DNA","text":"<p>Hvis du \u00f8nsker at skrive C# plugins (.xll) til Excel er Excel-DNA en oplagt mulighed. Se https://excel-dna.net/.</p> <p>Som eksempel - pr\u00f8v at skabe et .NET Framework (vigtigt) klassebibliotek (class library) og tilf\u00f8j NuGet-pakkerne</p> <ul> <li>ExcelDna.AddIn</li> <li>ExcelDna.IntelliSense</li> </ul> <p>og erstat koden i Class1.cs med f\u00f8lgende:</p> <pre><code>using ExcelDna.Integration;\nusing ExcelDna.IntelliSense;\nusing System;\nusing System.Linq;\nusing System.Runtime.InteropServices;\npublic static class MyFunctions\n{\n[ExcelFunction(Description = \"Find sidste mandag\")]\npublic static DateTime SidsteMandag()\n{\nDateTime d = DateTime.Today;\nwhile (d.DayOfWeek!= DayOfWeek.Monday)\n{\nd = d.AddDays(-1);\n}\nreturn d;\n}\n[ExcelFunction(Description = \"Finder sum af celler\")]\npublic static double MinSum([ExcelArgument(Name = \"Celler\", Description = \"Celler til sum\")] double[] celler)\n{\ntry\n{\nreturn celler.Sum();\n}\ncatch (Exception)\n{\nreturn 0;\n}\n}\n[ComVisible(false)]\ninternal class ExcelAddin : IExcelAddIn\n{\npublic void AutoOpen()\n{\nIntelliSenseServer.Install();\n}\npublic void AutoClose()\n{\nIntelliSenseServer.Uninstall();\n}\n}\n}\n</code></pre> <p>Pr\u00f8v s\u00e5 at trykke F5.</p> <p>Info</p>"},{"location":"168_Kommunikation_med_databaser.html#opgave-168-4","title":"Opgave 168-4","text":"<p>Skab et Excel-ark med ClosedXml (kode til s\u00f8gning: BGIE)</p> <p>Se opgave</p>"},{"location":"169_ExpressionTrees.html","title":"Expression trees","text":""},{"location":"169_ExpressionTrees.html#om-modulet","title":"Om modulet","text":"<p>Dette modul vil du l\u00e6re hvordan du kan arbejde med expression trees i C#.</p>"},{"location":"169_ExpressionTrees.html#om-expression-trees","title":"Om Expression trees","text":"<p>Expression trees giver mulighed for at konvertere kode til data. Det udnyttes blandt andet LINQ-frameworks, AutoMapper med videre.</p> <p>Kan ogs\u00e5 sige, at et EXT (expression tree) i C# svarer til et ATS (Abstract Syntax Tree) relateret til en compiler - men EXT repr\u00e6senterer et enkelt udtryk hvor AST repr\u00e6senterer et program.</p> <p><pre><code>a + b * 2\n\n    [+]\n  /    \\\n a     [*]\n      /   \\\n     b     2\n</code></pre> Ref</p> <pre><code>Func&lt;int, bool&gt; a = i =&gt; i &gt; 5;\nConsole.WriteLine(a(3));                    // false\nExpression&lt;Func&lt;int, bool&gt;&gt; b = i =&gt; i &gt; 5;\nConsole.WriteLine(b);                       // i=&gt; (i &gt; 5);\nConsole.WriteLine(b.GetType());             // System.Linq.Expressions.Expression&lt;System.Int32,System.Boolean&gt;            \nConsole.WriteLine(b.Type);                  // Func&lt;int, bool&gt;\nConsole.WriteLine(b.Parameters.GetType());  // ReadOnlyCollection&lt;System.Linq.Expressions.ParameterExpression&gt;\nConsole.WriteLine(b.Parameters[0].Name);    // i\nConsole.WriteLine(b.Parameters[0].Type);    // Int32\nConsole.WriteLine(b.Body);                  // (i &gt; 5);\nConsole.WriteLine(b.Body.GetType());        // System.Linq.Expressions.LogicalBinaryExpression\nBinaryExpression b1 = (BinaryExpression)b.Body;\nConsole.WriteLine(b1.Left);                 // i\nConsole.WriteLine(b1.Right);                // 5\nConsole.WriteLine(b1.NodeType);             // GreaterThan\nFunc&lt;int, bool&gt; c = b.Compile();\nConsole.WriteLine(c(3));                     // false\nExpression&lt;Func&lt;int, int, int&gt;&gt; d = (x, y) =&gt; x &gt; 10 ? x + y : x - y;\nConsole.WriteLine(d);                       // (x, y) =&gt; IIF((x &gt; 10), (x + y), (x - y))\nConsole.WriteLine(d.Body.GetType());        // System.Linq.Expressions.FullConditionalExpression\nExpression&lt;Func&lt;string, string&gt;&gt; e = x =&gt; x.ToUpper();\nConsole.WriteLine(e);                       // x =&gt; x.ToUpper()\nConsole.WriteLine(e.Body.GetType());        // System.Linq.Expressions.InstanceMethodCallExpression\n</code></pre> <p>Info</p>"},{"location":"169_ExpressionTrees.html#opgave-169-1","title":"Opgave 169-1","text":"<p>Brug af expressions til at skabe et repository med LINQ where/orderby muligheder (kode til s\u00f8gning: BGJB)</p> <p>Se opgave</p>"},{"location":"169_ExpressionTrees.html#expression-api","title":"Expression API","text":"<p>Der findes en masse typer til at beskrive et tr\u00e6, og mange kan oprettes gennem statiske metoder p\u00e5 Expression-klassen.</p> <p>Parametre kan beskrives med en ParameterExpression, og Body med en LambdaExpression eller en BinaryExpression. I selve body\u2019en kan der benytte ConstantExpression, MethodCallExpression, PropertyExpression (meget benyttet i EF, MVC mv) samt et hav af operatorer (LessThan, Equal, GreaterThan mv).</p> <pre><code>Func&lt;string, string&gt; m\u00e5l = x =&gt; x.ToUpper();\nvar p = Expression.Parameter(typeof(string));\nvar t = typeof(string).GetMethod(\"ToUpper\", Type.EmptyTypes);\nvar b = Expression.Call(p, t);\nvar l1 = Expression.Lambda(b, p);\nvar e1 = l1.Compile();\nConsole.WriteLine(e1.DynamicInvoke(\"a\"));\nvar l2 = Expression.Lambda&lt;Func&lt;string, string&gt;&gt;(b, p);\nvar e2 = l2.Compile();\nConsole.WriteLine(e2(\"a\"));\n</code></pre>"},{"location":"169_ExpressionTrees.html#iqueryable","title":"IQueryable <p>Hvor IEnumerable arbejder p\u00e5 samlinger</p> <pre><code>public interface IEnumerable\n{\n    IEnumerator GetEnumerator();\n}\n</code></pre> <p>arbejder IQueryable p\u00e5 en Expression</p> <pre><code>public interface IQueryable : IEnumerable\n{\n    Type ElementType { get; }\n    Expression Expression { get; }\n    IQueryProvider Provider { get; }\n}\n</code></pre> <p>Eksempelvis er Where-metoden p\u00e5 Linq to objects og Linq to EF fundamentalt forskellige fra hinanden:</p> <pre><code>public static IEnumerable&lt;TSource&gt; Where&lt;TSource&gt;(this IEnumerable&lt;TSource&gt; source, Func&lt;TSource, int, bool&gt; predicate);\n\npublic static IQueryable&lt;TSource&gt; Where&lt;TSource&gt;(this IQueryable&lt;TSource&gt; source, Expression&lt;Func&lt;TSource, bool&gt;&gt; predicate);\n</code></pre>","text":""},{"location":"169_ExpressionTrees.html#designtime-compile-runtime-compile","title":"designtime compile -&gt; runtime compile <p>Hvorfor benytte expressions:</p> <pre><code>// Lambda\nFunc&lt;int, int, int&gt; a = (x, y) =&gt; x + y;\nConsole.WriteLine(a(2, 2));   // 4\n\n// Expression\nExpression&lt;Func&lt;int, int, int&gt;&gt; b = (x, y) =&gt; x + y;\nConsole.WriteLine(b.Compile()(2, 2)); // 4\n\n// Expression API\nvar p1 = Expression.Parameter(typeof(int), \"x\");\nvar p2 = Expression.Parameter(typeof(int), \"y\");\nvar add = Expression.Add(p1, p2);\nvar exp = Expression.Lambda(add, p1, p2).Compile();\nConsole.WriteLine(exp.DynamicInvoke(2, 2)); // 4\n\n// Scripting (Microsoft.CodeAnalysis.CSharp.Scripting)\nstring expString = \"(x, y) =&gt; x + y\";\nFunc&lt;int, int, int&gt; s = CSharpScript.EvaluateAsync&lt;Func&lt;int, int, int&gt;&gt;(expString).Result;\nConsole.WriteLine(s(2, 2)); // 4\n</code></pre>","text":""},{"location":"170_Konfiguration.html","title":"Brug af konfigurationsfiler","text":""},{"location":"170_Konfiguration.html#om-modulet","title":"Om modulet","text":"<p>Dette modul vil introducere dig til konfiguration i .NET Core og .NET Framework. Der er ikke nogle videoer til dette modul (endnu) - brug koden som eksempler p\u00e5 brug af konfigurationsfiler.</p>"},{"location":"170_Konfiguration.html#konfiguration","title":"Konfiguration","text":"<p>Kommunikation med konfigurationsfiler sker p\u00e5 forskellig vis afh\u00e6ngig af runtime, og det kan ske b\u00e5de typevagt og typest\u00e6rkt.</p>"},{"location":"170_Konfiguration.html#typesvag-binding-til-en-net-core-konfigurationsfil","title":"Typesvag binding til en .NET Core konfigurationsfil","text":"<p>Den typesvage binding til en json-fil i .NET Core kr\u00e6ver NuGet pakken</p> <pre><code>Microsoft.Extensions.Configuration.Json\n</code></pre> <p>Med udgangspunkt i f\u00f8lgende json-fil kaldet appsettings.json (husk - \u201cCopy to Output Directory\u201d = \u201cCopy always\u201d)</p> <pre><code>{\n\"ApplicationName\": \"My sample application\",\n\"SectionA\": {\n\"ModuleName\": \"My sample module\"\n}\n}\n</code></pre> <p>kan f\u00f8lgende kode bruges:</p> <pre><code>// Kr\u00e6ver NuGet: Microsoft.Extensions.Configuration.Json\n// samt evt Microsoft.Extensions.Configuration.Binder (.NET 6+)\nusing Microsoft.Extensions.Configuration;\nusing System;\nusing System.IO;\nnamespace Configuration.Core\n{\nclass Program\n{\nstatic void Main(string[] args)\n{\nvar c1 = ConfigSetupWeak();\nConsole.WriteLine(c1[\"ApplicationName\"]);\nConsole.WriteLine(c1.GetSection(\"SectionA\")[\"ModuleName\"]);\n}\nstatic IConfigurationRoot ConfigSetupWeak() {\nvar builder = new ConfigurationBuilder()\n.SetBasePath(Directory.GetCurrentDirectory())\n.AddJsonFile(\"appsettings.json\", optional: true, reloadOnChange: true);\nIConfigurationRoot configuration = builder.Build();\nreturn configuration;\n}\n}\n}\n</code></pre>"},{"location":"170_Konfiguration.html#typestrk-binding-til-en-net-core-konfigurationsfil","title":"Typest\u00e6rk binding til en .NET Core konfigurationsfil","text":"<p>Den typest\u00e6rke binding kr\u00e6ver klasser der mapper konfigurationsfilen (typisk json), samt f\u00f8lgende pakker:</p> <pre><code>Microsoft.Extensions.Configuration.Json\nMicrosoft.Extensions.Configuration.Binder\n</code></pre> <p>Med udgangspunkt i f\u00f8lgende json-fil kaldet appsettings.json (husk - \u201cCopy to Output Directory\u201d = \u201cCopy always\u201d)</p> <pre><code>{\n\"A\": \"abc\",\n\"B\": 1,\n\"C\": true\n}\n</code></pre> <p>kan f\u00f8lgende kode bruges:</p> <pre><code>using System;\nusing System.IO;\nusing Microsoft.Extensions.Configuration;\nnamespace ConsoleOpgave_Configuration\n{\nclass Program\n{\nstatic void Main(string[] args)\n{\nvar configuration = GetConfiguration();\nConsole.WriteLine(configuration.A);\nConsole.WriteLine(configuration.B);\nConsole.WriteLine(configuration.C);\n}\nstatic Configuration GetConfiguration() {\nvar builder = new ConfigurationBuilder()\n.SetBasePath(Directory.GetCurrentDirectory())\n.AddJsonFile(\"appsettings.json\", optional: true, reloadOnChange: true);\nIConfigurationRoot configuration = builder.Build();\nvar c = new Configuration();            configuration.Bind(c);\nreturn c;\n}\n}\nclass Configuration {\npublic string A { get; set; }\npublic int B { get; set; }\npublic bool C { get; set; }\n}\n}\n</code></pre> <p>Info</p>"},{"location":"170_Konfiguration.html#opgave-170-1","title":"Opgave 170-1","text":"<p>Opgave i brug af en typest\u00e6rk appsettings.json konfigurationsfil (kode til s\u00f8gning: BHAB)</p> <p>Se opgave</p>"},{"location":"170_Konfiguration.html#net-framework","title":".NET Framework","text":"<p>Det nemmeste i .NET Framework er at benytte app.config og tilf\u00f8je f\u00f8lgende:</p> <pre><code>&lt;appSettings&gt;\n&lt;add key=\"MyValue1\" value=\"123\" /&gt;\n&lt;add key=\"MyValue2\" value=\"abc\" /&gt;\n&lt;/appSettings&gt;\n</code></pre> <p>til configuration-noden.</p> <p>Herefter kan noderne afl\u00e6ses med </p> <pre><code>string v1 = System.Configuration.ConfigurationManager.AppSettings[\"MyValue1\"];\nstring v2 = System.Configuration.ConfigurationManager.AppSettings[\"MyValue2\"];\n</code></pre> <p>Men det kr\u00e6ver, at projektet har en reference (ikke NuGet) til</p> <pre><code>System.Configuration\n</code></pre>"},{"location":"175_Serialisering.html","title":"Serialisering","text":""},{"location":"175_Serialisering.html#om-modulet","title":"Om modulet","text":"<p>I dette modul kigger vi p\u00e5 XML og JSON serialisering.</p>"},{"location":"175_Serialisering.html#serialisering-i-net","title":"Serialisering i .NET","text":"<ul> <li>Serialisering</li> <li>Fra objekter til XML, JSON og bin\u00e6rt</li> <li>Desiralisering</li> <li>Fra XML, JSON, Bin\u00e6rt til objekter og retur</li> <li>Persistering af data</li> </ul>"},{"location":"175_Serialisering.html#xml-seralisering","title":"XML seralisering","text":"<ul> <li>System.Xml.Serialization</li> <li>Serialize</li> <li>Deserialize</li> <li> <p>Brug attributter som</p> </li> <li> <p>[Serializable]</p> </li> <li>[XmlIgnore]</li> <li>[XmlElement] som element</li> <li>[XmlAttribute] som attribute</li> </ul> <pre><code>using System;\nusing System.Collections.Generic;\nusing System.Text;\nnamespace SerialiseringDemo1\n{\n[Serializable]\npublic class Person\n{\n[System.Xml.Serialization.XmlAttribute]\npublic int Id { get; set; }\npublic string Navn { get; set; }\npublic int Alder { get; set; }\n[System.Xml.Serialization.XmlIgnore]\npublic string Cpr { get; set; }\npublic static List&lt;Person&gt; HentPersoner()\n{\nreturn new List&lt;Person&gt;() {\nnew Person(){ Id = 1, Navn = \"Mikkel\", Alder = 15, Cpr = \"111\" },\nnew Person(){ Id = 2, Navn = \"Mathias\", Alder = 12, Cpr = \"222\" },\nnew Person(){ Id = 3, Navn = \"Lene\", Alder = 51, Cpr = \"333\" }\n};\n}\n}\n}\n</code></pre> <pre><code>  // Serialisering af en enkelt\nXmlSerializer xs1 = new XmlSerializer(typeof(SerialiseringDemo1.Person));\nusing (FileStream fs = File.Create(@\"c:\\temp\\data.xml\"))\nxs1.Serialize(fs, SerialiseringDemo1.Person.HentPersoner()[0]);\nConsole.WriteLine(File.ReadAllText(@\"c:\\temp\\data.xml\"));\nConsole.WriteLine();\n// Serialisering af en liste\nXmlSerializer xs2 = new XmlSerializer(typeof(List&lt;SerialiseringDemo1.Person&gt;));\nusing (FileStream fs = File.Create(@\"c:\\temp\\data1.xml\"))\nxs2.Serialize(fs, SerialiseringDemo1.Person.HentPersoner());\nConsole.WriteLine(File.ReadAllText(@\"c:\\temp\\data1.xml\"));\nConsole.WriteLine();\n// Deserialisering af en enkelt\nXmlSerializer xs3 = new XmlSerializer(typeof(SerialiseringDemo1.Person));\nSerialiseringDemo1.Person p;\nusing (StreamReader fs = File.OpenText(@\"c:\\temp\\data.xml\"))\np = xs3.Deserialize(fs) as SerialiseringDemo1.Person;\nConsole.WriteLine(p.Navn);\nConsole.WriteLine();\n// Deserialisering af en liste\nXmlSerializer xs4 = new XmlSerializer(typeof(List&lt;SerialiseringDemo1.Person&gt;));\nList&lt;SerialiseringDemo1.Person&gt; lst;\nusing (StreamReader fs = File.OpenText(@\"c:\\temp\\data1.xml\"))\nlst = xs4.Deserialize(fs) as List&lt;SerialiseringDemo1.Person&gt;;\nConsole.WriteLine(string.Join(\" \", lst.Select(i =&gt; i.Navn).ToArray()));\n/*\n ---------- Output: ----------\n&lt;?xml version=\"1.0\"?&gt;\n&lt;Person xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:xsd=\"http://www.w3.org/2001/XMLSchema\" Id=\"1\"&gt;\n  &lt;Navn&gt;Mikkel&lt;/Navn&gt;\n  &lt;Alder&gt;15&lt;/Alder&gt;\n&lt;/Person&gt;\n&lt;?xml version=\"1.0\"?&gt;\n&lt;ArrayOfPerson xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:xsd=\"http://www.w3.org/2001/XMLSchema\"&gt;\n  &lt;Person Id=\"1\"&gt;\n    &lt;Navn&gt;Mikkel&lt;/Navn&gt;\n    &lt;Alder&gt;15&lt;/Alder&gt;\n  &lt;/Person&gt;\n  &lt;Person Id=\"2\"&gt;\n    &lt;Navn&gt;Mathias&lt;/Navn&gt;\n    &lt;Alder&gt;12&lt;/Alder&gt;\n  &lt;/Person&gt;\n  &lt;Person Id=\"3\"&gt;\n    &lt;Navn&gt;Lene&lt;/Navn&gt;\n    &lt;Alder&gt;51&lt;/Alder&gt;\n  &lt;/Person&gt;\n&lt;/ArrayOfPerson&gt;\nMikkel\nMikkel Mathias Lene\n*/\n</code></pre>"},{"location":"175_Serialisering.html#binr-serialisering","title":"Bin\u00e6r serialisering","text":"<ul> <li> <p>System.Runtime.Serialization.Formatters.Binary.BinaryFormatter</p> </li> <li> <p>Serialize</p> </li> <li> <p>Deserialize</p> </li> <li> <p>Brug attributter som</p> </li> <li>[Serializable]</li> <li>[NonSerialized]</li> </ul> <pre><code>using System;\nusing System.Collections.Generic;\nnamespace SerialiseringDemo2\n{\n[Serializable]\npublic class Person\n{\npublic int Id { get; set; }\npublic string Navn { get; set; }\npublic int Alder { get; set; }\n[NonSerialized]\nprivate string cpr;\npublic string Cpr\n{\nget { return cpr; }\nset { cpr = value; }\n}\npublic static List&lt;Person&gt; HentPersoner()\n{\nreturn new List&lt;Person&gt;() {\nnew Person(){ Id = 1, Navn = \"Mikkel\", Alder = 15, Cpr = \"111\" },\nnew Person(){ Id = 2, Navn = \"Mathias\", Alder = 12, Cpr = \"222\" },\nnew Person(){ Id = 3, Navn = \"Lene\", Alder = 51, Cpr = \"333\" }\n};\n}\n}\n}\n</code></pre> <pre><code>BinaryFormatter format = new BinaryFormatter();\n// Serialisering af en enkelt\nusing (FileStream fs = File.Create(@\"c:\\temp\\data.bin\"))\nformat.Serialize(fs, SerialiseringDemo2.Person.HentPersoner()[0]);\n// Serialisering af en liste\nusing (FileStream fs = File.Create(@\"c:\\temp\\data1.bin\"))\nformat.Serialize(fs, SerialiseringDemo2.Person.HentPersoner());\n// Deserialisering af en enkelt\nSerialiseringDemo2.Person p;\nusing (FileStream fs = File.OpenRead(@\"c:\\temp\\data.bin\"))\np = format.Deserialize(fs) as SerialiseringDemo2.Person;\nConsole.WriteLine(p.Navn);\nConsole.WriteLine();\n// Deserialisering af en liste\nList&lt;SerialiseringDemo2.Person&gt; lst;\nusing (FileStream fs = File.OpenRead(@\"c:\\temp\\data1.bin\"))\nlst = format.Deserialize(fs) as List&lt;SerialiseringDemo2.Person&gt;;\nConsole.WriteLine(string.Join(\" \", lst.Select(i =&gt; i.Navn).ToArray()));\n/*\n ---------- Output: ----------\nMikkel\nMikkel Mathias Lene\n*/\n</code></pre> <ul> <li>Kan f\u00e5 mere kontrol ved at implementere ISerizable for p\u00e5 den m\u00e5de at styre   hvilke data der medtages</li> <li>Afh\u00e6ngig af milj\u00f8/bruger kr\u00e6ves der muligvis SecurityPermission-attribut</li> <li>GetObjectData bliver kaldt ved serialisering</li> <li>Speciel constructor bliver kaldt ved deserialisering</li> </ul> <pre><code>using System;\nusing System.Collections.Generic;\nusing System.Runtime.Serialization;\nnamespace SerialiseringDemo3\n{\n[Serializable]\npublic class Person : ISerializable\n{\npublic int Id { get; set; }\npublic string Navn { get; set; }\npublic int Alder { get; set; }\n[NonSerialized]\nprivate string cpr;\npublic string Cpr\n{\nget { return cpr; }\nset { cpr = value; }\n}\npublic static List&lt;Person&gt; HentPersoner()\n{\nreturn new List&lt;Person&gt;() {\nnew Person(){ Id = 1, Navn = \"Mikkel\", Alder = 15, Cpr = \"111\" },\nnew Person(){ Id = 2, Navn = \"Mathias\", Alder = 12, Cpr = \"222\" },\nnew Person(){ Id = 3, Navn = \"Lene\", Alder = 51, Cpr = \"333\" }\n};\n}\npublic Person()\n{}\n// Bliver kaldt ved serialisering\npublic void GetObjectData(SerializationInfo info, StreamingContext context)\n{\ninfo.AddValue(\"id\", this.Id);\ninfo.AddValue(\"navn\", this.Navn);\n}\n// Bliver kaldt ved deserialisering\npublic Person(SerializationInfo i, StreamingContext s)\n{\nthis.Id = i.GetInt32(\"id\");\nthis.Navn = i.GetString(\"navn\");\n}\n}\n}\n</code></pre> <pre><code>BinaryFormatter format = new BinaryFormatter();\n// Serialisering af en enkelt\nusing (FileStream fs = File.Create(@\"c:\\temp\\data.bin\"))\nformat.Serialize(fs, SerialiseringDemo3.Person.HentPersoner()[0]);\n// Serialisering af en liste\nusing (FileStream fs = File.Create(@\"c:\\temp\\data1.bin\"))\nformat.Serialize(fs, SerialiseringDemo3.Person.HentPersoner());\n// Deserialisering af en enkelt\nSerialiseringDemo3.Person p;\nusing (FileStream fs = File.OpenRead(@\"c:\\temp\\data.bin\"))\np = format.Deserialize(fs) as SerialiseringDemo3.Person;\nConsole.WriteLine(p.Navn);\nConsole.WriteLine();\n// Deserialisering af en liste\nList&lt;SerialiseringDemo3.Person&gt; lst;\nusing (FileStream fs = File.OpenRead(@\"c:\\temp\\data1.bin\"))\nlst = format.Deserialize(fs) as List&lt;SerialiseringDemo3.Person&gt;;\nConsole.WriteLine(string.Join(\" \", lst.Select(i =&gt; i.Navn).ToArray()));\n/*\n ---------- Output: ----------\nMikkel\nMikkel Mathias Lene\n*/\n</code></pre>"},{"location":"175_Serialisering.html#json-serialisering","title":"JSON Serialisering","text":""},{"location":"175_Serialisering.html#brug-af-systemtextjson","title":"Brug af System.Text.Json","text":"<pre><code>using System;\nusing System.Collections.Generic;\nnamespace MinTest\n{\nclass Program\n{\nstatic void Main(string[] args)\n{\nvar personer = Person.HentPersoner();\nvar json = System.Text.Json.JsonSerializer.Serialize(personer,\nnew System.Text.Json.JsonSerializerOptions { WriteIndented = true });\nConsole.WriteLine(json);\n/*\n             [\n              {\n                \"Id\": 1,\n                \"Navn\": \"Mikkel\",\n                \"Alder\": 15,\n                \"Cpr\": \"111\"\n              },\n              {\n                \"Id\": 2,\n                \"Navn\": \"Mathias\",\n                \"Alder\": 12,\n                \"Cpr\": \"222\"\n              },\n              {\n                \"Id\": 3,\n                \"Navn\": \"Lene\",\n                \"Alder\": 51,\n                \"Cpr\": \"333\"\n              }\n            ]\n         */\n// den anden vej\nList&lt;Person&gt; l = System.Text.Json.JsonSerializer.Deserialize&lt;List&lt;Person&gt;&gt;(json);\nforeach (var item in l)\n{\nConsole.WriteLine(item.Navn);\n}\n}\n}\npublic class Person\n{\npublic int Id { get; set; }\npublic string Navn { get; set; }\npublic int Alder { get; set; }\npublic string Cpr { get; set; }\npublic static List&lt;Person&gt; HentPersoner()\n{\nreturn new List&lt;Person&gt;() {\nnew Person(){ Id = 1, Navn = \"Mikkel\", Alder = 15, Cpr = \"111\" },\nnew Person(){ Id = 2, Navn = \"Mathias\", Alder = 12, Cpr = \"222\" },\nnew Person(){ Id = 3, Navn = \"Lene\", Alder = 51, Cpr = \"333\" }\n};\n}\n}\n}\n</code></pre>"},{"location":"175_Serialisering.html#brug-af-datacontractjsonserializer","title":"Brug af DataContractJsonSerializer","text":"<ul> <li>benytter attributter som</li> <li>[DataContract]</li> <li>[DataMember]</li> </ul> <pre><code>using System;\nusing System.Collections.Generic;\nusing System.Runtime.Serialization;\nnamespace SerialiseringDemo4\n{\n[DataContract]\npublic class Person\n{\n[DataMember]\npublic int Id { get; set; }\n[DataMember]\npublic string Navn { get; set; }\n[DataMember]\npublic int Alder { get; set; }\npublic string Cpr { get; set; }\npublic static List&lt;Person&gt; HentPersoner()\n{\nreturn new List&lt;Person&gt;() {\nnew Person(){ Id = 1, Navn = \"Mikkel\", Alder = 15, Cpr = \"111\" },\nnew Person(){ Id = 2, Navn = \"Mathias\", Alder = 12, Cpr = \"222\" },\nnew Person(){ Id = 3, Navn = \"Lene\", Alder = 51, Cpr = \"333\" }\n};\n}\n}\n}\n</code></pre> <pre><code>DataContractJsonSerializer s1 =\nnew DataContractJsonSerializer\n(typeof(SerialiseringDemo4.Person));\nDataContractJsonSerializer s2 =\nnew DataContractJsonSerializer\n(typeof(List&lt;SerialiseringDemo4.Person&gt;));\nusing (FileStream fs = File.Create(@\"c:\\temp\\data.json\"))\ns1.WriteObject(fs, SerialiseringDemo4.Person.HentPersoner()[0]);\n// eller til string\nMemoryStream m = new MemoryStream();\ns1.WriteObject(m, SerialiseringDemo4.Person.HentPersoner()[0]);\nm.Position = 0;\nConsole.WriteLine((new StreamReader(m)).ReadToEnd());\nConsole.WriteLine();\nusing (FileStream fs = File.Create(@\"c:\\temp\\data1.json\"))\ns2.WriteObject(fs, SerialiseringDemo4.Person.HentPersoner());\n// Deserialisering af en enkelt\nSerialiseringDemo4.Person p;\nusing (FileStream fs = File.OpenRead(@\"c:\\temp\\data.json\"))\np = s1.ReadObject(fs) as SerialiseringDemo4.Person;\nConsole.WriteLine(p.Navn);\nConsole.WriteLine();\n// Deserialisering af en liste\nList&lt;SerialiseringDemo4.Person&gt; lst;\nusing (FileStream fs = File.OpenRead(@\"c:\\temp\\data1.json\"))\nlst = s2.ReadObject(fs) as List&lt;SerialiseringDemo4.Person&gt;;\nConsole.WriteLine(string.Join(\" \", lst.Select(i =&gt; i.Navn).ToArray()));\n/*\n ---------- Output: ----------\n{\"Alder\":15,\"Id\":1,\"Navn\":\"Mikkel\"}\nMikkel\nMikkel Mathias Lene\n*/\n</code></pre> <p>Der findes andre pakker p\u00e5 NuGet - herunder JSON.NET</p>"},{"location":"185_Globalisering.html","title":"Globalisering","text":""},{"location":"185_Globalisering.html#om-modulet","title":"Om modulet","text":"<p>Dette modul vil se p\u00e5 hvordan du kan skabe applikationer som arbejder med flere sprog.</p>"},{"location":"185_Globalisering.html#globalisering-og-lokalisering","title":"Globalisering og lokalisering","text":"<ul> <li>Globalisering er formatering af tal og datoer og sammlingning af strenge</li> <li> <p>Lokalisering er brug af ressource filer til overs\u00e6ttelse</p> </li> <li> <p>Ikke d\u00e6kket i dette modul</p> </li> </ul>"},{"location":"185_Globalisering.html#culture","title":"Culture","text":"<ul> <li> <p>En Culture best\u00e5r af</p> </li> <li> <p>Land (da, en, de)</p> </li> <li>Kultur (DK, US, DE)</li> <li>Tilsammen danner de en specifik kultur (da-DK, en-US)</li> <li>Et rent land kaldes en neutral kultur (da, en, de)</li> <li>Brug CultureInfo til at repr\u00e6sentere en kultur</li> </ul> <pre><code>System.Globalization.CultureInfo ci;\nci = new System.Globalization.CultureInfo(\"da-DK\");\nConsole.WriteLine($\"{ci.Name} {ci.NativeName} {ci.DisplayName}\");\nci = new System.Globalization.CultureInfo(\"en-US\");\nConsole.WriteLine($\"{ci.Name} {ci.NativeName} {ci.DisplayName}\");\nci = new System.Globalization.CultureInfo(\"en\");\nConsole.WriteLine($\"{ci.Name} {ci.NativeName} {ci.DisplayName}\");\nci = System.Globalization.CultureInfo.CurrentCulture;\nConsole.WriteLine($\"{ci.Name} {ci.NativeName} {ci.DisplayName}\");\n// Mange m\u00e5der at finde culture p\u00e5 - brug evt kald til framework\nvar lst = System.Globalization.CultureInfo.GetCultures(System.Globalization.CultureTypes.NeutralCultures);\nstring tmp = string.Join(\" \", lst.Skip(51).Take(25).Select(i =&gt; i.DisplayName));\nConsole.WriteLine(tmp);\n/*\n ---------- Output: ----------\nda-DK dansk (Danmark) Dansk (Danmark)\nen-US English (United States) Engelsk (USA)\nen English Engelsk\nda-DK dansk (Danmark) Dansk (Danmark)\nGr\u00e6sk Engelsk esperanto Spansk Estisk Baskisk ewondo Persisk Fulah Fulah Finsk Filippinsk F\u00e6r\u00f8sk Fransk furlan Vestfrisisk Irsk Skotsk g\u00e6lisk Galisisk Guarani Tysk (Schweiz) Gujarati Ekegusii Gaelg Hausa\n*/\n</code></pre> <ul> <li>RegionInfo giver flere informationer om landet - herunder valuta</li> </ul> <pre><code>System.Globalization.CultureInfo ci;\nci = System.Globalization.CultureInfo.CurrentCulture;\nSystem.Globalization.RegionInfo ri;\nri = new System.Globalization.RegionInfo(ci.Name);\nConsole.WriteLine($\"Valuta {ri.CurrencyNativeName} {ri.CurrencyEnglishName}\");\nConsole.WriteLine($\"Navn {ri.DisplayName} {ri.EnglishName}\");\n/*\n ---------- Output: ----------\nValuta Dansk krone Danish Krone\nNavn Danmark Denmark\n*/\n</code></pre>"},{"location":"185_Globalisering.html#formatering-og-typekonvertering","title":"Formatering og typekonvertering","text":"<ul> <li>Brug kultur til formatering</li> <li>Brug kultur til typekonvertering</li> </ul> <pre><code>System.Globalization.CultureInfo dk;\ndk = new System.Globalization.CultureInfo(\"da-DK\");\nSystem.Globalization.CultureInfo us;\nus = new System.Globalization.CultureInfo(\"en-US\");\ndouble tal = 1234567.433456;\nDateTime dato = new DateTime(2018, 1, 1);\nConsole.WriteLine($\"da: {tal.ToString(dk)}\");\nConsole.WriteLine($\"us: {tal.ToString(us)}\");\nConsole.WriteLine($\"da: {tal.ToString(\"N2\", dk)}\");\nConsole.WriteLine($\"us: {tal.ToString(\"N2\", us)}\");\nConsole.WriteLine($\"da: {tal.ToString(\"C2\", dk)}\");\nConsole.WriteLine($\"us: {tal.ToString(\"C2\", us)}\");\nConsole.WriteLine($\"da: {dato.ToString(\"d\", dk)}\");\nConsole.WriteLine($\"us: {dato.ToString(\"d\", us)}\");\nConsole.WriteLine($\"da: {dato.ToString(\"F\", dk)}\");\nConsole.WriteLine($\"us: {dato.ToString(\"F\", us)}\");\n// Type konvertering\ntal = System.Convert.ToDouble(\"23.434,43\", dk);\nConsole.WriteLine($\"tal: {tal.ToString(dk)}\");\ntal = System.Convert.ToDouble(\"23,434.43\", us);\nConsole.WriteLine($\"tal: {tal.ToString(dk)}\");\ndato = System.Convert.ToDateTime(\"30-1-2018\", dk);\nConsole.WriteLine($\"dato: {dato.ToString(\"d\", dk)}\");\ndato = System.Convert.ToDateTime(\"2018-1-30\", us);\nConsole.WriteLine($\"dato: {dato.ToString(\"d\", dk)}\");\n/*\n ---------- Output: ----------\nda: 1234567,433456\nus: 1234567.433456\nda: 1.234.567,43\nus: 1,234,567.43\nda: 1.234.567,43 kr.\nus: $1,234,567.43\nda: 01-01-2018\nus: 1/1/2018\nda: 1. januar 2018 00:00:00\nus: Monday, January 1, 2018 12:00:00 AM\ntal: 23434,43\ntal: 23434,43\ndato: 30-01-2018\ndato: 30-01-2018\n*/\n</code></pre>"},{"location":"185_Globalisering.html#sammenligning-og-sortering","title":"Sammenligning og sortering","text":"<pre><code>System.Globalization.CultureInfo dk;\ndk = new System.Globalization.CultureInfo(\"da-DK\");\nSystem.Globalization.CultureInfo us;\nus = new System.Globalization.CultureInfo(\"en-US\");\n// Returnerer -1 0 1\nConsole.WriteLine(dk.CompareInfo.Compare(\"Aarhus\", \"\u00c5rhus\", System.Globalization.CompareOptions.IgnoreCase));\nConsole.WriteLine(us.CompareInfo.Compare(\"Aarhus\", \"\u00c5rhus\", System.Globalization.CompareOptions.IgnoreCase));\nstring[] lst = { \"K\u00f8benhavn\", \"Aalborg\", \"\u00c5rhus\", \"Odense\" };\nvar lst1 = lst.OrderBy(i =&gt; i, StringComparer.Create(dk, true));\nvar lst2 = lst.OrderBy(i =&gt; i, StringComparer.Create(us, true));\nConsole.WriteLine(string.Join(\" \", lst1));\nConsole.WriteLine(string.Join(\" \", lst2));\n/*\n ---------- Output: ----------\n1\n-1\nK\u00f8benhavn Odense Aalborg \u00c5rhus\nAalborg \u00c5rhus K\u00f8benhavn Odense\n*/\n</code></pre>"},{"location":"195_RegEx.html","title":"RegEx","text":""},{"location":"195_RegEx.html#om-modulet","title":"Om modulet","text":"<p>Dette modul vil introducere dig til regular expressions i C#.</p>"},{"location":"195_RegEx.html#regular-expresions","title":"Regular Expresions","text":"<ul> <li>Standard for at finde m\u00f8nstre i strenge p\u00e5 mange platforme</li> <li>Validering</li> <li>Find</li> <li>Erstatning</li> <li>Benytter System.Text.RegularExpressions.Regex</li> </ul>"},{"location":"195_RegEx.html#regex-cheatsheats","title":"RegEx cheatsheat(s)","text":"<ul> <li> <p>Der er masser af beskrivelser p\u00e5 nettet omkring syntaks</p> </li> <li> <p>Regex tutorial\u200a\u2014\u200aA quick cheatsheet by examples</p> </li> <li>RegEx Storm</li> <li>RegEx Storm Tester</li> </ul>"},{"location":"195_RegEx.html#regex-eksempler","title":"RegEx eksempler","text":"<ul> <li> <p>kraftigt inspireret af (8 Regular Expressions You Should Know</p> </li> <li> <p>Simpelt password</p> </li> <li>/^[a-z0-9_-]{6,18}$/</li> <li>Hex</li> <li>/^#?([a-f0-9]{6}|[a-f0-9]{3})$/<ul> <li>6 eller 3 langt - skal starte med #</li> </ul> </li> <li>Email (mange forskellige meninger)</li> <li>/^([a-z0-9_.-]+)@([\\da-z.-]+).([a-z.]{2,6})$/</li> <li> <p>Url (mange forskellige meninger)</p> </li> <li> <p>/^(https?:\\/\\/)?([\\da-z.-]+).([a-z.]{2,6})([\\/\\w .-])\\/?$/</p> </li> </ul>"},{"location":"195_RegEx.html#ismatch","title":"IsMatch","text":"<pre><code>// using System.Text.RegularExpressions;\nRegex regex = new Regex(@\"^-?\\d+(\\,\\d{1,2})?$\");\nConsole.WriteLine(regex.IsMatch(\"-87,0\"));      Console.WriteLine(regex.IsMatch(\"42,000\"));     Console.WriteLine(regex.IsMatch(\"1111,22\"));    Console.WriteLine(regex.IsMatch(\"9999,88$\"));   Console.WriteLine(regex.IsMatch(\"9.999,88\"));   /*\n ---------- Output: ----------\nTrue\nFalse\nTrue\nFalse\nFalse\n*/\n</code></pre>"},{"location":"195_RegEx.html#match","title":"Match","text":"<pre><code>// using System.Text.RegularExpressions;\nstring input = \"Navn: Mathias Cronberg\";\nMatch m = Regex.Match(input, @\"Navn: (.*$)\");\nConsole.WriteLine(m.Groups[1]);\n/*\n ---------- Output: ----------\nMathias Cronberg\n*/\n</code></pre>"},{"location":"195_RegEx.html#erstat","title":"Erstat","text":"<pre><code>// using System.Text.RegularExpressions;\nstring input = \"03/24/2018\";\nstring s = Regex.Replace(input,\n@\"\\b(?&lt;month&gt;\\d{1,2})/(?&lt;day&gt;\\d{1,2})/(?&lt;year&gt;\\d{2,4})\\b\",\n\"${day}-${month}-${year}\"\n);\nConsole.WriteLine(s);\n/*\n ---------- Output: ----------\n24-03-2018\n*/\n</code></pre>"},{"location":"200_Reflection.html","title":"Reflection","text":""},{"location":"200_Reflection.html#om-modulet","title":"Om modulet","text":"<p>Dette modul vil introducere dig til reflection - muligheden for at kode arbejder med anden kode.</p>"},{"location":"200_Reflection.html#formal-med-reflection","title":"Form\u00e5l med reflection","text":"<ul> <li>Inspisere medlemmer p\u00e5 alle .NET typer<ul> <li>Inspisere attributter</li> </ul> </li> <li>Oprette kode dynamisk<ul> <li>Typer</li> <li>IL kode</li> </ul> </li> </ul> <p>Pr\u00f8v eksempelvis pakken <code>MCronberg.CSCourseHelper.Standard</code> som blandt andet indeholder en extension metode til objekt, der viser yderligere info om instanser.</p>"},{"location":"200_Reflection.html#assembly","title":"Assembly","text":"<ul> <li>Find typer</li> <li>Oprettelse instanser</li> <li>Afvikling af metoder</li> </ul> <pre><code>namespace Reflection1\n{\npublic class TestKlasse\n{\npublic int Id;\npublic string Navn { get; set; }\npublic void Test() { }\npublic int Test1() =&gt; this.Id;\npublic string Test2(int a, char b) =&gt; this.Navn?.ToUpper() + new string(b, a).ToUpper();\npublic static void Test3() { }\npublic TestKlasse() { }\npublic TestKlasse(int id, string navn)\n{\nthis.Id = id;\nthis.Navn = navn;\n}\n}\n}\n</code></pre> <pre><code>// using System.Reflection;\nAssembly assem = typeof(Reflection1.TestKlasse).Assembly;\nConsole.WriteLine(\"Assembly Full Name:\");\nConsole.WriteLine(assem.FullName);\nAssemblyName assemName = assem.GetName();\nConsole.WriteLine(\"\\nName: {0}\", assemName.Name);\nConsole.WriteLine(\"Version: {0}.{1}\",\nassemName.Version.Major, assemName.Version.Minor);\nObject o = assem.CreateInstance(\"Reflection1.TestKlasse\", false,\nBindingFlags.ExactBinding,\nnull, new Object[] { 1, \"a\" }, null, null);\nMethodInfo m = assem.GetType(\"Reflection1.TestKlasse\").GetMethod(\"Test1\");\nObject ret = m.Invoke(o, new Object[] { });\nConsole.WriteLine($\"Test1: {ret}\");\nm = assem.GetType(\"Reflection1.TestKlasse\").GetMethod(\"Test2\");\nret = m.Invoke(o, new Object[] { 3, 'x' });\nConsole.WriteLine($\"Test2: {ret}\");\n/*\n ---------- Output: ----------\nAssembly Full Name:\nEksempler, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null\nName: Eksempler\nVersion: 1.0\nTest1: 1\nTest2: AXXX\n*/\n</code></pre> <ul> <li>Mange forskellige statiske metoder p\u00e5 Assembly<ul> <li>Load()</li> <li>LoadFrom()</li> <li>ReflectionOnlyLoad()</li> <li>ReflectionOnlyLoadFrom()</li> <li>GetExecutingAssembly()</li> <li>GetEntryAssembly()</li> <li>GetTypes() (ikke statisk)</li> </ul> </li> </ul>"},{"location":"200_Reflection.html#type","title":"Type","text":"<ul> <li>Find medlemmer p\u00e5 typer<ul> <li>GetMembers()</li> <li>GetFields()</li> <li>GetProperties()</li> <li>GetEvents()</li> <li>GetMethods()</li> <li>GetConstructors()</li> </ul> </li> <li>Find information om medlemmer og evt eksekver<ul> <li>MemberInfo</li> <li>FieldInfo</li> <li>PropertyInfo</li> <li>EventInfo</li> <li>MethodBase</li> <li>MethodInfo</li> <li>ConstructorInfo</li> </ul> </li> <li>Filtrering med Bindingflags<ul> <li>Default</li> <li>DeclaredOnly</li> <li>FlattenHierarchy</li> <li>IgnoreCase</li> <li>Instance</li> <li>Public</li> <li>NonPublic</li> <li>Static</li> </ul> </li> </ul> <pre><code>// using System.Reflection;\nReflection1.TestKlasse o = new Reflection1.TestKlasse();\nType t = o.GetType();\nConsole.WriteLine(\"Felter:\");\nforeach (var item in t.GetFields())\nConsole.WriteLine($\"  {item.Name}\");\nConsole.WriteLine(\"Egenskaber:\");\nforeach (var item in t.GetProperties())\nConsole.WriteLine($\"  {item.Name}\");\nConsole.WriteLine(\"Instans metoder:\");\nforeach (var item in t.GetMethods(BindingFlags.Instance | BindingFlags.Public))\nConsole.WriteLine($\"  {item.Name}\");\nConsole.WriteLine(\"Statiske metoder:\");\nforeach (var item in t.GetMethods(BindingFlags.Static | BindingFlags.Public))\nConsole.WriteLine($\"  {item.Name}\");\nConsole.WriteLine(\"Constructors:\");\nforeach (var item in t.GetConstructors())\nConsole.WriteLine($\"  Argumenter: {item.GetParameters().Length}\");\n/*\n ---------- Output: ----------\nFelter:\n  Id\nEgenskaber:\n  Navn\nInstans metoder:\n  get_Navn\n  set_Navn\n  Test\n  Test1\n  Test2\n  ToString\n  Equals\n  GetHashCode\n  GetType\nStatiske metoder:\n  Test3\nConstructors:\n  Argumenter: 0\n  Argumenter: 2\n*/\n</code></pre>"},{"location":"200_Reflection.html#attributter","title":"Attributter","text":"<ul> <li>[]-format</li> <li>Ekstra metadata om typer og medlemmer</li> <li>Bruges meget af frameworket<ul> <li>[Obsolete]</li> <li>[AssemblyVersion]</li> <li>[Serializable]</li> <li>..</li> </ul> </li> <li>Nemt at lave sine egne</li> </ul> <pre><code>using System;\nnamespace Reflection2\n{\n[MinAttribut1]\npublic class MinKlasse {\n[MinAttribut2(1, 2)]\npublic void Test() { }\n}\npublic class MinAttribut1 : Attribute\n{\n}\npublic class MinAttribut2 : Attribute\n{\nprivate int a;\nprivate int b;\npublic MinAttribut2()\n{\n}\npublic MinAttribut2(int a=0, int b=1)\n{\nthis.a = a;\nthis.b = b;\n}\n}\n}\n</code></pre> <ul> <li>Attributter kan afl\u00e6ses gennem reflection</li> </ul> <pre><code>Reflection2.MinKlasse o = new Reflection2.MinKlasse();\nforeach (var item in o.GetType().GetCustomAttributes())\nConsole.WriteLine(item.ToString());\nforeach (var m in o.GetType().GetMethods())\nforeach (var a in m.GetCustomAttributes())\nConsole.WriteLine(a.ToString());\n/*\n ---------- Output: ----------\nReflection2.MinAttribut1\nReflection2.MinAttribut2\n*/\n</code></pre> <p>Info</p>"},{"location":"200_Reflection.html#opgave-200-1","title":"Opgave 200-1","text":"<p>Brug et par simple attributter (Obsolete og Conditional) (kode til s\u00f8gning: CAAB)</p> <p>Se opgave</p>"},{"location":"200_Reflection.html#caller-info-attributes","title":"Caller Info Attributes","text":"<p>Reflection-releaterede attributter</p> <pre><code>private static void CallerInfoTest([CallerMemberName] string callerMemberName = null, [CallerFilePath] string callerFilePath = null, [CallerLineNumber] int callerLineNumber = 0)\n{\nConsole.WriteLine(callerMemberName);\nConsole.WriteLine(callerFilePath);\nConsole.WriteLine(callerLineNumber);\n}\n</code></pre> <p>Info</p>"},{"location":"200_Reflection.html#opgave-200-2","title":"Opgave 200-2","text":"<p>Skab en klasse der implementerer INotifyPropertyChanged (kode til s\u00f8gning: CAAC)</p> <p>Se opgave</p>"},{"location":"200_Reflection.html#automatisk-kodegenerering","title":"Automatisk kodegenerering","text":"<ul> <li>Nogen gange giver det mening at genere kode dynamisk og automatisk<ul> <li>is\u00e6r ORM-produkter som EF ol. men der er mange andre eksempler</li> </ul> </li> <li>Frameworket har System.CodeDom som giver mulighed for at genere source (VB, C#) og eksekverbar IL</li> <li>Man opbygger et tr\u00e6 af objekter som repr\u00e6senterer kode, og evt kompilere dette til sidst</li> <li>Kort eksempel som genererer en enum ud fra en database</li> </ul> <pre><code>// using System.CodeDom\n// using Microsoft.CSharp;\n// Antag at dette er hentet fra et database-kald\n// og skal ligge til grund for en enum\nDictionary&lt;int, string&gt; StatusKoder = new Dictionary&lt;int, string&gt;();\nStatusKoder.Add(0, \"IkkeAngivet\");\nStatusKoder.Add(1, \"Ligegyldigt\");\nStatusKoder.Add(2, \"IkkeVigtigt\");\nStatusKoder.Add(4, \"Vigtigt\");\nStatusKoder.Add(8, \"MegetVigtig\");\n// Automatisk generering af enum\nCodeCompileUnit unit = new CodeCompileUnit();\nCodeNamespace ns = new CodeNamespace(\"MitNamespace\");\nns.Imports.Add(new CodeNamespaceImport(\"System\"));\nunit.Namespaces.Add(ns);\nCodeTypeDeclaration en = new CodeTypeDeclaration(\"StatusKoder\");\nen.IsEnum = true;\nns.Types.Add(en);\nforeach (var statuskode in StatusKoder)\n{\nCodeMemberField f = new CodeMemberField(\"\", statuskode.Value);\nf.InitExpression = new CodePrimitiveExpression(statuskode.Key);\nen.Members.Add(f);\n}\nCSharpCodeProvider p = new CSharpCodeProvider();\nusing (System.IO.TextWriter w = System.IO.File.CreateText(@\"c:\\temp\\statuskoder.cs\"))\n{\np.GenerateCodeFromCompileUnit(unit, w, new System.CodeDom.Compiler.CodeGeneratorOptions() {  BlankLinesBetweenMembers = false});\n}\n// F\u00f8lgende indhold vil nu v\u00e6re at finde i c:\\temp\\statuskoder.cs\n// (Bem\u00e6rk - sidste komma i en enum er lovligt i C#)\nConsole.WriteLine(System.IO.File.ReadAllText(@\"c:\\temp\\statuskoder.cs\"));\n/*\n ---------- Output: ----------\n//------------------------------------------------------------------------------\n// &lt;auto-generated&gt;\n//     This code was generated by a tool.\n//     Runtime Version:4.0.30319.42000\n//\n//     Changes to this file may cause incorrect behavior and will be lost if\n//     the code is regenerated.\n// &lt;/auto-generated&gt;\n//------------------------------------------------------------------------------\nnamespace MitNamespace {\n    using System;\n    public enum StatusKoder {\n        IkkeAngivet = 0,\n        Ligegyldigt = 1,\n        IkkeVigtigt = 2,\n        Vigtigt = 4,\n        MegetVigtig = 8,\n    }\n}\n*/\n</code></pre> <p>Der er s\u00e5gar mulighed for at skabe kode dynamisk og afvikle denne med det samme!!</p>"},{"location":"200_Reflection.html#scripting","title":"Scripting","text":"<p>Brug af Roslyn (open-source C# compilers with rich code analysis APIs) til at generere udtryk fra en streng (eval() i C#)</p> <pre><code>// Nuget Add Package Microsoft.CodeAnalysis.Scripting\nusing Microsoft.CodeAnalysis.CSharp.Scripting;\nusing Microsoft.CodeAnalysis.Scripting;\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Threading.Tasks;\nnamespace ConsoleApp2\n{\ninternal class Program\n{\nstatic async Task Main(string[] args)\n{\nvar albums = new List&lt;Album&gt;\n{\nnew Album { Quantity = 10, Artist = \"A\", Title = \"T1\" },\nnew Album { Quantity = 50, Artist = \"B\", Title = \"T2\" },\nnew Album { Quantity = 200, Artist = \"C\", Title = \"T3\" },\n};\nstring discountFilter = \"album =&gt; album.Quantity &gt; 10\";\nScriptOptions options = ScriptOptions.Default.AddReferences(typeof(Album).Assembly);\nFunc&lt;Album, bool&gt; discountFilterExpression = await CSharpScript.EvaluateAsync&lt;Func&lt;Album, bool&gt;&gt;(discountFilter, options);\nList&lt;Album&gt; res = albums.Where(discountFilterExpression).ToList();\nforeach (var item in res)\nConsole.WriteLine(item.Title);\n}\n}\npublic class Album\n{\npublic int Quantity { get; set; }\npublic string Artist { get; set; }\npublic string Title { get; set; }\n}\n}\n</code></pre> <p>Diverse artikler:</p> <ul> <li>https://www.strathweb.com/2018/01/easy-way-to-create-a-c-lambda-expression-from-a-string-with-roslyn/</li> <li>https://mariomucalo.com/eval-in-c-sharp-roslyn-microsoft-codeanalysis-csharp-scripting-nuget-package/</li> </ul>"},{"location":"330_Terning.html","title":"En OOP terning","text":""},{"location":"330_Terning.html#om-modulet","title":"Om modulet","text":"<p>En terning er rigtig god til at beskrive forskellige teorier inden for objektorienteret programmering med C#. S\u00f8rg for at kopiere koden over i en tom .NET Core Consol applikation og pr\u00f8v det.</p>"},{"location":"330_Terning.html#struct-eller-klasse","title":"Struct eller klasse","text":"<p>Hvis du skal skabe en type der repr\u00e6senterer en terning skal du tage stilling til om du vil benytte en struktur eller en klasse. Den umiddelbare forskel er om variabler indeholder v\u00e6rdier (sstuktur) eller referencer (klasse). Hvis der er tale om en struktur er det nemt at kopiere og sammenligne instanser, og det er nemt for runtime at rydde op. Hvis der er tale om en klasse er det nemt at sende/gemme referencer til terninger rundt i applikationen, men til geng\u00e6ld koster det lidt at allokere og rydde op. Det store argument for at benytte en klasse er dog mulighedern for nedarvning, og med tanke p\u00e5 at en terning kan benyttes i mange forskellige versioner (meyer, yatzy, ludo mv) b\u00f8r en terning repr\u00e6senteres af en klasse.</p> <pre><code>public class Terning {\n}\n</code></pre> <p>Klassen er public for at sikre, at den kan benyttes i andre projekter.</p>"},{"location":"330_Terning.html#felter","title":"Felter","text":"<p>Felter (fields) er typens (her klassens) interne data, og en terning har som minimum en v\u00e6rdi mellem 1 og 6. Du kan v\u00e6lge at benytte en byte (8 bit) for at det fylder s\u00e5 lidt som muligt, men i virkeligheden er det nok ligegyldigt s\u00e5 du kan lige s\u00e5 godt benytte en int (32 bit):</p> <pre><code>public class Terning\n{\npublic int V\u00e6rdi;\n}\n</code></pre> <p>Her har klassen f\u00e5et tilf\u00f8jet et offentligt felt, s\u00e5 nu kan der tildeles en v\u00e6rdi:</p> <pre><code>Terning t = new Terning();\nt.V\u00e6rdi = 4;\n</code></pre> <p>Problemet ved at benytte et offentligt felt er dog, at V\u00e6rdi kan tildeles alt hvad en int kan best\u00e5r af:</p> <pre><code>Terning t = new Terning();\nt.V\u00e6rdi = -4;\n</code></pre> <p>Det kunne skabe en del b\u00f8vl s\u00e5 det duer ikke. Du b\u00f8r ikke have nogle offentlige felter i dine typer!</p> <p>Du kunne m\u00e5ske overveje at benytte en enum tli at repr\u00e6sentere en v\u00e6rdi:</p> <pre><code>public enum TerningV\u00e6rdi\n{\nEt = 1, To = 2, Tre = 3, Fire = 4, Fem = 5,\nSeks = 6\n}\npublic class Terning\n{\npublic TerningV\u00e6rdi V\u00e6rdi;\n}\n</code></pre> <p>men det giver nok for meget b\u00f8vl med konvertering til int hele tiden. Havde det v\u00e6ret eksempelvis et kort fra et kortspil du skulle repr\u00e6sentere med en type giver det god mening. Vi holder fast i en int som type til at holde v\u00e6rdien af terningen.</p> <p>Der kan v\u00e6re andre felter som m\u00e5ske kunne medtages</p> <ul> <li>TidspunktForOprettelse (DateTime)</li> <li>ForrigeV\u00e6rdi (int)</li> <li>SnydeFaktor (double)</li> </ul> <p>og s\u00e5 videre.</p>"},{"location":"330_Terning.html#statiske-felter","title":"Statiske felter","text":"<p>Du kan eventuelt tilf\u00f8je statiske felter hvis du \u00f8nsker instanser som kan tilg\u00e5s af alt kode (offentlige statiske felter) eller som kan tilg\u00e5s af instanser af klassen (private offentlige felter). Se afsnit om metoder for et eksempel p\u00e5 et privat statisk felt.</p>"},{"location":"330_Terning.html#konstruktr","title":"Konstrukt\u00f8r","text":"<p>En konstrukt\u00f8r (constructor) giver mulighed for at afvikle kode n\u00e5r der oprettes en instans. Standard konstrukt\u00f8ren er uden argumenter, og de brugerdefinerede er med argumenter. I terningen kan begge m\u00e5ske give mening:</p> <pre><code>public class Terning\n{\npublic int v\u00e6rdi;\n// standard (default)\npublic Terning()\n{\nthis.v\u00e6rdi = 1;\n}\n// brugerdefineret (custom)\npublic Terning(int startV\u00e6rdi)\n{\nif (startV\u00e6rdi &lt; 1 || startV\u00e6rdi &gt; 6) {\nthrow new Exception(\"Forkert v\u00e6rdi\");\n}\nthis.v\u00e6rdi = startV\u00e6rdi;\n}\n}\n</code></pre> <p>Nu kan man oprette en instans p\u00e5 to m\u00e5der:</p> <pre><code>Terning t1 = new Terning();\nConsole.WriteLine(t1.v\u00e6rdi);        // 1\nTerning t2 = new Terning(2);\nConsole.WriteLine(t2.v\u00e6rdi);        // 2\n</code></pre>"},{"location":"330_Terning.html#metoder","title":"Metoder","text":"<p>Metoder er typens m\u00e5de at afvikle instruktioner - typisk relateret til typens felter. I en terning kunne der v\u00e6re flere metoder, men en b\u00f8r der som minimum v\u00e6re. Det kunne v\u00e6re fikst hvis terningen selv kan f\u00e5 en tilf\u00e6ldig v\u00e6rdi - s\u00e5 der b\u00f8r v\u00e6re en Ryst() metode.</p> <pre><code>public class Terning\n{\npublic int V\u00e6rdi;\npublic void Ryst()\n{\nSystem.Random rnd = new Random();\nthis.V\u00e6rdi = rnd.Next(1, 7);\n}\n}\n</code></pre> <p>Nu kan terningen \u201crystes\u201d for at f\u00e5 felter V\u00e6rdi tildelt en ny v\u00e6rdi:</p> <pre><code>Terning t = new Terning();\nt.Ryst();\nConsole.WriteLine(t.V\u00e6rdi); // tilf\u00e6ldig v\u00e6rdi\n</code></pre> <p>Der kunne v\u00e6re mange andre metoder:</p> <ul> <li>GemTilDisk()</li> <li>HentFraDisk()</li> <li>SkrivTilKonsol()</li> <li>SnydN\u00e6steGang()</li> </ul> <p>og s\u00e5 videre.</p>"},{"location":"330_Terning.html#brug-af-random","title":"Brug af Random","text":"<p>Rent performancem\u00e6ssigt kan man godt argumentere for, at f\u00f8lgende Ryst() metode m\u00e5ske ikke er super smart:</p> <pre><code>public class Terning\n{\npublic int V\u00e6rdi;\npublic void Ryst()\n{\n// Hver gang Ryst() kaldes bliver der skabt et nyt objekt\nSystem.Random rnd = new Random();\nthis.V\u00e6rdi = rnd.Next(1, 7);\n}\n}\n</code></pre> <p>For at undg\u00e5 at der oprettes et objekt af Random hver gang Ryst() kaldes kunne instansen af Random placeres p\u00e5 klasseniveau som et privat felt:</p> <pre><code>public class Terning\n{\npublic int V\u00e6rdi;\nprivate readonly System.Random rnd;\npublic void Ryst()\n{   this.V\u00e6rdi = this.rnd.Next(1, 7);\n}\npublic Terning()\n{\nthis.rnd = new Random();\n}\n}\n</code></pre> <p>Nu oprettes en instans af Random n\u00e5r der skabes en instans af Terning, og ike hver gang Ryst() kaldes (readonly betyder, at rnd ikke m\u00e5 tildeles en v\u00e6rdi andre steder end i en konstrukt\u00f8r).</p> <p>M\u00e5ske kan feltet endda g\u00f8res statisk s\u00e5ledes, at der kun er et objekt som kan bruges af alle terninger:</p> <pre><code>public class Terning\n{\npublic int V\u00e6rdi;\nprivate static readonly System.Random rnd;\npublic void Ryst()\n{\nthis.V\u00e6rdi = rnd.Next(1, 7);\n}\nstatic Terning()\n{\nrnd = new Random();\n}\n}\n</code></pre> <p>Bem\u00e6rk den nu statiske konstrukt\u00f8r.</p>"},{"location":"330_Terning.html#statiske-metoder","title":"Statiske metoder","text":"<p>Ryst er en instans metode - den arbejder p\u00e5 instansens data, men du kan ogs\u00e5 v\u00e6lge at tilf\u00f8je statiske metoder. Det er typisk hj\u00e6lpemetoder som ikke har noget med instanserne at g\u00f8re. P\u00e5 en terning kunne en statisk metode m\u00e5ske v\u00e6re FindTilf\u00e6ldigTerningV\u00e6rdi():</p> <pre><code>public class Terning\n{\npublic int V\u00e6rdi;\npublic void Ryst()\n{\nSystem.Random rnd = new Random();\nthis.V\u00e6rdi = rnd.Next(1, 7);\n}\npublic static int FindTilf\u00e6ldigTerningV\u00e6rdi() {\nSystem.Random rnd = new Random();\nreturn rnd.Next(1, 7);\n}\n}\n</code></pre> <p>Metoden kan bruges som f\u00f8lger:</p> <pre><code>Console.WriteLine(Terning.FindTilf\u00e6ldigTerningV\u00e6rdi());     // tilf\u00e6ldig v\u00e6rdi\n</code></pre> <p>Bem\u00e6rk, at metoden findes p\u00e5 typen og ikke p\u00e5 en instans.</p>"},{"location":"330_Terning.html#egenskaber","title":"Egenskaber","text":"<p>Et offentlig felt er en skidt id\u00e9 fordi du ikke kan styre tildeling og afl\u00e6sning af v\u00e6rdier:</p> <pre><code>public class Terning\n{\npublic int V\u00e6rdi;\n}\n</code></pre> <p>Dette er ikke smart:</p> <pre><code>Terning t = new Terning();\nt.V\u00e6rdi = -4;\n</code></pre> <p>Men du kan v\u00e6lge at indkasple data ved at g\u00f8re felterne private:</p> <pre><code>public class Terning\n{\nprivate int v\u00e6rdi;\n}\n</code></pre> <p>Bem\u00e6rk, at v\u00e6rdi nu er stavet med lille hvilket er den generelle navngivningsstandard.</p> <p>Nu kan feltet ikke tilg\u00e5s udefra men ved hj\u00e6lp af en offenlig egenskab skabes der adgang. I egenskaben kan du skrive den kode du \u00f8nsker:</p> <pre><code>public class Terning\n{\nprivate int v\u00e6rdi;\npublic int V\u00e6rdi\n{\nget\n{\n// sikkehedskode\n// logkode\nreturn this.v\u00e6rdi;\n}\nset\n{\n// sikkehedskode\n// logkode\n// valideringskode\nif (this.v\u00e6rdi &lt; 1 || this.v\u00e6rdi &gt; 6)\nthrow new Exception(\"Forkert v\u00e6rdi\");\nthis.v\u00e6rdi = value;\n}\n}\n}\n</code></pre> <p>Microsoft anbefaler, at en egenskab har samme navn som feltet men med det f\u00f8rste bogstav med stort.</p> <p>Nu kan feltet v\u00e6rdi tilg\u00e5s gennem egenskaben V\u00e6rdi men med valideringskode:</p> <pre><code>Terning t1 = new Terning();\nt1.V\u00e6rdi = 4;\nTerning t2 = new Terning();\nt2.V\u00e6rdi = -4;  // Exception\n</code></pre> <p>Du kan ogs\u00e5 overveje at benytte en automatisk egenskab som kun kan afl\u00e6ses udefra, og s\u00e5 benytte en konstrukt\u00f8r til at angive en v\u00e6rdi:</p> <pre><code>public class Terning\n{\npublic int V\u00e6rdi { get; private set; }\npublic Terning()\n{\nthis.V\u00e6rdi = 1;\n}\npublic Terning(int startV\u00e6rdi)\n{\nif (startV\u00e6rdi &lt; 1 || startV\u00e6rdi &gt; 6)\n{\nthrow new Exception(\"Forkert v\u00e6rdi\");\n}\nthis.V\u00e6rdi = startV\u00e6rdi;\n}\n}\n</code></pre> <p>Nu kan terningen kun f\u00e5 en v\u00e6rdi ved oprettelse - hereter kan den kun afl\u00e6ses.</p>"},{"location":"330_Terning.html#nedarvning","title":"Nedarvning","text":"<p>For Terning er en klasse kan den benyttes i et arvehieraki. Her er en generel terning og to mere specifikke terninger:</p> <pre><code>public class Terning\n{\nprotected static readonly System.Random rnd;\npublic int V\u00e6rdi\n{\nget; protected set;\n}\npublic Terning()\n{\nthis.Ryst();\n}\nstatic Terning()\n{\nrnd = new Random();\n}\npublic void Ryst()\n{\nthis.V\u00e6rdi = rnd.Next(1, 7);\n}\npublic Terning(int startV\u00e6rdi)\n{\nif (startV\u00e6rdi &lt; 1 || startV\u00e6rdi &gt; 6)\n{\nthrow new Exception(\"Forkert v\u00e6rdi\");\n}\nthis.V\u00e6rdi = startV\u00e6rdi;\n}\n}\npublic class PakkelegTerning : Terning\n{\npublic bool M\u00e5TagePakke()\n{\nreturn this.V\u00e6rdi == 6;\n}\n}\npublic class LudoTerning : Terning\n{\npublic bool ErStjerne()\n{\nreturn this.V\u00e6rdi == 3;\n}\npublic bool ErGlobus()\n{\nreturn this.V\u00e6rdi == 5;\n}\n}\n</code></pre> <p>Bem\u00e6rk at instansen af System.Random og egenskaben V\u00e6rdi nu kan tilg\u00e5s gennem et protected felt s\u00e5ledes, at objektet eventuelt kan benyttes i underklasser.</p>"},{"location":"330_Terning.html#polymorfi","title":"Polymorfi","text":"<p>Den ene gren af polymorfi (b\u00f8rn kan have deres egen implementation) kan ogs\u00e5 give god mening i en terning. For det f\u00f8rste kan den virtuelle metode ToString (fra System.Object) overskrives s\u00e5 den giver lidt mere mening:</p> <pre><code>public class Terning\n{\nprotected static readonly System.Random rnd;\npublic int V\u00e6rdi\n{\nget; private set;\n}\npublic Terning()\n{\nthis.Ryst();\n}\nstatic Terning()\n{\nrnd = new Random();\n}\npublic void Ryst()\n{\nthis.V\u00e6rdi = rnd.Next(1, 7);\n}\npublic Terning(int startV\u00e6rdi)\n{\nif (startV\u00e6rdi &lt; 1 || startV\u00e6rdi &gt; 6)\n{\nthrow new Exception(\"Forkert v\u00e6rdi\");\n}\nthis.V\u00e6rdi = startV\u00e6rdi;\n}\npublic override string ToString()\n{\nreturn $\"[ {this.V\u00e6rdi} ]\";\n}\n}\npublic class PakkelegTerning : Terning\n{\npublic bool M\u00e5TagePakke()\n{\nreturn this.V\u00e6rdi == 6;\n}\n}\npublic class LudoTerning : Terning\n{\npublic bool ErStjerne()\n{\nreturn this.V\u00e6rdi == 3;\n}\npublic bool ErGlobus()\n{\nreturn this.V\u00e6rdi == 5;\n}\npublic override string ToString()\n{\nif (this.ErStjerne())\nreturn \"[ S ]\";\nif (this.ErGlobus())\nreturn \"[ G ]\";\nreturn $\"[ {this.V\u00e6rdi} ]\";\n}\n}\n</code></pre> <p>Nu giver ToString god mening:</p> <pre><code>Terning t1 = new Terning();\nConsole.WriteLine(t1);\nLudoTerning t2 = new LudoTerning();\nConsole.WriteLine(t2);\nPakkelegTerning t3 = new PakkelegTerning();\nConsole.WriteLine(t3);\n</code></pre> <p>Du kan ogs\u00e5 v\u00e6lge at skabe egne virtuelle metoder. Hvad med en virtuel Ryst s\u00e5ledes, at underklasser kan v\u00e6lge at overskrive den:</p> <pre><code>public class Terning\n{\nprotected static readonly System.Random rnd;\npublic int V\u00e6rdi\n{\nget; protected set;\n}\npublic Terning()\n{\nthis.Ryst();\n}\nstatic Terning()\n{\nrnd = new Random();\n}\npublic virtual void Ryst()\n{\nthis.V\u00e6rdi = rnd.Next(1, 7);\n}\npublic Terning(int startV\u00e6rdi)\n{\nif (startV\u00e6rdi &lt; 1 || startV\u00e6rdi &gt; 6)\n{\nthrow new Exception(\"Forkert v\u00e6rdi\");\n}\nthis.V\u00e6rdi = startV\u00e6rdi;\n}\npublic override string ToString()\n{\nreturn $\"[ {this.V\u00e6rdi} ]\";\n}\n}\npublic class PakkelegTerning : Terning\n{\npublic bool M\u00e5TagePakke()\n{\nreturn this.V\u00e6rdi == 6;\n}\npublic override void Ryst()\n{\n// Hvis det er et lige millisekund...\nif (DateTime.Now.Millisecond % 2 == 0)\nthis.V\u00e6rdi = 6;\nelse\nbase.Ryst();\n}\n}\npublic class LudoTerning : Terning\n{\npublic bool ErStjerne()\n{\nreturn this.V\u00e6rdi == 3;\n}\npublic bool ErGlobus()\n{\nreturn this.V\u00e6rdi == 5;\n}\npublic override string ToString()\n{\nif (this.ErStjerne())\nreturn \"[ S ]\";\nif (this.ErGlobus())\nreturn \"[ G ]\";\nreturn $\"[ {this.V\u00e6rdi} ]\";\n}\n}\n</code></pre> <p>Nu er der en stor sansynlighed for at, pakkeleg-terningen rystes til en 6\u2019er.</p>"},{"location":"330_Terning.html#abstrakt-klasse","title":"Abstrakt klasse","text":"<p>I et arvehieraki er den \u00f8veste klasse tit blot \u201cmor\u201d for alle andre, og der dermed ikke b\u00f8r kunne skabes en instans af klassen. I s\u00e5 fald kan klassen g\u00f8res abstrakt. Det giver ogs\u00e5 mulighed for abstrakte metoder uden implementation som skal implementeres af underklasser:</p> <pre><code>public abstract class Terning\n{\nprotected static readonly System.Random rnd;\npublic int V\u00e6rdi\n{\nget; protected set;\n}\npublic Terning()\n{\nthis.Ryst();\n}\nstatic Terning()\n{\nrnd = new Random();\n}\npublic abstract void Ryst();\npublic Terning(int startV\u00e6rdi)\n{\nif (startV\u00e6rdi &lt; 1 || startV\u00e6rdi &gt; 6)\n{\nthrow new Exception(\"Forkert v\u00e6rdi\");\n}\nthis.V\u00e6rdi = startV\u00e6rdi;\n}\npublic override string ToString()\n{\nreturn $\"[ {this.V\u00e6rdi} ]\";\n}\n}\npublic class PakkelegTerning : Terning\n{\npublic bool M\u00e5TagePakke()\n{\nreturn this.V\u00e6rdi == 6;\n}\npublic override void Ryst()\n{\nif (DateTime.Now.Millisecond % 2 == 0)\nthis.V\u00e6rdi = 6;\nelse\nthis.V\u00e6rdi = rnd.Next(1, 7);\n}\n}\npublic class LudoTerning : Terning\n{\npublic bool ErStjerne()\n{\nreturn this.V\u00e6rdi == 3;\n}\npublic bool ErGlobus()\n{\nreturn this.V\u00e6rdi == 5;\n}\npublic override string ToString()\n{\nif (this.ErStjerne())\nreturn \"[ S ]\";\nif (this.ErGlobus())\nreturn \"[ G ]\";\nreturn $\"[ {this.V\u00e6rdi} ]\";\n}\npublic override void Ryst()\n{\nusing (System.Net.WebClient w = new System.Net.WebClient())\n{\n// Henter tilf\u00e6ldigt tal fra random.org\nstring s = w.DownloadString(\"https://www.random.org/integers/?num=1&amp;min=1&amp;max=6&amp;col=1&amp;base=10&amp;format=plain&amp;rnd=new\");\nthis.V\u00e6rdi = Convert.ToInt32(s);\n}\n}\n}\n</code></pre> <p>Nu er underklasser tvunget til at implementere Ryst(). PakkelegTerning bruger System.Random og et ur, og LudoTerning henter tal fra random.org.</p>"},{"location":"330_Terning.html#delegates","title":"Delegates","text":"<p>Brugen af delegates (referencer til metoder) kan blandt andet bruges til at afkoble Ryst-metoden i terningen s\u00e5ledes, at den der benytter terningen selv skal tilf\u00f8je metoden. </p> <p>Det kan g\u00f8res p\u00e5 \u201cden gamle m\u00e5de\u201d ved at definere en delegate der returnerer en int:</p> <pre><code>namespace Demo\n{\nusing System;\nclass Program\n{\nstatic void Main(string[] args)\n{\n// Enten\nRystDelegate d1 = new RystDelegate(MinRyst);\nTerning t1 = new Terning(d1);\nConsole.WriteLine(t1);\n// Eller \nRystDelegate d2 = MinRyst;\nTerning t2 = new Terning(d2);\nConsole.WriteLine(t2);\n// Eller             \nTerning t3 = new Terning(MinRyst);\nConsole.WriteLine(t3);\n}\nstatic int MinRyst()\n{\nreturn new Random().Next(1, 7);\n}\n}\npublic delegate int RystDelegate();\npublic class Terning\n{\nprivate RystDelegate RystMetode;\npublic int V\u00e6rdi\n{\nget; private set;\n}\npublic Terning(RystDelegate ryst)\n{\nif (ryst == null)\nthrow new ApplicationException(\"Mangler Ryst\");\nthis.RystMetode = ryst;\nthis.Ryst();\n}\npublic void Ryst()\n{\nthis.V\u00e6rdi = this.RystMetode.Invoke();\n}\npublic override string ToString()\n{\nreturn $\"[ {this.V\u00e6rdi} ]\";\n}\n}\n}\n</code></pre>"},{"location":"330_Terning.html#brug-af-indbyggede-delegates","title":"Brug af indbyggede delegates","text":"<p>I stedet for at definere en delegate kunne du benytte en Func i stedet:</p> <pre><code>namespace Demo\n{\nusing System;\nclass Program\n{\nstatic void Main(string[] args)\n{\n// Enten\nFunc&lt;int&gt; d1 = MinRyst;\nTerning t1 = new Terning(d1);\nConsole.WriteLine(t1);\n// Eller \nFunc&lt;int&gt; d2 = MinRyst;\nTerning t2 = new Terning(d2);\nConsole.WriteLine(t2);\n// Eller             \nTerning t3 = new Terning(MinRyst);\nConsole.WriteLine(t3);\n}\nstatic int MinRyst()\n{\nreturn new Random().Next(1, 7);\n}\n}\npublic class Terning\n{\nprivate Func&lt;int&gt; RystMetode;\npublic int V\u00e6rdi\n{\nget; private set;\n}\npublic Terning(Func&lt;int&gt; ryst)\n{\nif (ryst == null)\nthrow new ApplicationException(\"Mangler Ryst\");\nthis.RystMetode = ryst;\nthis.Ryst();\n}\npublic void Ryst()\n{\nthis.V\u00e6rdi = this.RystMetode.Invoke();\n}\npublic override string ToString()\n{\nreturn $\"[ {this.V\u00e6rdi} ]\";\n}\n}\n}\n</code></pre>"},{"location":"330_Terning.html#lambda","title":"Lambda","text":"<p>I stedet for en konkret MinRyst-metode giver det m\u00e5ske mening at bruge en lambda i stedet:</p> <pre><code>namespace Demo\n{\nusing System;\nclass Program\n{\nstatic void Main(string[] args)\n{\n// Enten\nFunc&lt;int&gt; d1 = () =&gt; new Random().Next(1, 7);\nTerning t1 = new Terning(d1);\nConsole.WriteLine(t1);\n// Eller             \nTerning t2 = new Terning(() =&gt; new Random().Next(1, 7));\nConsole.WriteLine(t2);\n}\n}\npublic class Terning\n{\nprivate Func&lt;int&gt; RystMetode;\npublic int V\u00e6rdi\n{\nget; private set;\n}\npublic Terning(Func&lt;int&gt; ryst)\n{\nif (ryst == null)\nthrow new ApplicationException(\"Mangler Ryst\");\nthis.RystMetode = ryst;\nthis.Ryst();\n}\npublic void Ryst()\n{\nthis.V\u00e6rdi = this.RystMetode.Invoke();\n}\npublic override string ToString()\n{\nreturn $\"[ {this.V\u00e6rdi} ]\";\n}\n}\n}\n</code></pre>"},{"location":"330_Terning.html#hndelser","title":"H\u00e6ndelser","text":"<p>Med h\u00e6ndelser kan du skabe en terning som selv afvikler kode n\u00e5r der rystes en sekser. I virkeligheden er der blot tale om en \u201cbeskyttet\u201d delegate der erkl\u00e6res ved hj\u00e6lp af event-kodeordet, og der benyttes typisk den indbyggede EventHandler- eller EventHandler\\&lt;T&gt; delegate for at overholde best-practice.</p> <pre><code>using System;\nnamespace Demo\n{\ninternal class Program\n{\npublic static void Main()\n{\nTerning t = new Terning() ;\nt.Sekser += (s, e) =&gt; Console.Beep();\nt.Ryst();\nConsole.WriteLine(t.V\u00e6rdi);\n}\n}\npublic class Terning\n{\npublic event EventHandler Sekser;\npublic int V\u00e6rdi\n{\nget; private set;\n}\npublic void Ryst()\n{\nthis.V\u00e6rdi = new Random().Next(1, 7);\nif (this.V\u00e6rdi == 6)\nthis.Sekser?.Invoke(this, new EventArgs());\n}\npublic override string ToString()\n{\nreturn $\"[ {this.V\u00e6rdi} ]\";\n}\n}\n}\n</code></pre>"},{"location":"330_Terning.html#async","title":"ASync","text":"<p>Du kan overveje at benytte en asynkron Ryst s\u00e5fremt der er tale om instruktioner som kan tage tid at afvikle. Dermed kan hovedtr\u00e5den frigives til andet arbejde medens Ryst afvikles (giver ikke meget mening i en konsol-app men i UI applikationer kan det have en v\u00e6rdi).</p> <pre><code>using System;\nusing System.Net;\nusing System.Net.Http;\nusing System.Threading.Tasks;\nnamespace Demo\n{\ninternal class Program\n{\npublic static async Task Main()\n{\nTerning t = new Terning();\nt.Ryst();\nConsole.WriteLine(t.V\u00e6rdi);\nawait t.RystAsync();\nConsole.WriteLine(t.V\u00e6rdi);\n}\n}\npublic class Terning\n{\npublic int V\u00e6rdi\n{\nget; private set;\n}\npublic void Ryst()\n{\nusing (WebClient w = new WebClient())\n{\nstring tal = w.DownloadString(\"https://www.random.org/integers/?num=1&amp;min=1&amp;max=6&amp;col=1&amp;base=10&amp;format=plain&amp;rnd=new\");\nthis.V\u00e6rdi = Convert.ToInt32(tal);\n}\n}\npublic async Task RystAsync()\n{\nHttpClient httpClient = new HttpClient();\nvar tal = await httpClient.GetStringAsync(\"https://www.random.org/integers/?num=1&amp;min=1&amp;max=6&amp;col=1&amp;base=10&amp;format=plain&amp;rnd=new\");\nthis.V\u00e6rdi = Convert.ToInt32(tal);\n}\npublic override string ToString()\n{\nreturn $\"[ {this.V\u00e6rdi} ]\";\n}\n}\n}\n</code></pre>"},{"location":"360_Optimering.html","title":"Optimering","text":""},{"location":"360_Optimering.html#om-modulet","title":"Om modulet","text":"<p>I dette modul ser vi p\u00e5 optimering af kode - herunder brug af IDisposable.</p>"},{"location":"360_Optimering.html#objektets-liv-og-dd","title":"Objektets liv og d\u00f8d","text":"<ul> <li>Objekt oprettes</li> <li>constructor k\u00f8res</li> <li>Objektet lever sit liv p\u00e5 heap\u2019en</li> <li>Objektet slettes (enten ved null eller scope)</li> <li>Finalize/destructor</li> <li>Hukommelse frigives</li> <li>runtime h\u00e5ndterer oprettelse af objektet</li> <li>Garbage Collection rydder op</li> </ul>"},{"location":"360_Optimering.html#tilgange-til-garbage-collection","title":"Tilgange til garbage Collection","text":"<ul> <li>System.GC</li> <li>Collect();</li> <li>WaitForPendingFinalizers()</li> <li>masse metoder men i praksis skal man lave GC g\u00f8re det automatisk</li> </ul>"},{"location":"360_Optimering.html#destructors","title":"Destructors","text":"<ul> <li>Finalize kommer fra System.Object og kan ikke overskrives</li> <li>Brug en destructor</li> <li>~Navn</li> <li>Ved arv k\u00f8res finanlize \u201cfra bunden (specialiseret til generaliseret)</li> </ul> <pre><code>using System;\nusing System.Collections.Generic;\nusing System.Text;\nnamespace Oprydning\n{\nclass A\n{\npublic A()\n{\nConsole.WriteLine(\"A()\");\n}\n~A() {\n// Console.WriteLine(\"~A()\");\n}\n}\nclass B: A\n{\npublic B()\n{\nConsole.WriteLine(\"B()\");\n}\n~B()\n{\n// Console.WriteLine(\"~B()\");\n}\n}\n}\n</code></pre> <pre><code>Oprydning.B b = new Oprydning.B();\nb = null;\nGC.Collect();\nGC.WaitForPendingFinalizers();\n/*\n ---------- Output: ----------\nA()\nB()\n~B()\n~A()\n*/\n</code></pre> <ul> <li>Problemet er, at man ikke ved hvorn\u00e5r finanlize k\u00f8rer!!!</li> </ul>"},{"location":"360_Optimering.html#idisposable","title":"IDisposable","text":"<ul> <li>IDisposable har en enkelt Dispose-metode som kan implementeres hvis man i kode   \u00f8nsker at kunne rydde op</li> </ul> <pre><code>using System;\nnamespace Oprydning\n{\nclass C : IDisposable\n{\n#region IDisposable Support\nprivate bool disposedValue = false; // To detect redundant calls\nprotected virtual void Dispose(bool disposing)\n{\nif (!disposedValue)\n{\nif (disposing)\n{\n// TODO: dispose managed state (managed objects).\n}\n// TODO: free unmanaged resources (unmanaged objects) and override a finalizer below.\n// TODO: set large fields to null.\ndisposedValue = true;\n}\n}\n// TODO: override a finalizer only if Dispose(bool disposing) above has code to free unmanaged resources.\n// ~A() {\n//   // Do not change this code. Put cleanup code in Dispose(bool disposing) above.\n//   Dispose(false);\n// }\n// This code added to correctly implement the disposable pattern.\npublic void Dispose()\n{\n// Do not change this code. Put cleanup code in Dispose(bool disposing) above.\nDispose(true);\n// TODO: uncomment the following line if the finalizer is overridden above.\n// GC.SuppressFinalize(this);\n}\n#endregion\n}\n}\n</code></pre> <ul> <li>Nu kan man k\u00f8re [objekt].Dispose() hvis man \u00f8nsker at rydde op</li> <li>K\u00f8res automatisk med en using-struktur<ul> <li>Se Avancerede typer</li> </ul> </li> </ul>"},{"location":"360_Optimering.html#memory-leaks","title":"Memory leaks","text":"<ul> <li> <p>Man kan godt skabe mem.leaks i C#</p> </li> <li> <p>Is\u00e6r events kan g\u00f8re ondt</p> </li> <li>Se (og k\u00f8r i VS - se hukommelsesforbrug stige) dette eksempel hvor en App skaber objekter     der binder en metode til \u201cmor\u2019s\u201d event og glemmer at slette referencen</li> </ul> <pre><code>using System;\nusing System.Collections.Generic;\nnamespace MemLeak1\n{\nclass Program\n{\nstatic void Main(string[] args)\n{\nMinApp app = new MinApp();\nfor (int x = 0; x &lt; 100; x++)\n{\nfor (int i = 0; i &lt; 10000; i++)\n{\napp.OpretObjekt();\n}\nSystem.Threading.Thread.Sleep(200);\n}\n}\n}\nclass MinApp\n{\npublic event EventHandler Hjerteslag;\npublic void OpretObjekt()\n{\nvar o = new MitObjekt(this);\no = null;\n}\npublic void Tick()\n{\nif (Hjerteslag != null)\nHjerteslag(this, new EventArgs());\n}\n}\nclass MitObjekt\n{\nprivate MinApp mor;\npublic MitObjekt(MinApp mor)\n{\nthis.mor = mor;\nthis.mor.Hjerteslag += SkrivTick;\n}\nprivate void SkrivTick(object s, EventArgs e)\n{\nConsole.WriteLine(\"Tick\");\n}\n~MitObjekt()\n{\nthis.mor.Hjerteslag -= SkrivTick;\n}\n}\n}  </code></pre> <ul> <li>Her bliver der ryddet op</li> </ul> <pre><code>using System;\nusing System.Collections.Generic;\nnamespace MemLeak2\n{\nclass Program\n{\nstatic void Main(string[] args)\n{\nMinApp app = new MinApp();\nfor (int x = 0; x &lt; 100; x++)\n{\nfor (int i = 0; i &lt; 10000; i++)\n{\napp.OpretObjekt();\n}\nSystem.Threading.Thread.Sleep(200);\napp.FjernReferencer();\n}\n}\n}\nclass MinApp\n{\npublic event EventHandler Hjerteslag;\npublic List&lt;MitObjekt&gt; lst = new List&lt;MitObjekt&gt;();\npublic void OpretObjekt()\n{\nlst.Add(new MitObjekt(this));\n}\npublic void Tick()\n{\nif (Hjerteslag != null)\nHjerteslag(this, new EventArgs());\n}\npublic void FjernReferencer()\n{\nforeach (var item in lst)\n{\nitem.FjernEvent();\n}\n}\n}\nclass MitObjekt\n{\nprivate MinApp mor;\npublic MitObjekt(MinApp mor)\n{\nthis.mor = mor;\nthis.mor.Hjerteslag += SkrivTick;\n}\nprivate void SkrivTick(object s, EventArgs e)\n{\nConsole.WriteLine(\"Tick\");\n}\npublic void FjernEvent()\n{\nthis.mor.Hjerteslag -= SkrivTick;\n}\n}\n}\n</code></pre> <ul> <li>Kan ogs\u00e5 s\u00e6tte delegate til null</li> </ul> <pre><code>using System;\nusing System.Collections.Generic;\nnamespace MemLeak3\n{\nclass Program\n{\nstatic void Main(string[] args)\n{\nMinApp app = new MinApp();\nfor (int x = 0; x &lt; 100; x++)\n{\nfor (int i = 0; i &lt; 10000; i++)\n{\napp.OpretObjekt();\n}\nSystem.Threading.Thread.Sleep(200);\napp.FjernReferencer();\nGC.Collect();\nGC.WaitForPendingFinalizers();\n}\n}\n}\nclass MinApp\n{\npublic event EventHandler Hjerteslag;\npublic void OpretObjekt()\n{\nvar o = new MitObjekt(this);\no = null;\n}\npublic void Tick()\n{\nif (Hjerteslag != null)\nHjerteslag(this, new EventArgs());\n}\npublic void FjernReferencer()\n{\nHjerteslag = null;\n}\n}\nclass MitObjekt\n{\nprivate MinApp mor;\npublic MitObjekt(MinApp mor)\n{\nthis.mor = mor;\nthis.mor.Hjerteslag += SkrivTick;\n}\nprivate void SkrivTick(object s, EventArgs e)\n{\nConsole.WriteLine(\"Tick\");\n}\n}\n}\n</code></pre>"},{"location":"360_Optimering.html#ref-local","title":"ref local","text":"<p>Fra C# 7 kan metoder nu returnerer v\u00e6rdibaserede variabler by ref, og de skal gemmes i en \u201cref local\u201d variabel.</p> <pre><code>char[] arr = { 'r', 'e', 't'};\nConsole.WriteLine(string.Join(\" \", arr));\nchar res1 = getChar1(2, arr);\nres1 = 'f';\nConsole.WriteLine(string.Join(\" \", arr));\nref char res2 = ref getChar2(2, arr);\nres2 = 'f';\nConsole.WriteLine(string.Join(\" \", arr));\nchar getChar1(int index, char[] a) {\nreturn a[index];\n}\nref char getChar2(int index, char[] a)\n{\nreturn ref a[index];\n}\n</code></pre> <p>Pas lidt p\u00e5 hvor og hvordan man bruger dem</p>"},{"location":"360_Optimering.html#span","title":"Span <p>I C# 7 blev Span introduceret og giver typesikker adgang til et omr\u00e5de i hukommelsen (stack/heap). Se det som et vindue mod hukommelse med mulighed for at tilrette direkte.  <p>Bem\u00e6rk - der er typisk tale om mikrooptimering!</p>","text":""},{"location":"360_Optimering.html#eksempel-pa-span","title":"Eksempel p\u00e5 Span <pre><code>string[] array = { \"a\", \"b\", \"c\", \"d\", \"e\" };\n// Slizing\nvar firstView = new Span&lt;string&gt;(array, 0, 3);\nvar secondView = new Span&lt;string&gt;(array, 2, 3);\n\nfirstView[0] = \"w\";\nConsole.WriteLine(string.Join(' ', array));\n// array = { \"w\", \"b\", \"c\", \"d\", \"e\" }\nfirstView[2] = \"x\";\nConsole.WriteLine(string.Join(' ', array));\n// array = { \"w\", \"b\", \"x\", \"d\", \"e\" }\nsecondView[0] = \"y\";\nConsole.WriteLine(string.Join(' ', array));\n// array = { \"w\", \"b\", \"y\", \"d\", \"e\" }\n</code></pre> <p>Span har en s\u00f8ster kaldet ReadOnlySpan som giver en readonly adgang.","text":""},{"location":"360_Optimering.html#eksempel-pa-readonlyspan","title":"Eksempel p\u00e5 ReadOnlySpan <pre><code>{\n\n    string navn = \"Michell Cronberg\";\n    int mellemrum = navn.IndexOf(\" \");\n    string fornavn = navn.Substring(0, mellemrum);\n    string efternavn = navn.Substring(mellemrum + 1);\n    Console.WriteLine(fornavn);\n    Console.WriteLine(efternavn);\n    // Problem: fornavn og efternavn allokeres p\u00e5 heap (og efterf\u00f8lgende skal fjernes)\n}\n\n{\n    string navn = \"Michell Cronberg\";\n    int mellemrum = navn.IndexOf(\" \");\n    ReadOnlySpan&lt;char&gt; span = navn.AsSpan();\n    // 'slize' til et nyt vindue\n    ReadOnlySpan&lt;char&gt; fornavn = span.Slice(0, mellemrum);\n    ReadOnlySpan&lt;char&gt; efternavn = span.Slice(mellemrum + 1);\n    Skriv(fornavn);\n    Console.WriteLine();\n    Skriv(efternavn);\n\n    // Console.WriteLine mangler et overload der tager Span&lt;T&gt;\n    void Skriv(ReadOnlySpan&lt;char&gt; chars)\n    {\n        for (int i = 0; i &lt; chars.Length; i++)\n            Console.Write(chars[i]);\n    }\n\n\n}\n</code></pre> <p>Her er et mere grundigt eksempel: </p> <pre><code>// Kr\u00e6ver Benchmark.NET\n// Eksempel kraftigt inspireret af \n// https://www.stevejgordon.co.uk/an-introduction-to-optimising-code-using-span-t\n\nusing BenchmarkDotNet.Attributes;\nusing BenchmarkDotNet.Order;\nusing BenchmarkDotNet.Running;\n\nnamespace Test\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            string name = \"Michel A Cronberg\";\n            NameParser p = new NameParser();\n            Console.WriteLine(p.GetLastNameUsingSplit(name));\n            Console.WriteLine(p.GetLastNameUsingSubstring(name));\n            Console.WriteLine(p.GetLastNameWithSpan(name));\n            var result = BenchmarkRunner.Run(typeof(NameParser).Assembly);\n        }\n    }\n    public class NameParser\n    {\n        public string GetLastNameUsingSplit(string fullName)\n        {\n            var s = fullName.Split(' ');\n            return s.Length &gt; -1\n                ? s[s.Length - 1]\n                : string.Empty;\n        }\n\n        public string GetLastNameUsingSubstring(string fullName)\n        {\n            var lastSpaceIndex = fullName.LastIndexOf(\" \", StringComparison.Ordinal);\n\n            return lastSpaceIndex == -1\n                ? string.Empty\n                : fullName.Substring(lastSpaceIndex + 1);\n        }\n\n        public string GetLastNameWithSpan(ReadOnlySpan&lt;char&gt; fullName)\n        {\n            var lastSpaceIndex = fullName.LastIndexOf(' ');\n\n            // koster 40b at returnere en string - kunne returnere en readonlyspan&lt;t&gt;\n            return lastSpaceIndex == -1\n                ? string.Empty\n                : fullName.Slice(lastSpaceIndex + 1).ToString();\n        }\n    }\n\n    [RankColumn]\n    [Orderer(SummaryOrderPolicy.FastestToSlowest)]\n    [MemoryDiagnoser]\n    public class NameParserBenchmarks\n    {\n        private const string FullName = \"Michell A Cronberg\";\n        private static readonly NameParser Parser = new NameParser();\n\n        [Benchmark(Baseline = true)]\n        public void GetLastNameUsingSplit()\n        {\n            Parser.GetLastNameUsingSplit(FullName);\n        }\n\n        [Benchmark]\n        public void GetLastNameUsingSubstring()\n        {\n            Parser.GetLastNameUsingSubstring(FullName);\n        }\n\n        [Benchmark]\n        public void GetLastNameWithSpan()\n        {\n            Parser.GetLastNameWithSpan(FullName);\n        }\n    }\n}\n</code></pre>","text":""},{"location":"360_Optimering.html#memory","title":"Memory <p>Da Span arbejder p\u00e5 stack\u2019en kan den ikke bruges som felter i klasser, og dermed ikke i lambda eller som parametre i async metoder. Derfor findes Memory (ReadOnlyMemory) som giver disse muligheder: <pre><code>// async Task Test(Span&lt;int&gt; mem) --- fejl\nasync Task Test(Memory&lt;int&gt; mem)\n{\n\n}\n</code></pre> <p>Memory kan efterf\u00f8lgende konverteres til Span (men ikke den anden vej)","text":""},{"location":"400_Git.html","title":"Git og GitHub","text":""},{"location":"400_Git.html#om-modulet","title":"Om modulet","text":"<p>I dette modul bliver du introduceret til Git og GitHub, samt brugen af begge i Visual Studio.</p> <p></p> <p>Fra WikiPedia</p>"},{"location":"400_Git.html#git","title":"Git","text":"<p>Git er et frit, distribueret versionsstyringssystem med fokus p\u00e5 hastighed, designet til at vedligeholde kildekode. Git blev skabt af Linus Torvalds til udvikling af Linuxkernen.</p> <p>Alt er som udgangspunkt gemt lokalt, og baseret p\u00e5 en konkret rod-mappe hvor alt automatisk er under versionsstyring. Man kan dog v\u00e6lge hvilke filer og mapper man \u00f8nsker udtaget af versionsstyring gennem en .gitignore fil i roden af mappen. Se github/gitignore, og evt. en fil direkte relateret til C# l\u00f8sninger.</p>"},{"location":"400_Git.html#github","title":"GitHub","text":"<p>GitHub er en af de mange cloududbydere af versionstyring baseret p\u00e5 Git. GitHub blev k\u00f8bt af Microsoft i 2018 for en ufattelig masse penge. Det er gratis at oprette b\u00e5de offentlige og (et bekr\u00e6nset antal) private repositories, men et abonnement kan k\u00f8bes for f\u00e5 \\$.</p>"},{"location":"400_Git.html#git-github-og-visual-studio","title":"Git, GitHub og Visual Studio","text":"<p>Git er indbygget i de sidste nye versioner af Visual Studio, og de fleste installationer s\u00f8rger ligeledes for, at GitHub Extension for Visual Studio bliver installeret. Ellers b\u00f8r du selv g\u00f8re det.</p>"},{"location":"400_Git.html#tilfj-vs-lsning-til-source-control","title":"Tilf\u00f8j VS l\u00f8sning til source control","text":"<p>Som udgangspunkt er en ny l\u00f8sning ikke under versionsstyring s\u00e5 det skal du selv g\u00f8re. </p> <ul> <li>H\u00f8jreklik p\u00e5 l\u00f8sningen i Solution Explorer-vinduet, og v\u00e6lg \u201cAdd solution to source control\u201d.</li> </ul>"},{"location":"400_Git.html#gem-rettelser-lokalt","title":"Gem rettelser (lokalt)","text":"<p>N\u00e5r du \u00f8nsker at gemme rettelser kan du g\u00f8re det i Team Explorer-vinduet (typisk placeret i samme vindue som Solution Explorer).</p> <ul> <li>Find Team Explorer-vinduet</li> <li>Klik p\u00e5 huset i toppen af vinduet</li> <li>Klik p\u00e5 Changes-knappen</li> <li>Skriv en tekst (commit message)</li> <li>Klik p\u00e5 Commit all-knappen</li> </ul> <p>Ny er rettelser gemt som et commit, og kan ses under Sync (huset i toppen af vinduet og Sync-knappen). Bem\u00e6rk, at der kun er gemt lokalt - der er ikke synkroniseret med en Git-udbyder (som eksempelvis GitHub).</p>"},{"location":"400_Git.html#opret-repository-i-github","title":"Opret repository i GitHub","text":"<p>N\u00e5r f\u00f8rst et projekt er under Git source control kan du v\u00e6lge at synkronisere din kode med en cloud udbyder at Git. Der er mange at v\u00e6lge i mellem, men det nemmeste er klar at benytte GitHub da det er indbygget i VS (GitHub er ejet af Microsoft).</p> <p>F\u00f8rst skal du oprette en (gratis) konto hos GitHub, og s\u00f8rge for at din mailadresse er valideret inden du g\u00e5r videre. Herefter skal du logge ind i GitHub fra Visual Studio via Team Explorer-vinduets Sync-fane (se evt video). Herefter kan du oprette projektet i GitHub.</p>"},{"location":"400_Git.html#synkroniser-med-github","title":"Synkronis\u00e9r med GitHub","text":"<p>N\u00e5r du har gemt rettelser kan du finde dem under Sync (huset i toppen af vinduet og Sync-knappen), og det er ogs\u00e5 her du skal synkronisere med eksempelvis GitHub ved at klikke p\u00e5 Sync-linket i toppen af vinduet. Du kan ogs\u00e5 klikke p\u00e5 Push-linket men bem\u00e6rk, at eventuelle rettelser sket fra andre maskiner s\u00e5 ikke synkroniseres med dit lokale repository.</p>"},{"location":"400_Git.html#abn-et-nyt-projekt-direkte-fra-github","title":"\u00c5bn et nyt projekt direkte fra GitHub","text":"<p>Hvis du gerne vil oprette projekt baseret p\u00e5 et GutHub-projekt kan dette ogs\u00e5 g\u00f8res gennem Visual Studio. I det f\u00f8rste opstartsvindue, eller fra File-menuen i VS, kan du v\u00e6lge \u201cClone or check out code\u201d. Her kan du angive en git-url (den kan du finde under den store gr\u00f8nne knap p\u00e5 et repository i GitHub) og en lokal placering. S\u00e5 vil VS clone koden og \u00e5bne projektet. Husk at sikre dig, at Solution Explorer-vinduet er i \u201cSolution view\u201d (og ikke i \u201cFolder view\u201d). Se eventuelt video.</p>"},{"location":"410_IntroduktionWinForm.html","title":"WinForm intro","text":""},{"location":"410_IntroduktionWinForm.html#om-modulet","title":"Om modulet","text":"<p>I dette modul bliver du introduceret til udvikling af en brugerflade til Windows ved hj\u00e6lp af Microsofts gamle (men stadig benyttede) programmeringsmodel. Der er udelukkende tale om en introduktion for at f\u00e5 dig igang. Bem\u00e6rk at b\u00e5de WinForm og WPF (Windows Presentation Foundation) udelukkende er til Windows p\u00e5 trods af at de fra .NET Core 3.0 kan skabes udfra en .NET Core skabelon.</p>"},{"location":"410_IntroduktionWinForm.html#brugerflader-til-windows","title":"Brugerflader til Windows","text":"<p>I .NET er der to m\u00e5der at skabe en brugerflade til Windows</p> <ul> <li>WinForm</li> <li>WPF (Windows Presentation Foundation)</li> </ul> <p>WinForm er en gammel teknologi der bygger over p\u00e5 de indbyggede kontroller i Windows, og WPF er en nyere teknologi som er fri af Windows, og benytter opm\u00e6rkninger (XMAL) til at skabe brugerfladen. Begge teknologier er stadig benyttet og i princippet kan du v\u00e6lge frit. De kan begge benyttes under .NET Core (3.x), men der udvikles ikke p\u00e5 nogen af dem fra Microsoft side.</p>"},{"location":"410_IntroduktionWinForm.html#hvorfor-winform","title":"Hvorfor WinForm","text":"<ul> <li>Nemt og hurtigt</li> <li>Meget dokumentation og mange brugerflade kontroller at v\u00e6lge imellem</li> </ul>"},{"location":"410_IntroduktionWinForm.html#hvorfor-wpf","title":"Hvorfor WPF","text":"<ul> <li>Ikke afh\u00e6ngig af Windows kontroller og man kan dermed skabe alle typer af brugerflade elementer</li> <li>Brugen af XMAL</li> <li>Effektiv databinding</li> </ul>"},{"location":"410_IntroduktionWinForm.html#valg-af-ui","title":"Valg af UI","text":"<p>Hvis du er nybegynder vil jeg anbefale WinForm - det er nemt at komme igang med og der findes en masse information p\u00e5 nettet.</p>"},{"location":"410_IntroduktionWinForm.html#windows-forms-app","title":"Windows Forms App","text":"<p>Du kan oprette en ny WinForm applikation ved at s\u00f8ge efter WinForm eller v\u00e6lge \u201cC#\u201d, \u201cWindows\u201d og \u201cDesktop\u201d i dropdown-listerne.</p> <p>I skrivende stund (feb 2020) er WinForm og WPF designerne ikke fuldt integreret i .NET Core projekter i VS 2019. De er p\u00e5 vej (er i preview versionen af VS) men indtil da kan du bare benytte .NET Framework og ikke .NET Core.</p> <p></p> <p>N\u00e5r applikationen er oprettet kan du dobbeltklikke p\u00e5 \u201cForm1\u201d i Solution Explorer-vinduet for at aktivere designeren (hvis ikke den er det i forvejen), og finde Toolbox-vinduet p\u00e5 View-menuen. S\u00e5 kan du begynde at tr\u00e6kke kontroller som tekstbokse, knapper, lister med videre til formularen. Det sidste vigtige vinduet i WinForm-udvikling er Properties-vinduet, som typisk dukker op under Solution Explorer-vinduet n\u00e5r du har markeret en kontrol eller en formular i designeren.</p> <p></p>"},{"location":"410_IntroduktionWinForm.html#hndelser-og-egenskaber","title":"H\u00e6ndelser og egenskaber","text":"<p>En kontrol har en masse egenskaber (farve, st\u00f8rrelse, font mv) og en masse h\u00e6ndelser (click, keypress, drag mv), og begge kan findes i Properties-vinduet ved at klikke p\u00e5 ikoner for egenskaber og h\u00e6ndelser</p> <p></p>"},{"location":"410_IntroduktionWinForm.html#eksempel-pa-en-applikation","title":"Eksempel p\u00e5 en applikation","text":"<p>Den nemmeste m\u00e5de at forst\u00e5 WinForm er at se et kort eksempel p\u00e5 udvikling af en simpel applikation.</p>"},{"location":"420_IntroMonoGame.html","title":"MonoGame intro","text":""},{"location":"420_IntroMonoGame.html#om-modulet","title":"Om modulet","text":"<p>I dette modul bliver du introduceret til udvikling af simple spil med MonoGame. Modulet kr\u00e6ver en del viden om C# og er udelukkende men som inspiration. Der er s\u00e5ledes ingen video med udelukkende eksempelkode.</p>"},{"location":"420_IntroMonoGame.html#om-monogame","title":"Om MonoGame","text":"<p>MonoGame er en open source version af Microsofts gamle XNA framework. Det kan benyttes til udvikling af spil (og andre grafiktunge applikationer) til iOS, Android, MacOS, Linux, Windows, PS4, PSVita, Xbox One, og Switch.</p> <p>Du kan evt se et eksempel p\u00e5 konvertering af et \u201csimpelt\u201d TRex Game til MonoGame TRexGame. Der er ligeledes en (meget lang) tilh\u00f8rende Youtube serie.</p>"},{"location":"420_IntroMonoGame.html#installering-af-monogame-i-vs-2019","title":"Installering af MonoGame i VS 2019","text":"<p>Installering af MonoGame til udvikling af spil i VS 2019 sker ved hj\u00e6lp af en extension samt installering af et v\u00e6rkt\u00f8j til at h\u00e5ndtere eksterne ressource (Pipeline tool). Du kan f\u00f8lge vejledning fra MonoGame</p> <p>https://docs.monogame.net/articles/getting_started/0_getting_started.html</p> <p>F\u00f8lg \u201cSetting up your development environment\u201d og husk at VS skal genstartes efter installation af extensions.</p> <p>Du burde nu kunne skabe et \u201cMonoGame Cross Platform Desktop (OpenGL)\u201d projekt. Hvis du afvikler burde du se et tomt bl\u00e5 vindue som er dit \u201cl\u00e6rred\u201d til spillet.</p> <p></p>"},{"location":"420_IntroMonoGame.html#monogame-content-builder-tool","title":"MonoGame Content Builder Tool","text":"<p>Alle ressourcer (typisk billeder og lyde) skal kombileres til et for MonoGame kendt bin\u00e6rt format. Det sker gennem et \u201cMonoGame Content Builder Tool\u201d som kan startes fra Visual Studio. V\u00e6rkt\u00f8jet er installeret jf. ovenn\u00e6vnte men pr\u00f8v det lige jvf denne vejledning.</p> <p></p>"},{"location":"420_IntroMonoGame.html#brug-af-monogame-content-builder-tool","title":"Brug af MonoGame Content Builder Tool","text":"<p>Start med et nyt tomt \u201cMonoGame Cross Platform Desktop (OpenGL)\u201d projekt. Hent nu grafik fra OpenGameArt - Kenney\u2019s Simplified Platformer Pack, og pak alle ressourcer ud til en tom mappe. Tilf\u00f8j nu en enkelt png af en karakter til programmet jf video.</p>"},{"location":"420_IntroMonoGame.html#simpel-brug-af-game-klassen","title":"Simpel brug af Game-klassen","text":"<p>Et MonoGame spil er bygget op omkring klassen Game som blandt andet best\u00e5r af de virtuelle metoder</p> <ul> <li>Initialize<ul> <li>Initialiseringskode</li> </ul> </li> <li>LoadContent<ul> <li>oprettelse af sprites, lyde mv</li> </ul> </li> <li>Update<ul> <li>Kaldes l\u00f8bende af MonoGame og bruges blandt til at h\u00e5ndtere input fra tastatur</li> </ul> </li> <li>Draw<ul> <li>Kaldes l\u00f8bende af MonoGame og bruges til at tegne sprites</li> </ul> </li> </ul> <p>Her er et eksempel med tegning af en sprite og brug af pile tasterne. Eksemplet foruds\u00e6tter af platformChar_walk2.png er kompileret via MCBT v\u00e6rkt\u00f8jet jf. ovenfor. Foruds\u00e6tter ogs\u00e5 at projektet er oprettet som Game1 (ellers ret program.cs)</p> <pre><code>using Microsoft.Xna.Framework;\nusing Microsoft.Xna.Framework.Graphics;\nusing Microsoft.Xna.Framework.Input;\nnamespace Game1\n{\npublic class Game1 : Game\n{\n// felt til opbevaring af oplysning om grafik, sk\u00e6rm mv\nprivate GraphicsDeviceManager graphics;\n// felt til opbevaring af tegning af sprites mv\nprivate SpriteBatch spriteBatch;\n// felt til opbevaring af en sprite\nTexture2D character;\n// felt opbevaring af til position af sprite (x,y)\nVector2 position;\n// konstant til opbevaring af den hastighed sprite skal bev\u00e6ge sig\nconst float speed = 3;\npublic Game1()\n{\n// opret objekt til info om grafik\ngraphics = new GraphicsDeviceManager(this);\n// s\u00e6t mappe til sprites, lyde mv\nContent.RootDirectory = \"Content\";\n// vis mus\nIsMouseVisible = false;\n}\nprotected override void Initialize()\n{\nbase.Initialize();\n}\n// Bruges til at oprette sprites mv\nprotected override void LoadContent()\n{\n// Opret SpriteBatch til tegning mv\nspriteBatch = new SpriteBatch(GraphicsDevice);\n// Hent sprite fra Content (platformChar_walk2.png)\ncharacter = Content.Load&lt;Texture2D&gt;(\"platformChar_walk2\");\n// S\u00e6t position (f = float)\nposition = new Vector2(100f, 100f);\n}\n// Kaldes af MonoGame mange gange i sekundet\nprotected override void Update(GameTime gameTime)\n{\n// Luk program hvis...\nif (Keyboard.GetState().IsKeyDown(Keys.Escape))\nExit();\n// Find h\u00f8jde og bredde p\u00e5 vindue\nint width = graphics.PreferredBackBufferWidth;\nint height = graphics.PreferredBackBufferHeight;\n// Beregn en delta v\u00e6rdi for at tage hensyn til at\n// spil kan afvikles p\u00e5 maskiner med forskellige CPU kraft\n// gametime leveres af Update-metoden\nvar delta = 0.15f * (float)gameTime.ElapsedGameTime.TotalMilliseconds;\n// Hvis h\u00f8jrepil og position ikke er uden for vindue\nif (Keyboard.GetState().IsKeyDown(Keys.Right) &amp;&amp; position.X + character.Width &lt; width)\nposition.X += speed * delta;\n// Hvis venstrepil og position ikke er uden for vindue \nif (Keyboard.GetState().IsKeyDown(Keys.Left) &amp;&amp; position.X &gt; 0)\nposition.X -= speed * delta;\nbase.Update(gameTime);\n}\n// Kaldes af MonoGame mange gange i sekundet\nprotected override void Draw(GameTime gameTime)\n{\n// Baggrund\nGraphicsDevice.Clear(Color.CornflowerBlue);\n// Start tegning\nspriteBatch.Begin();\n// Tegn sprite (color = white = ingen farve)\nColor color = Color.White;\nspriteBatch.Draw(character, position, color);\n// Afslut tegning\nspriteBatch.End();            base.Draw(gameTime);\n}\n}\n}\n</code></pre>"},{"location":"420_IntroMonoGame.html#objektorienteret-tilgang","title":"Objektorienteret tilgang","text":"<p>Man kan v\u00e6lge at opdele de enkelte elementer i spillet i klasser og interface. Her er en keyboard manager-klasse, en sprite-klasse og et interface:</p> <pre><code>class KeyboardManager\n{\npublic event Action&lt;GameTime&gt; EscapedPressed;\npublic event Action&lt;GameTime&gt; LeftPressed;\npublic event Action&lt;GameTime&gt; RightPressed;\npublic void Check(KeyboardState keyboardState, GameTime gameTime) {\nif (keyboardState.IsKeyDown(Keys.Escape)) {\nEscapedPressed?.Invoke(gameTime);\n}\nif (keyboardState.IsKeyDown(Keys.Left))\n{\nLeftPressed?.Invoke(gameTime);\n}\nif (keyboardState.IsKeyDown(Keys.Right))\n{\nRightPressed?.Invoke(gameTime);\n}\n}\n}\ninterface ISprite\n{\nvoid Draw(GameTime gameTime, SpriteBatch spriteBatch);\nvoid Update(GameTime gameTime);\n}\nclass Character : ISprite\n{\nconst float speed = 3;\nColor drawColor = Color.White;\nconst string contentName = \"platformChar_walk2\";\nTexture2D sprite;\nVector2 position;\nprivate ContentManager content;\nprivate SpriteBatch spriteBatch;\nprivate GraphicsDeviceManager graphics;\nprivate KeyboardManager keyboardManager;\npublic Character(ContentManager content, SpriteBatch spriteBatch, GraphicsDeviceManager graphics, KeyboardManager keyboardManager)\n{\nposition = new Vector2 { X = 200, Y = 200 };\nthis.content = content;\nthis.spriteBatch = spriteBatch;\nsprite = content.Load&lt;Texture2D&gt;(contentName);\nthis.graphics = graphics;\nthis.keyboardManager = keyboardManager;\nkeyboardManager.LeftPressed += gameTime =&gt;\n{\nvar delta = 0.15f * (float)gameTime.ElapsedGameTime.TotalMilliseconds;\nif (position.X &gt; 0)\nposition.X -= speed * delta;\n};\nkeyboardManager.RightPressed += gameTime =&gt;\n{\nvar delta = 0.15f * (float)gameTime.ElapsedGameTime.TotalMilliseconds;\nif (position.X + sprite.Width &lt; graphics.PreferredBackBufferWidth)\nposition.X += speed * delta;\n};\n}\npublic void Update(GameTime gameTime)\n{\n}\npublic void Draw(GameTime gameTime, SpriteBatch spriteBatch)\n{\nspriteBatch.Draw(sprite, position, drawColor);\n}\n}\n</code></pre> <p>Nu kan Game-klasse begr\u00e6nses til mere generiske elemeenter og al logik flyttes til specifikke klasser:</p> <pre><code>public class Game1 : Game\n{\nprivate GraphicsDeviceManager graphics;\nprivate SpriteBatch spriteBatch;\nprivate Character character;\nprivate KeyboardManager keyboardManager;\npublic Game1()\n{\ngraphics = new GraphicsDeviceManager(this);\nContent.RootDirectory = \"Content\";\nIsMouseVisible = true;\nkeyboardManager = new KeyboardManager();\nkeyboardManager.EscapedPressed += (_) =&gt; { Exit(); };\n}\nprotected override void Initialize()\n{\nbase.Initialize();\n}\nprotected override void LoadContent()\n{\nspriteBatch = new SpriteBatch(GraphicsDevice);\ncharacter = new Character(Content, spriteBatch, graphics, keyboardManager);            }\nprotected override void Update(GameTime gameTime)\n{\nkeyboardManager.Check(Keyboard.GetState(), gameTime);\ncharacter.Update(gameTime);\nbase.Update(gameTime);\n}\nprotected override void Draw(GameTime gameTime)\n{\nGraphicsDevice.Clear(Color.CornflowerBlue);\nspriteBatch.Begin();\ncharacter.Draw(gameTime, spriteBatch);\nspriteBatch.End();\nbase.Draw(gameTime);\n}\n}\n</code></pre>"},{"location":"420_IntroMonoGame.html#simpel-animation","title":"Simpel animation","text":"<p>Animation kan foretages ved at opdele sprites i frames og vise disse med et givet interval. Med udgangspunkt i platformer pack er her et simpelt eksempel (inspireret af MonoGame TRexGame):</p> <pre><code>public class Sprite\n{\npublic Texture2D Texture { get; set; }\npublic Color TintColor { get; set; } = Color.White;\npublic Sprite(Texture2D texture)\n{\nTexture = texture;\n}\npublic void Draw(SpriteBatch spriteBatch, Vector2 position)\n{\nspriteBatch.Draw(Texture, position, TintColor);\n}\n}\npublic class SpriteAnimationFrame\n{\nprivate Sprite _sprite;\npublic Sprite Sprite {\nget\n{\nreturn _sprite;\n}\nset\n{\nif (value == null)\nthrow new ArgumentNullException(\"value\", \"The sprite cannot be null.\");\n_sprite = value;\n}\n}\npublic float TimeStamp { get; }\npublic SpriteAnimationFrame(Sprite sprite, float timeStamp)\n{\nSprite = sprite;\nTimeStamp = timeStamp;\n}\n}\npublic class SpriteAnimation\n{\nprivate List&lt;SpriteAnimationFrame&gt; _frames = new List&lt;SpriteAnimationFrame&gt;();\npublic SpriteAnimationFrame this[int index]\n{\nget\n{\nreturn GetFrame(index);\n}\n}\npublic int FrameCount =&gt; _frames.Count;\npublic SpriteAnimationFrame CurrentFrame\n{\nget\n{\nreturn _frames\n.Where(f =&gt; f.TimeStamp &lt;= PlaybackProgress + 0.0005f)\n.OrderBy(f =&gt; f.TimeStamp)\n.LastOrDefault();\n}\n}\npublic float Duration\n{\nget\n{\nif (!_frames.Any())\nreturn 0;\nreturn _frames.Max(f =&gt; f.TimeStamp);\n}\n}\npublic bool IsPlaying { get; private set; }\npublic float PlaybackProgress { get; private set; }\npublic bool ShouldLoop { get; set; } = true;\npublic void AddFrame(Sprite sprite, float timeStamp)\n{\nSpriteAnimationFrame frame = new SpriteAnimationFrame(sprite, timeStamp);\n_frames.Add(frame);\n}\npublic void Update(GameTime gameTime)\n{\nif(IsPlaying)\n{\nPlaybackProgress += (float)gameTime.ElapsedGameTime.TotalSeconds;                if (PlaybackProgress &gt; Duration)\n{\nif (ShouldLoop)\nPlaybackProgress -= Duration;\nelse\nStop();\n}\n}\n}\npublic void Draw(SpriteBatch spriteBatch, Vector2 position)\n{\nSpriteAnimationFrame frame = CurrentFrame;\nif (frame != null)\nframe.Sprite.Draw(spriteBatch, position);\n}\npublic void Play()\n{\nIsPlaying = true;\n}\npublic void Stop()\n{\nIsPlaying = false;\nPlaybackProgress = 0;\n}\npublic SpriteAnimationFrame GetFrame(int index)\n{\nif (index &lt; 0 || index &gt;= _frames.Count)\nthrow new ArgumentOutOfRangeException(nameof(index), \"A frame with index \" + index + \" does not exist in this animation.\");\nreturn _frames[index];\n}\npublic void Clear()\n{\nStop();\n_frames.Clear();\n}\npublic static SpriteAnimation CreateAnimation(float frameLength, params Texture2D[] texture)\n{\nSpriteAnimation anim = new SpriteAnimation();\nfor (int i = 0; i &lt; texture.Length; i++)\n{\nSprite s = new Sprite(texture[i]);\nanim.AddFrame(s, frameLength * i);\n}\nSprite sprite = new Sprite(texture[0]);\nanim.AddFrame(sprite, frameLength * texture.Length);\nreturn anim;\n}\n}\n</code></pre> <p>og her brugen af klasserne (tilret evt Game1):</p> <pre><code>public class Game1 : Game\n{\nprivate GraphicsDeviceManager graphics;\nprivate SpriteBatch spriteBatch;\nSpriteAnimation sa;\npublic Game1()\n{\ngraphics = new GraphicsDeviceManager(this);\nContent.RootDirectory = \"Content\";\nIsMouseVisible = true;\n}\nprotected override void Initialize()\n{\n// TODO: Add your initialization logic here\nbase.Initialize();\n}\nprotected override void LoadContent()\n{\nspriteBatch = new SpriteBatch(GraphicsDevice);\nvar pos1 = Content.Load&lt;Texture2D&gt;(\"platformChar_walk1\");\nvar pos2 = Content.Load&lt;Texture2D&gt;(\"platformChar_walk2\");\nsa = SpriteAnimation.CreateAnimation(0.5f, pos1, pos2);\n}\nprotected override void Update(GameTime gameTime)\n{\nif (GamePad.GetState(PlayerIndex.One).Buttons.Back == ButtonState.Pressed || Keyboard.GetState().IsKeyDown(Keys.Escape))\nExit();\nsa.Play();\nsa.Update(gameTime);\nbase.Update(gameTime);\n}\nprotected override void Draw(GameTime gameTime)\n{\nGraphicsDevice.Clear(Color.CornflowerBlue);\nspriteBatch.Begin();\nsa.Draw(spriteBatch, new Vector2 { X = 200, Y = 200 });\nspriteBatch.End();\nbase.Draw(gameTime);\n}\n}\n</code></pre>"},{"location":"500_EkstraOpgaver.html","title":"Ekstra opgaver","text":""},{"location":"500_EkstraOpgaver.html#opgaver-pa-github","title":"Opgaver p\u00e5 GitHub","text":"<p>Jeg har nogle ekstra opgaver p\u00e5 GitHub hvis du vil \u00f8ve dig lidt mere. De er lidt l\u00e6ngere og mere omfattende men ikke n\u00f8dvendigvis sv\u00e6rere.</p>"},{"location":"500_EkstraOpgaver.html#vendespil","title":"Vendespil","text":"<p>En nogenlunde simpel men meget sjov opgave hvor du skal skabe et vendespil (hukommelsesspil) p\u00e5 konsol.</p> <p>Info</p>"},{"location":"500_EkstraOpgaver.html#opgave-500-1","title":"Opgave 500-1","text":"<p>Komplet Vendespil-spil til afvikling p\u00e5 consol (kode til s\u00f8gning: FAAB)</p> <p>Se opgave</p>"},{"location":"500_EkstraOpgaver.html#yatzy","title":"Yatzy","text":"<p>En omfattende opgave hvor du skal skabe et komplet Yatzy-spil.</p> <p>Info</p>"},{"location":"500_EkstraOpgaver.html#opgave-500-2","title":"Opgave 500-2","text":"<p>Komplet Yatzy-spil - med eller uden bot. (kode til s\u00f8gning: FAAC)</p> <p>Se opgave</p>"},{"location":"500_EkstraOpgaver.html#propertychanged","title":"PropertyChanged","text":"<p>Simpel opgave i brugen af h\u00e6ndelser/delegates, som samtidig kan bruges som inspiration ved design af klasser. </p> <p>Info</p>"},{"location":"500_EkstraOpgaver.html#opgave-500-3","title":"Opgave 500-3","text":"<p>Lidt mere omfattende opgave i brugen h\u00e6ndelser og delegates, samt brug af INotifyPropertyChanged. (kode til s\u00f8gning: FAAD)</p> <p>Se opgave</p>"},{"location":"500_EkstraOpgaver.html#hgtet-liste","title":"H\u00e6gtet liste","text":"<p>Info</p>"},{"location":"500_EkstraOpgaver.html#opgave-500-4","title":"Opgave 500-4","text":"<p>Skab din helt egen h\u00e6gtede liste. (kode til s\u00f8gning: FAAE)</p> <p>Se opgave</p>"},{"location":"500_EkstraOpgaver.html#polymorfi","title":"Polymorfi","text":"<p>Info</p>"},{"location":"500_EkstraOpgaver.html#opgave-500-5","title":"Opgave 500-5","text":"<p>Simpel opgave i objektorienteret design. (kode til s\u00f8gning: FAAF)</p> <p>Se opgave</p>"},{"location":"links.html","title":"Links fra kurset","text":"<p>Diverse links relateret til kurset (genereret 01-03-2023)</p>"},{"location":"links.html#cs","title":"cs","text":"<ul> <li>OpenAI API</li> <li>Polyglot Notebooks </li> <li>SharpLab</li> <li>Run C# scripts from the .NET CLI.</li> <li>C# docs</li> </ul>"},{"location":"links.html#ai","title":"ai","text":"<ul> <li>Chat GPT</li> <li>OpenAI API</li> <li>Playground AI</li> <li>How To Rank First Page Google With ChatGPT SEO Extension (New Strategy 2023) - YouTube</li> <li>MidJourney AI - Getting started</li> <li>Awesome chatgpt</li> <li>Awesome AI</li> <li>Demo Stable Diffusion Online </li> <li>16 Best Free AI Art Generators</li> </ul>"},{"location":"links.html#visual-studio","title":"visual studio","text":"<ul> <li>Visual Studio IDE </li> <li>VS Extension: ReSharper</li> <li>VS Extension: CodeMaid </li> <li>VS Extension: Add New File (64-bit)</li> <li>VS Extension: Simple editorconfig</li> </ul>"},{"location":"links.html#visual-studio-code","title":"visual studio code","text":"<ul> <li>Polyglot Notebooks </li> <li>Visual Studio Code </li> <li>Emmet cheatsheet</li> </ul>"},{"location":"links.html#includeurlfalse","title":"includeurl=false","text":""},{"location":"opgaver.html","title":"Opgaver","text":"<p>F\u00f8lgende 110 opgaver er tilg\u00e6ngelige</p>"},{"location":"opgaver.html#introduktion-til-visual-studio","title":"Introduktion til Visual Studio","text":"<ul> <li> <p>25-1 Leg med VS og C#</p> <ul> <li>Simpel \u2018pr\u00f8v det selv\u2019/\u2019kom i gang\u2019 opgave</li> </ul> </li> <li> <p>25-2 Debugging</p> <ul> <li>Opgave i simpel debugging</li> </ul> </li> </ul>"},{"location":"opgaver.html#en-konsol-applikation","title":"En konsol applikation","text":"<ul> <li> <p>30-1 Brug af pakken CommandLineParser</p> <ul> <li>Opgave i h\u00e5ndtering af parametre fra kommandoprompt</li> </ul> </li> </ul>"},{"location":"opgaver.html#simple-variabler","title":"Simple variabler","text":"<ul> <li> <p>40-1 Brug af variabler (tal)</p> <ul> <li>Simpel brug af forskellige tal og operatorer (l\u00f8sning med video)</li> </ul> </li> <li> <p>40-2 Brug af DateTime og TimeSpan</p> <ul> <li>Opret og beregn p\u00e5 b\u00e5de DateTime og TimeSpan-variabler</li> </ul> </li> <li> <p>40-3 Regnemaskine (typekonvertering)</p> <ul> <li>Brug af System.Convert samt ToString/Formatering (l\u00f8sning med video)</li> </ul> </li> </ul>"},{"location":"opgaver.html#tegn-og-tekster","title":"Tegn og tekster","text":"<ul> <li> <p>45-1 Brug af strenge</p> <ul> <li>Simpel opgave i brug af strenge</li> </ul> </li> </ul>"},{"location":"opgaver.html#konstanter","title":"Konstanter","text":"<ul> <li> <p>48-1 Brug af enum</p> <ul> <li>Brug en enum til at definere kul\u00f8r p\u00e5 et spillekort.</li> </ul> </li> </ul>"},{"location":"opgaver.html#programflow","title":"Programflow","text":"<ul> <li> <p>50-1 Simpel brug af for og if</p> <ul> <li>Leg lidt med et par for-l\u00f8kker og en if-struktur</li> </ul> </li> <li> <p>50-2 Brug af for og if</p> <ul> <li>Brug et par for-l\u00f8kker og en if-struktur til at skabe en 10-tabel</li> </ul> </li> <li> <p>50-3 Leg med break og continue</p> <ul> <li>En lille opgave s\u00e5 du kan lege lidt med break og continue.</li> </ul> </li> </ul>"},{"location":"opgaver.html#metoder","title":"Metoder","text":"<ul> <li> <p>60-1 Brug af simple metoder</p> <ul> <li>Brug af simple metoder</li> </ul> </li> <li> <p>60-2 Metode der returnerer en nullable</p> <ul> <li>Skab en metode der returnerer en nullable v\u00e6rdi</li> </ul> </li> <li> <p>60-3 Statiske metoder</p> <ul> <li>Brug af statiske metoder</li> </ul> </li> <li> <p>60-4 Overload</p> <ul> <li>Brug af overloaede metoder</li> </ul> </li> <li> <p>60-5 Rekursive metoder</p> <ul> <li>Udvikling af en simpel rekursiv metode.</li> </ul> </li> <li> <p>60-6 Rekursive metoder (avanceret)</p> <ul> <li>Udvikling af en rekursiv metode til at finde undermapper og filer.</li> </ul> </li> <li> <p>60-7 Extension</p> <ul> <li>Skab en extension-metode til System.String</li> </ul> </li> </ul>"},{"location":"opgaver.html#fejlhandtering","title":"Fejlh\u00e5ndtering","text":"<ul> <li> <p>65-1 Simpel fejlh\u00e5ndtering</p> <ul> <li>Brug af try/catch (med video af l\u00f8sning)</li> </ul> </li> <li> <p>65-2 Egne exceptions</p> <ul> <li>Brug ApplicationException til at kaste en fejl ved forkert kald til en metode</li> </ul> </li> <li> <p>65-3 Egne exceptions</p> <ul> <li>Noget mere kompleks opgave i brugen af flere catch-blokke, samt brug af ApplicationException.</li> </ul> </li> </ul>"},{"location":"opgaver.html#arrays","title":"Arrays","text":"<ul> <li> <p>70-1 Simpelt array</p> <ul> <li>Simpel opgave i brugen af et array</li> </ul> </li> <li> <p>70-2 To-dimensionelt array</p> <ul> <li>Opgave som benytter et to dimensionelt array og en tilh\u00f8rende metode</li> </ul> </li> <li> <p>70-3 Brug af Split</p> <ul> <li>Brug af Split-metoden til at skabe et array</li> </ul> </li> </ul>"},{"location":"opgaver.html#samlinger","title":"Samlinger","text":"<ul> <li> <p>75-1 Brug af list, stack og dictionary</p> <ul> <li>Simpel opgave i brugen af forskellige collections</li> </ul> </li> <li> <p>75-2 Brug af en stack</p> <ul> <li>Dan en bunke af kort ved hj\u00e6lp af en Stack&lt;&gt;</li> </ul> </li> <li> <p>75-3 IEnumable og IComparable</p> <ul> <li>Brug af IEnumable og IComparable til at skabe en garage med biler</li> </ul> </li> <li> <p>75-4 yield return</p> <ul> <li>Brug af yield return til at skabe Fibonacci-numre</li> </ul> </li> </ul>"},{"location":"opgaver.html#klasser","title":"Klasser","text":"<ul> <li> <p>80-1 Singleton-m\u00f8nsteret</p> <ul> <li>Avanceret opgave der viser singleton-m\u00f8nsteret</li> </ul> </li> <li> <p>80-2 Klasse der repr\u00e6senterer en simpel terning</p> <ul> <li>Simpel klasse der repr\u00e6senterer en terning</li> </ul> </li> <li> <p>80-3 Klasse der repr\u00e6senterer en terning med snyd</p> <ul> <li>Lidt avanceret klasse til at repr\u00e6sentere en terning</li> </ul> </li> <li> <p>80-4 Klasse der repr\u00e6senterer et b\u00e6ger af terninger</p> <ul> <li>For at spille Yatzy skal vi bruge et b\u00e6ger - en m\u00e5de at skabe et b\u00e6ger er at benytte et array.</li> </ul> </li> <li> <p>80-5 Oprettelse og brug af en simpel klasse</p> <ul> <li>Lille opgave i erkl\u00e6ring og brug af en klasse og constructor</li> </ul> </li> <li> <p>80-6 Konto med tilh\u00f8rende transaktioner</p> <ul> <li>Skab en Konto-klasser der inderholder en liste af transaktioner. Her er der is\u00e6r fokus p\u00e5 (manglende) sikkerhed.</li> </ul> </li> <li> <p>80-7 Statiske metoder</p> <ul> <li>Definition af en klasse med statiske metoder</li> </ul> </li> </ul>"},{"location":"opgaver.html#stukturer","title":"Stukturer","text":"<ul> <li> <p>82-1 Brug af struct</p> <ul> <li>Brug af en struct til at repr\u00e6sentere en vare i et ERP system</li> </ul> </li> <li> <p>82-2 Brug af struct og en enum</p> <ul> <li>Brug af en struct og en enum til at repr\u00e6sentere et spillekort</li> </ul> </li> </ul>"},{"location":"opgaver.html#hukommelsesteori","title":"Hukommelsesteori","text":"<ul> <li> <p>87-1 Forskel p\u00e5 struct og class</p> <ul> <li>Den helt grundl\u00e6ggende opgave i hukommelsesteori - den SKAL du forst\u00e5 ;)</li> </ul> </li> <li> <p>87-2 Visualiser stack/heap</p> <ul> <li>Med udgangspunkt i en terning og et b\u00e6ger skal du visualisere stack/heap</li> </ul> </li> </ul>"},{"location":"opgaver.html#indkapsling","title":"Indkapsling","text":"<ul> <li> <p>90-1 Terning med egenskaber</p> <ul> <li>En mere komplet terning der benytter egenskaber</li> </ul> </li> <li> <p>90-2 Komplete egenskaber</p> <ul> <li>Simpel opgave i brugen af komplete egenskaber</li> </ul> </li> <li> <p>90-3 Hvorfor sker der en fejl?</p> <ul> <li>Simpel klasse med en simpel egenskab men med en heftig fejl - find den!!</li> </ul> </li> <li> <p>90-4 Brug af automatiske egenskaber</p> <ul> <li>Kom godt i gang med automatiserede egenskaber</li> </ul> </li> <li> <p>90-5 En Terning med automatiske egenskaber</p> <ul> <li>Benyt automatiske (get only) egenskaber til en Terning</li> </ul> </li> <li> <p>90-6 Get-egenskab eller en metode?</p> <ul> <li>Opgave i brug af en Get-egenskab som alternativ til en metode</li> </ul> </li> <li> <p>90-7 Immutable klasse</p> <ul> <li>Opgave i brug immutable datatyper (samt c# 9 records)</li> </ul> </li> <li> <p>90-8 Serialisering/Deserialiering</p> <ul> <li>Opgave der leger lidt med serialisering</li> </ul> </li> </ul>"},{"location":"opgaver.html#nedarvning","title":"Nedarvning","text":"<ul> <li> <p>100-1 Simpel arv</p> <ul> <li>Simpel opgave i brugen af arv (persontyper)</li> </ul> </li> <li> <p>100-2 Udvidelse af eksisterende framework klasser</p> <ul> <li>Opgave der viser at man ogs\u00e5 kan arve fra framework-klasser</li> </ul> </li> <li> <p>100-3 Egne exceptions</p> <ul> <li>Udvikling af egne exception-klasser ved hj\u00e6lp af arv</li> </ul> </li> <li> <p>100-4 Lidt st\u00f8rre opgave i arv (terning)</p> <ul> <li>Skab en terning (mor) og en ludoterning (barn) som man ikke kan arve yderligere fra</li> </ul> </li> </ul>"},{"location":"opgaver.html#polymorfi","title":"Polymorfi","text":"<ul> <li> <p>105-1 Simpel opgave i polymorfi (ToString fra Object)</p> <ul> <li>Overskrivning af ToString</li> </ul> </li> <li> <p>105-2 Terning med polymorfi</p> <ul> <li>Brug af polymorfi med terninger og ludoterninger</li> </ul> </li> <li> <p>105-3 Abstrakt klasse</p> <ul> <li>Udvikling og brug af en abstrakt Person-klasse</li> </ul> </li> <li> <p>105-4 Lidt mere kompleks opgave i polymorfi</p> <ul> <li>Brug af polymorfi i en samling af dyr</li> </ul> </li> </ul>"},{"location":"opgaver.html#interface","title":"Interface","text":"<ul> <li> <p>110-1 Eget interface</p> <ul> <li>Udvikling af egne interfaces og tilh\u00f8rende polymorfi</li> </ul> </li> <li> <p>110-2 Brug af IComparable&lt;&gt;</p> <ul> <li>Brug af IComparable&lt;&gt; i forbindelse med sortering</li> </ul> </li> <li> <p>110-3 Dependency Injection (DI)</p> <ul> <li>Avanceret opgave i brug af interfaces til afkobling</li> </ul> </li> </ul>"},{"location":"opgaver.html#delegates","title":"Delegates","text":"<ul> <li> <p>120-1 Simpel opgave i delegates</p> <ul> <li>En opgave der omhandler brugen af delegates - b\u00e5de med og uden sukker.</li> </ul> </li> <li> <p>120-2 Simpel regnemaskine (r\u00e5 delegates)</p> <ul> <li>Brug af r\u00e5 delegates til at skabe en regnemaskine</li> </ul> </li> <li> <p>120-3 Log</p> <ul> <li>Brug af delegates til log-funktionalitet</li> </ul> </li> <li> <p>120-4 Log</p> <ul> <li>Brug af delegates til log-funktionalitet (indbyggede delegates)</li> </ul> </li> <li> <p>120-5 Simpel regnemaskine (indbyggede delegates)</p> <ul> <li>Brug af Func til at skabe en regnemaskine</li> </ul> </li> <li> <p>120-6 Predicate til en liste af tal</p> <ul> <li>Brug af en predicate til Array-funktioner</li> </ul> </li> <li> <p>120-7 Brug af en Predicate (avanceret)</p> <ul> <li>Brug af en Predicate til en filtreringsmetode</li> </ul> </li> <li> <p>120-8 Brug af lambda</p> <ul> <li>Brug af delegates og lambda-metoder til at arbejde p\u00e5 et array af heltal.</li> </ul> </li> <li> <p>120-9 Simpel regnemaskine (lambda)</p> <ul> <li>Brug af Func til at skabe en regnemaskine</li> </ul> </li> </ul>"},{"location":"opgaver.html#hndelser","title":"H\u00e6ndelser","text":"<ul> <li> <p>125-1 Brug af FileSystemWatcher</p> <ul> <li>\u00d8v dig p\u00e5 brug af events med FileSystemWatcher.</li> </ul> </li> <li> <p>125-2 Kreditmax</p> <ul> <li>Skab din egen h\u00e6ndelse.</li> </ul> </li> <li> <p>125-3 Kreditmax med egen h\u00e6ndelse</p> <ul> <li>Skab en h\u00e6ndelse med egen eventargs</li> </ul> </li> </ul>"},{"location":"opgaver.html#avancerede-typer","title":"Avancerede typer","text":"<ul> <li> <p>126-1 Record</p> <ul> <li>Brug af en record (class)</li> </ul> </li> <li> <p>126-2 Metode der returnerer en nullable</p> <ul> <li>Skab simple metoder/typer der benytter nullable variabler</li> </ul> </li> <li> <p>126-3 Metode der returnerer en Tuple</p> <ul> <li>Skab en metoder der returnerer flere v\u00e6rdier uden en type definition.</li> </ul> </li> <li> <p>126-4 Brug af using</p> <ul> <li>\u00d8v dig p\u00e5 Dispose-m\u00f8nsteret</li> </ul> </li> <li> <p>126-5 Brug af anonyme typer</p> <ul> <li>Leg med b\u00e5de anonyme objekter og Expando-klassen</li> </ul> </li> </ul>"},{"location":"opgaver.html#operator-overload","title":"Operator overload","text":"<ul> <li> <p>128-1 Simpel brug af operator overload</p> <ul> <li>Brug operator overload til at finde ud af om en hund &gt; end en anden hund</li> </ul> </li> <li> <p>128-2 Dan din egen datatype</p> <ul> <li>Tilf\u00f8j en ny datatype (Nibble) til C# og overload operatorer</li> </ul> </li> </ul>"},{"location":"opgaver.html#generiske-typer-og-medlemmer","title":"Generiske typer og medlemmer","text":"<ul> <li> <p>130-1 Brug af en generisk metode (simpel)</p> <ul> <li>Simpel brug af en generisk metode</li> </ul> </li> <li> <p>130-2 Udvikling af en generisk metode</p> <ul> <li>Skab en generisk metode der kan benytte af typer der implementerer IComparable</li> </ul> </li> <li> <p>130-3 Generisk klasse</p> <ul> <li>Skab din egen generiske klasse</li> </ul> </li> <li> <p>130-4 Generisk terning</p> <ul> <li>Skab et generisk b\u00e6ger til terninger</li> </ul> </li> </ul>"},{"location":"opgaver.html#linq-to-objects","title":"LINQ to Objects","text":"<ul> <li> <p>150-1 LINQ med tal</p> <ul> <li>Brug LINQ mod et simpelt int-array</li> </ul> </li> <li> <p>150-2 LINQ med objekter</p> <ul> <li>Brug LINQ mod en simpel liste af objekter</li> </ul> </li> <li> <p>150-3 Yatzy-LINQ</p> <ul> <li>Brug af (eksempelvis) LINQ til at finde point til Yatzy - ST\u00d8RRE OPGAVE</li> </ul> </li> <li> <p>150-4 Leg med LINQ</p> <ul> <li>Brug en liste af personer til at lege med LINQ</li> </ul> </li> <li> <p>150-5 Udvidelse af LINQ</p> <ul> <li>Brug af extension metoder til at udvide og forbedre LINQ to objects</li> </ul> </li> </ul>"},{"location":"opgaver.html#asynkron-programmering","title":"Asynkron programmering","text":"<ul> <li> <p>155-1 Forst\u00e5 async/await</p> <ul> <li>Forst\u00e5 brugen af async/await ved at \u2018beregne primtal\u2019.</li> </ul> </li> <li> <p>155-2 Simpel opgave i async/await</p> <ul> <li>Hent et tilf\u00e6ldigt tal fra random.org og gem det i en fil - asynkront</li> </ul> </li> <li> <p>155-3 Opgave i async/await - med serialisering</p> <ul> <li>Brug async/await til at hente tilf\u00e6ldige brugere fra filltext.com</li> </ul> </li> <li> <p>155-4 Brug af Task.WhenAll</p> <ul> <li>Hent HTML og gem i tre forskellige filer</li> </ul> </li> <li> <p>155-5 Skab en metode der gemmer en fil asynkront</p> <ul> <li>\u00d8v dig p\u00e5 brug af Task og async/await gennem IO-operationer.</li> </ul> </li> <li> <p>155-6 Hent en samling tilf\u00e6ldige tal fra nettet asynkront</p> <ul> <li>Her kan du \u00f8ve dig lidt p\u00e5 at skabe metoder der returnerer en Task</li> </ul> </li> </ul>"},{"location":"opgaver.html#kommunikation-med-xml","title":"Kommunikation med XML","text":"<ul> <li> <p>160-1 Leg med LINQ2XML</p> <ul> <li>Simpel LINQ2XML opgave</li> </ul> </li> </ul>"},{"location":"opgaver.html#kommunikation-med-filer","title":"Kommunikation med filer","text":"<ul> <li> <p>165-1 Brug af statiske IO metoder</p> <ul> <li>Brug af File og Directory-klasserne</li> </ul> </li> <li> <p>165-2 Brug af IO typer</p> <ul> <li>Brug af FileInfo og DirectoryInfo-klasserne</li> </ul> </li> <li> <p>165-3 Brug af IO streaming</p> <ul> <li>Brug af StreamWriter til at gemme en stor tekstfil</li> </ul> </li> </ul>"},{"location":"opgaver.html#kommunikation-over-http","title":"Kommunikation over HTTP","text":"<ul> <li> <p>167-1 Brug af HttpClient og WebApi til JSON data</p> <ul> <li>Hent og vis samtlige kommuner i Danmark fra DAWA</li> </ul> </li> </ul>"},{"location":"opgaver.html#kommunikation-med-databaser","title":"Kommunikation med databaser","text":"<ul> <li> <p>168-1 Connected data</p> <ul> <li>Brug SQLLite til at lege med DataConnection, DataCommand mv</li> </ul> </li> <li> <p>168-2 Disconnected data</p> <ul> <li>Brug SQLLite til at lege med DataAdapter og DataTable mv</li> </ul> </li> <li> <p>168-3 CSV</p> <ul> <li>Leg med manuel og automatisk serialisering af CSV filer</li> </ul> </li> <li> <p>168-4 Skab et Excel-ark</p> <ul> <li>Skab et Excel-ark med ClosedXml</li> </ul> </li> </ul>"},{"location":"opgaver.html#expression-trees","title":"Expression trees","text":"<ul> <li> <p>169-1 Repository med expressions</p> <ul> <li>Brug af expressions til at skabe et repository med LINQ where/orderby muligheder</li> </ul> </li> </ul>"},{"location":"opgaver.html#brug-af-konfigurationsfiler","title":"Brug af konfigurationsfiler","text":"<ul> <li> <p>170-1 Brug af en typest\u00e6rk konfigurationsfil</p> <ul> <li>Opgave i brug af en typest\u00e6rk appsettings.json konfigurationsfil</li> </ul> </li> </ul>"},{"location":"opgaver.html#reflection","title":"Reflection","text":"<ul> <li> <p>200-1 Simpel brug af indbyggede attributter</p> <ul> <li>Brug et par simple attributter (Obsolete og Conditional)</li> </ul> </li> <li> <p>200-2 Brug af CallerMemberName</p> <ul> <li>Skab en klasse der implementerer INotifyPropertyChanged</li> </ul> </li> </ul>"},{"location":"opgaver.html#ekstra-opgaver","title":"Ekstra opgaver","text":"<ul> <li> <p>500-1 Vendespil</p> <ul> <li>Komplet Vendespil-spil til afvikling p\u00e5 consol</li> </ul> </li> <li> <p>500-2 CSYatzy</p> <ul> <li>Komplet Yatzy-spil - med eller uden bot.</li> </ul> </li> <li> <p>500-3 PropertyChanged</p> <ul> <li>Lidt mere omfattende opgave i brugen h\u00e6ndelser og delegates, samt brug af INotifyPropertyChanged.</li> </ul> </li> <li> <p>500-4 H\u00e6gtet liste</p> <ul> <li>Skab din helt egen h\u00e6gtede liste.</li> </ul> </li> <li> <p>500-5 Polymorfi</p> <ul> <li>Simpel opgave i objektorienteret design.</li> </ul> </li> </ul>"},{"location":"Certificering/basiccert.html","title":"C# certificering","text":"<p>En C# certificering er en god m\u00e5de at bevise dine f\u00e6rdigheder og viden inden for programmeringssproget C# og tilh\u00f8rende emner. Denne certificering er designet til at bevise, at du har en grundig forst\u00e5else af C#, og vil \u00f8ge din trov\u00e6rdighed og forbedre dine karrieremuligheder inden for softwareudvikling.</p> <p>For at opn\u00e5 certificeringen skal du gennemf\u00f8re et hjemmeprojekt inden for en uge, som vil blive bed\u00f8mt af en instrukt\u00f8r. Efterf\u00f8lgende vil du deltage i et m\u00f8de med instrukt\u00f8ren (fysisk eller online), hvor du vil blive bedt om at forklare hvordan din l\u00f8sning er opbygget samt besvare nogle teoretiske sp\u00f8rgsm\u00e5l. Vurderingen af b\u00e5de dit projekt og dine teoretiske svar vil danne grundlaget for den endelige bed\u00f8mmelse.</p> <p>N\u00e5r du har opn\u00e5et certificeringen, vil du modtage et konkret certifikat, som dokumenterer dine f\u00e6rdigheder og viden i C# og tilh\u00f8rende emner. Desuden vil du f\u00e5 adgang til en detaljeret beskrivelse af certificeringens omfang, s\u00e5 du og din arbejdsgiver kan f\u00e5 et klart billede af de f\u00e6rdigheder og kompetencer, du har opn\u00e5et.</p> <p>Denne certificering vil v\u00e6re en v\u00e6rdifuld tilf\u00f8jelse til dit CV og kan hj\u00e6lpe dig med at skille dig ud fra andre softwareudviklere i en konkurrencepr\u00e6get branche. </p> <p>F\u00f8lgende emner er d\u00e6kket af certificeringen (klik p\u00e5 emner for en yderligere uddybning):</p> Grundl\u00e6ggende forst\u00e5else for .NET runtime <ul> <li>Forskellen p\u00e5 .NET Framework, .NET Core og .NET</li> <li>De forskellige komponenter i .NET Runtime<ul> <li>CLR</li> <li>BCL</li> <li>Grundl\u00e6ggende brug af .NET CLI</li> </ul> </li> <li>Forskellen p\u00e5 C#, IL og Assembler</li> <li>Grundl\u00e6ggende forst\u00e5else for NuGet</li> </ul> Strukturen p\u00e5 en C# l\u00f8sning og tilh\u00f8rende projekt(er) <ul> <li>Strukturen p\u00e5 en konsol applikation i C#</li> <li>Brug af eksterne klassebiblioteker<ul> <li>Separate projekter med reference</li> <li>NuGet pakker</li> </ul> </li> </ul> Grundl\u00e6ggende forst\u00e5else for brug af Visual Studio eller Visual Studio Code <ul> <li>Grundl\u00e6ggende brug af debugger</li> </ul> Brug af typer og variabler <ul> <li>Viden om de mest benyttede typer i .NET<ul> <li>int, double, bool, DateTime, TimeSpan, String, Char</li> <li>C# operatorer    </li> </ul> </li> <li>Erkl\u00e6ring og tildeling</li> <li>Typekonvertering </li> <li>Konstanter<ul> <li>Enums</li> </ul> </li> <li>Forskellen p\u00e5 v\u00e6rdibaserede og referencebaserede typer<ul> <li>Stack og heap</li> </ul> </li> <li>Forskellen p\u00e5 mutable og immutable typer</li> <li>Grundl\u00e6ggende forst\u00e5else af forskellen p\u00e5 class og struct</li> </ul> Programflow i C# <ul> <li>if, switch, for, do/while</li> <li>continue/break</li> <li>goto</li> </ul> Definering af klasser og strukturer <ul> <li>Medlemstyper<ul> <li>Felter</li> <li>Egenskaber</li> <li>Metoder<ul> <li>Lambda</li> </ul> </li> <li>H\u00e6ndelser</li> <li>Konstrukt\u00f8rer</li> </ul> </li> <li>Tilgang til medlemmer</li> <li>Forskellen p\u00e5 instans og statiske medlemmer</li> <li>Records</li> <li>Tuples</li> <li>Nullable typer</li> </ul> Fejlh\u00e5ndtering <ul> <li>Grundl\u00e6ggende forst\u00e5else for fejlh\u00e5ndtering</li> <li>Brug af try/catch/finally</li> <li>Forst\u00e5else for Exception-klassen<ul> <li>InnerException</li> </ul> </li> <li>Brug af throw-kodeordet</li> </ul> Samlinger <ul> <li>Brug af arrays</li> <li>Brug af generiske samlinger<ul> <li>List&lt;T&gt;, Dictonary&lt;TKey, TValue&gt;</li> </ul> </li> <li>Grundl\u00e6ggende brug af LINQ to objects</li> </ul> Grundl\u00e6ggende viden om OOP i C# <ul> <li>Viden om <ul> <li>Abstraktion</li> <li>Indkapsling</li> <li>Nedarvning</li> <li>Polymorfi</li> </ul> </li> <li>Brug af Interface</li> </ul> Grundl\u00e6ggende viden om delegates <ul> <li>Indbyggede delegates<ul> <li>Action</li> <li>Func</li> <li>Predicate</li> </ul> </li> <li>event-kodeordet</li> </ul> Grundl\u00e6ggende brug af asynkron kode <ul> <li>async og await</li> <li>Task og Task&lt;T&gt; klassen</li> </ul>"}]}